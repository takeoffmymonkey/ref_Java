package algorithms_datastructures.datastructures;

/*
 * hash function  - мапит ключи рандомно в слоты (индексы массива) таблицы Т (массима), т.е.
 * возвращает число, которое можно исопльзовать как индекс
 *      - т.е. hashcode() должен вернуть целое число, а затем это число будет переведено в индекс
 *          - например, k%m, где к - код, м - колво ячеек
 * - не исключено, что будет выдано одинаковое значение для разных элементов, происходит collision
 *      - чтобы разрешить, можно использовать например лист для элементов в одном слоте, т.н. chaining
 *          - load factor - отношение кол-ва элементов к кол-ву ячеек, т.е. на ratio загрузки ячеек
 *          значениями. у хештри и хешмеп оно константное (0.75), т.е. при увеличении числа элементов
 *          растет колво ячеек
 *      - либо использовать open addressing - когда хешируется значение, с ним передается еще и
 *      "пробный шаг" (напр. сначала 0) - если результат хеша приподает на ячейку с уже существующим
 *      значением, то берется следующий шаг - 1, пока не попадется свободная ячейка. тогда таблица
 *      должна быть больше и равна колву элементов. и сложно удалять. чем выше лоад фактор, тем
 *      медленнее работа: если он 0.5, то проб максимум 2, если 0.8, то уже макс 5, если 0.9, то их 10
 *
 *
 * */

public class HashTable {
}
