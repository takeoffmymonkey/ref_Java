package algorithms_datastructures.algorithms.sort;

/* QuickSort
 * - ключевая идея: элемент сортирован, если все элементы до него меньше, а после - больше
 *      - поэтому с элементом сравниваются остальные и помещаются соответственно справа или слева
 *          - правильный индекс сортированного элемента теперь известен
 *      - для левой и правой несортированных подгрупп нужно рекурсивно повторить предыдущий шаг,
 *      разбивая их до массива длиной в 1 или 0
 *
 * - алгоритм:
 *      - выбрать определенный элемент из массива
 *          - назовём его опорным
 *          - например, первый
 *      - сравниваем все элементы с опорным - все что меньше ставится перед ним, а равные или больше -
 *      после него
 *          - сортированный элемент забираем в сортированный массив, т.к. знаем его позицию
 *          - остаются 2 несортированных подмассива (слева и справа)
 *      - рекурсивно применить предыдущие шаги к подмассивам пока в массиве не останется 1 или 0
 *      элементов
 *
 * - divide and conquer
 *
 * - in-place
 *
 * - сложность:
 *      - лучшая: O(n log(n))
 *      - средняя: O(n log(n))
 *      - худшая: O(n^2) */


public class QuickSort {
}
