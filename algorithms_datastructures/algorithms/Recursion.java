package algorithms_datastructures.algorithms;

/* Рекурсия
 * - позволяет описать повторяющееся (или даже потенциально бесконечное) вычисление
 *      - при это без явных повторений части программы или циклов
 *
 * - виды:
 *      - прямая: вызов функции из нее же самой
 *      - косвенная: вызов функции через другие функции
 *          - напр. А вызывает Б, а Б вызывает А
 *      - параллельная: на одной рекурсивной ветке делается несколько рекурсивных вызовов
 *          - типична для обработки, например, деревьев
 *
 * - глубина рекурсии: количество вложенных вызовов функции
 *      - каждый вызов хранится в стек-фрейме стека вызовов
 *          - LIFO
 *          - требует определенного количества оперативной памяти
 *      - при слишком большой глубине - stackoverflow
 *
 * - обязательно требуется break condition, чтобы не было stackoverflow
 *      - т.е. на верхнем уровне есть выбор из нескольких альтернатив, одна из которых рекурсивная,
 *      а другая терминальная
 *      - но даже с ним при высоком значении может быть stackoverflow
 *
 * - теоритически может быть заменена циклом и стеком
 *      - (а цикл и стек рекурсией)
 *      - но бессмыслена, т.к. автоматическое выполнение заменяется на ручное
 *
 * - работа некоторых алгоритмов основана на рекурсии:
 *      - MergeSort, QuickSort*/


public class Recursion {
    public static void main(String[] args) {

        System.out.println(factorialIterative(5));
        System.out.println(factorialRecursive(5));


    }


    // factorial(n) = n*(n-1)*(n-2)*...1
    private static int factorialIterative(int n) {
        int result = 1;
        for (int i = 1; i <= n; i++) {
            result *= i;
        }
        return result;
    }

    // factorial(n) = n*factorial(n-1)
    private static int factorialRecursive(int n) {
        if (n == 0) return 1;
        return n * factorialRecursive(n - 1);
    }
}
