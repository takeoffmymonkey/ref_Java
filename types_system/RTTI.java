package types_system;

import _types_references_annotations.my_annotations.Ntrstn;

/* RTTI (runtime type identification) - (АВТОМАТИЧЕСКИЙ) МЕХАНИЗМ ДИНАМИЧЕСКОГО ОПРЕДЕЛЕНИЯ ТИПОВ
 * - использует в runtime информацию о типе класса, доступную при компиляции
 *      - todo для получения информации используется соответствующий:
  *         - объект Class
 *          - файл .class
 *              - используется при компиляции, например, чтобы проверить Тип.class
 *
 * - обеспечивает:
 *      - безопасность (нисходящих) преобразований типов:
 *          - чтобы при попытке привести родителя к ребенку удостоверится, что приводимый объект
 *          действительно является ребенком
 *              - иначе будет вызвано ClassCastException
 *                  - т.к. дальше было бы некорректное поведение программы и загрязнение кучи
 *
 *      - полиморфизм:
 *          - чтобы в рантайме при вызове метода по родительской ссылке вызвать метод реального типа
 *          объекта по ссылке
 *
 *      - безопасность работы с массивами
 *          - чтобы в массив нельзя было добавить несовместимые типы
 *              - такое возможно при назначении массива родительской ссылке и добавления в него
 *              родительских элементов
 *              - JVM обязана контролировать совместимость типов в массиве
 *              - иначе будет вызвано ArrayStoreException
 *                  - т.к. дальше было бы некорректное поведение программы и загрязнение кучи
 *
 *
 * - самостоятельно получить информацию о типе от RTTI можно при помощи оператора instanceof
 *      - чтобы избежать ClassCastException и ArrayStoreException
 *      - чтобы проверить, совместимы ли типы иерархически
 *      - работает только для ссылочных (в т.ч. null)
 *      - RTTI является традиционным способом получения информации о типе */


/* RTTI VS РЕФЛЕКСИЯ
 * - сходства:
 *      - позволяют во время работы программы узнавать информацию о типе объекта
 *          - для получения информации используется объект Class
 *
 * - различия:
 *      - RTTI: традиционный механизм обеспечения типовой безопасности, основанный на информации о
 *      типах, известной при компиляции
 *          - todo т.е. информация о типе класса, который существовал при компиляции
 *              - для получения информации используется:
 *                 - компилятором соответствующий файл .class
 *                 - JVM соответствующий объект Class
 *          - механизм используется автоматически для обеспечения типовой безопасности при:
 *              - приведениях (корректность приведения родителя к ребенку)
 *              - работе с массивами (корректность добавления/извлечения элементов)
 *              - полиморфизме (вызов корректного метода)
 *          - можно самостоятель узнать только информацию о типе объекта, но не о его структуре
 *
 *      - рефлексия: механизм доступа к информации о типе и структуре класса (в т.ч. внешнего)
 *          - информация о типе класса могла быть недоступной при компиляции, например:
 *              - при программировании компонентов программы
 *              - при распределенных вычислениях
 *          - для получения информации используется:
 *                 - JVM соответствующий объект Class
 *          - можно также узнать информацию о всей структуре класса
 *              - т.е. все унаследованные и синтетические/неявные члены */


@Ntrstn("Механизм динамического определения типов (RTTI) является традиционным способом получения " +
        "информации о типе объекта во время работы программы и необходим для обеспечения типовой " +
        "безопасности при операции нисходящего приведения, работы с массивами и динамической " +
        "диспетчеризации методов при полиморфизме")

@Ntrstn("Обеспечение безопасности механизмом RTTI в рантайме означает, что при возникновении " +
        "проблемы будет выброшено исключение, чтобы избежать загрязнения кучи (когда ссылка типа " +
        "ребенка ссылается на объект родительского типа)")

@Ntrstn("RTTI используется автоматически самой JVM, когда производится нисходящее преобразование, " +
        "чтобы гарантировать, что реальный объект по родительской ссылке действительно является " +
        "ребенком, прежде чем присваивать этот объект ссылке типа ребенка. Также RTTI используется, " +
        "когда в массив типа ребенка, присвоенный ссылке родительского типа, добавляется элемент " +
        "родительского типа (т.к. компилятор позволяет такое действие). В обоих случаях, чтобы " +
        "избежать загрязнения кучи (когда ссылка типа ребенка ссылается на объект родительского типа), " +
        "выбрасывается исключение во время работы программы. Кроме того, RTTI используется, чтобы " +
        "обеспечить полиморфизм и динамическое связывание при вызове метода - определяется реальный " +
        "тип объекта по ссылке и вызывается его метод")

@Ntrstn("Для избежания исключений RTTI ClassCastException (при нисходящем приведении) и " +
        "ArrayStoreException (при работе с массивом), перед тем как производить опасное действие, " +
        "можно убедится в иерархической совместимости типов при помощи оператора instanceof, однако " +
        "он работает только для ссылочных типов и null")

@Ntrstn("Механизмы рефлексии и динамического определения типа (RTTI) можно равноценно использовать " +
        "в runtime, чтобы узнать тип интересующего объекта. Для этого в RTTI можно использовать " +
        "оператор instanceof, а в рефлексии - информацию из объекта Class нужного объекта (instanceof " +
        "также использует этот объект для определения типа, а затем проверяет еще и иерархическую " +
        "совместимость (мое предположение!)). Однако, в отличие от рефлексии, RTTI имеет только " +
        "информацию о типах классов, которые были доступны еще при компиляции, а также используется " +
        "(автоматически) для обеспечения типовой безопасности при нисходящем преобразовании, при " +
        "работе с элементами массива и при вызовах полиморфных методов. В отличие от RTTI, рефлексия " +
        "не используется автоматически, и предоставляет разработчику доступ ко всем членам объекта " +
        "(в т.ч. синтетическим, которые появились после компиляции) - в runtime можно менять значения " +
        "полей, запускать нужные методы и создавать объекты при помощи конструкторов. Кроме того, " +
        "можно полноценно (а не только как с типом Object) работать с объектами классов, которые не " +
        "были доступны при компиляции, но были добавлены уже впоследствии")

public class RTTI {

    public static void main(String[] args) {
        /* ОБЕСПЕЧЕНИЕ БЕЗОПАСНОСТИ НИСХОДЯЩИХ ПРЕОБРАЗОВАНИЙ */
        Parent p = new Parent();
        Child c = new Child();
        Child2 c2 = new Child2();
        p = c; // OK: upcast
        c = (Child) p; // OK: downcast + RTTI
//        c2 = (Child2) p; // NOT OK: downcast + RTTI => ClassCastException
//        c2 = (Child2) c; // NOT OK: ошибка компилятора
//        c2 = (Child2) (Parent) c; // NOT OK: downcast + RTTI => ClassCastException


        /* ОБЕСПЕЧЕНИЕ ДИНАМИЧЕСКОГО СВЯЗЫВАНИЯ ПРИ ПОЛИМОРФИЗМЕ */
        p = c;
        p.meth(); // Child method (определен реальный тип и вызван его метод meth)


        /* ОБЕСПЕЧЕНИЕ БЕЗОПАСНОСТИ РАБОТЫ С МАССИВАМИ */
        Child[] ca = new Child[1];
//        ca[0] = new Parent(); // ошибка компиляции: нельзя добавить родительский элемент
        Parent[] pa = ca;
        pa[0] = new Child();
//        pa[0] = new Parent(); // ошибка runtime (при компиляции нет проблем): ArrayStoreException


        /* INSTANCEOF ДЛЯ ИЗБЕЖАНИЯ ИСКЛЮЧЕНИЙ */
        if (p instanceof Child2) c2 = (Child2) p;

    }
}

class Parent {
    void meth() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    void meth() {
        System.out.println("Child method");
    }
}

class Child2 extends Parent {
}