package types_references_classes.nested.inner;

import java.io.Serializable;

/* ЛОКАЛЬНЫЙ КЛАСС - ОПРЕДЕЛЕН В ЛЮБОМ БЛОКЕ КОДА
 * - простом блоке
 * - статическом блоке
 * - в методе
 * - в конструкторе
 * - блоке if, for и т.д.
 * - в перечислении
 * - в интерфейсе:
 *      - только в дефолтной имплементации метода
 *          - в других местах любые блоки кода запрещены*/


/* ИСПОЛЬЗОВАНИЕ - КЛАСС НУЖЕН ТОЛЬКО В БЛОКЕ КОДА
 * - когда нужно создавать более 1 его экземляра
 * - когда нужно иметь доступ к его конструктору (в анонимном нельзя добавлять конструктор)
 * - todo когда нужно представить новый именованный тип (потому что, напр., нужно вызывать
 * дополнительные методы потом)*/


/* СХОДСТВО С ВНУТРЕННИМ КЛАССОМ:
 * - является его особым подвидом
 * - так же не может существовать без экземпляра обрамляющего класса
 * - так же имеет доступ ко всем членам и конструкторам обрамляющего класса (в т.ч приватным)
 *      - если объявлен в статическом блоке (в т.ч. интерфейсе и перечислении) - только к
 *      статическим членам и конструкторам
 * - так же не может иметь статических членов, потому что ассоциирован с экземпляром обрамляющего
 * класса:
 *      - при этом так же может унаследовать статические члены
 *      - при этом так же может иметь статические переменные-константы */


/* ЭТО ЛОКАЛЬНАЯ ЕДИНИЦА
 * - (т.е. как и локальная переменная):
 *      - не является членом класса
 *          - полностью скрыт от внешнего кода
 *          - но может наследовать любой класс
 *              - в т.ч. статический
 *          - но может имплементировать любой интерфейс
 *      - может использоваться только после объявления
 *      - не может иметь модификаторов доступа
 *          - но его члены могут иметь любой модификатор доступа
 *      - область действия всегда ограничивается блоком, в котором он объявлен:
 *          - уничтожается после выполнения блока или оператора, в котором он был создан
 *          - может затемнять и конфликтовать с именами из обрамляющих блоков */


/* ДОСТУП
 * - имеет доступ ко всем членам и конструкторам обрамляющего класса (в т.ч. приватным и статическим)
 *      - если объявлен в статическом блоке (в т.ч. интерфейсе и перечислении) - только к
 *      статическим членам и конструкторам
 * - имеет доступ только к финализированным другим локальным переменным или параметрам
 *      - т.к. при таком обращении локальный класс захватывает переменную или параметр
 *      - с J8 может обращаться без final, если переменная или параметр эффективно финализированы:
 *          - т.е. их значение не меняется после инициализации) */


/* ОБРАЩЕНИЕ
 * - вне блока кода обратиться нельзя */


public class Local {
    int var; // есть доступ
    static int staticVar; // есть доступ
    private int privateVar; // есть доступ
    private static int privateStaticVar; // есть доступ
    int shadow;


    /*МОЖЕТ БЫТЬ В БЛОКЕ КОДА*/ {
        /*МОЖЕТ БЫТЬ РАСШИРЕНИЕМ КАКОГО-ТО КЛАССА*/
        /*МОЖЕТ РЕАЛИЗОВЫВАТЬ КАКОЙ-ТО ИНТЕРФЕЙС*/
        /*НЕ МОЖЕТ ОБЪЯВЛЯТЬ ОБ ИМПЛЕМЕНТАЦИИ КАКОГО-ТО ИНТЕРФЕЙСА*/
        class InnerLocal extends ExternalClass implements Serializable {
            /* МОЖЕТ ИМЕТЬ ТОЛЬКО НЕСТАТИЧЕСКИЕ ЧЛЕНЫ */
            int v;

            void method() {
            }

            class InnerInnerLocal { // можно объявлять внутренние классы
            }

            {
                class InnerLocal2 { // можно объявлять внутренние локальные классы
                }
            }
            // static int v2;
            // static void meth () {}
            // static class StaticInner {}
            // enum InnerEnum {ONE, TWO}
            // interface InnerInterface {}

            /*МОЖЕТ УНАСЛЕДОВАТЬ СТАТИЧЕСКИЕ ЧЛЕНЫ*/
            void m() {
                staticExtVar = 2;
                staticExtMeth();
            }

            /* МОЖЕТ ИМЕТЬ ПЕРЕМЕННЫЕ-КОНСТАНТЫ*/
            final static int v4 = 34 + 54;


            /* ЕСТЬ ДОСТУП КО ВСЕМУ ИЗ ОБРАМЛЯЮЩЕГО КЛАССА*/
            /* ЧЛЕНЫ МОГУТ ИМЕТЬ ЛЮБОЙ МОДИФИКАТОР ДОСТУПА*/
            private int anVar = var;
            protected int anVar2 = staticVar;
            public int anInt3 = privateVar;
            int anInt4 = privateStaticVar;
            Local local = new Local();
            Local local2 = new Local(3);
            MyEnum myEnum = MyEnum.ONE;
            MyInterface myInterface = new MyInterface() {
            };
            /*МОЖЕТ ПРОИСХОДИТЬ ЗАТЕМНЕНИЕ*/
            int shadow = 5; // затемняет shadow из внешней области
        }


        /* МОЖНО ИСПОЛЬЗОВАТЬ ТОЛЬКО ПОСЛЕ ОБЪЯВЛЕНИЯ */
        InnerLocal innerLocal = new InnerLocal();
        innerLocal.m();


        /* МОЖЕТ БЫТЬ В ЛЮБОМ БЛОКЕ, НАПР. IF*/
        if (true) {
            class InnerLocal2 {
            }
        }
    }


    /* МОЖЕТ БЫТЬ В СТАТИЧЕСКОМ БЛОКЕ КОДА */
    static {
        class InnerLocal {
            /* В СТАТИЧЕСКОМ БЛОКЕ ДОСТУП ЕСТЬ ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ И КОНСТРУКТОРАМ */
            // int v = var;
            int v2 = staticVar;
            Local anonymous = new Local();
            Local anonymous2 = new Local(3);
        }
    }


    /* МОЖЕТ БЫТЬ В КОНСТРУКТОРЕ */
    public Local() { // есть доступ
        class InnerLocal {
        }
    }


    /* ИМЕЕТ ДОСТУП ТОЛЬКО К (ЭФФЕКТИВНО) ФИНАЛИЗИРОВАННЫМ ДРУГИМ ЛОКАЛЬНЫМ ПЕРЕМЕННЫМ И ПАРАМЕТРАМ*/
    private Local(int parameter) { // есть доступ
        int localVar = 0;
//        localVar = 6; // не должно меняться или должно быть финализировано
        {
            class InnerLocal {
                int v = localVar;
                int v2 = parameter;
            }
        }
    }


    /* МОЖЕТ БЫТЬ В МЕТОДЕ */
    void meth() { // есть доступ
        class InnerLocal {
        }
    }


    /* В ИНТЕРФЕЙСЕ МОЖЕТ БЫТЬ ТОЛЬКО МЕТОДЕ С ДЕФОЛТНОЙ ИМПЛЕМЕНТАЦИЕЙ */
    interface MyInterface { // есть доступ
        default void meth() {
            class MyInterfaceInnerLocal {
                /* В СТАТИЧЕСКОМ БЛОКЕ ДОСТУП ЕСТЬ ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ И КОНСТРУКТОРАМ */
                // int v = var;
                int v2 = staticVar;
                Local anonymous = new Local();
                Local anonymous2 = new Local(3);
            }
        }
    }


    /* МОЖЕТ БЫТЬ В ПЕРЕЧИСЛЕНИИ */
    enum MyEnum { // есть доступ
        ONE, TWO;

        {
            class InnerLocal {
                /* В СТАТИЧЕСКОМ БЛОКЕ ДОСТУП ЕСТЬ ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ И КОНСТРУКТОРАМ */
                // int v = var;
                int v2 = staticVar;
                Local anonymous = new Local();
                Local anonymous2 = new Local(3);
            }
        }
    }
}


class ExternalClass {
    static int staticExtVar;

    static void staticExtMeth() {
    }
}