package types_references_classes.nested.inner;

import types_references_annotations.my_annotations.Ntrstn;


/*ВНУТРЕННИЙ КЛАСС - КЛАСС БЕЗ МОДИФИКАТОРА STATIC, ВЛОЖЕННЫЙ В ДРУГОЙ КЛАСС */


/* ИСПОЛЬЗОВАНИЕ
 * - когда нужен доступ к непубличным полям или методам обрамляющего класса */


/* ДОПОЛНИТЕЛЬНЫЕ (ОСОБЫЕ) ВИДЫ (ВЕДУТ СЕБЯ ИНАЧЕ)
 * - локальный: внутри блока кода (класс нужен только там)
 * - анонимный: внутри блока кода, но без имени (переопределенный класс нужен одноразово) */


/* КАК ВСЕ ВЛОЖЕННЫЕ
 * - являются членами обрамляющего класса (т.е. наследуются)
 *      - вложенный класс может имплементировать любой интерфейс
 *      - вложенный класс может наследовать любой класс
 *          - в т.ч. нестатическим статический
 *      - вложенный класс можно наследовать отдельно
 *          - в т.ч. нестатическим статический
 * - как и другие члены, могут иметь любые модификаторы доступа
 *      - члены вложенных классов могут иметь любые модификаторы доступа
 *      - в интерфейсе автоматически становится статическим открытым
 * - все это не относится к внутренним локальным, анонимным и лямбда-выражениям */


/*ВНУТРЕННИЕ ЛОКАЛЬНЫЕ, АНОНИМНЫЕ И ЛЯМБДА-ВЫРАЖЕНИЯ ЯВЛЯЮТСЯ ЛОКАЛЬНЫМИ ЭЛЕМЕНТАМИ
 * - т.е. не являются членами (т.е. не наследуются), НО:
 *      - могут имплементировать любой интерфейс
 *      - могут наследовать любой класс
 *          - в т.ч. статический
 * - не могут иметь модификатор доступа
 *      - но их члены могут иметь любой модификатор доступа
 * - могут использоваться только после объявления*/


/* НАСЛЕДОВАНИЕ
 * - может быть унаследован отдельно только другим нестатическим классом*/


/* ДОСТУП
 * - внутренний класс имеет прямой доступ:
 *      - ко всем конструкторам обрамляющего класса
 *          - в т.ч. к приватным!!
 *      - ко всем членам обрамляющего класса:
 *          - в т.ч. к приватным!!
 *          - в т.ч. к статическим!!
 *
 * - обрамляющий класс не имеет прямого доступа к членам вложенного класса */


/* НЕ МОЖЕТ СУЩЕСТВОВАТЬ БЕЗ ЭКЗЕМПЛЯРА ОБРАМЛЯЮЩЕГО КЛАССА
 * - компилятор автоматически добавляет в конструктор внутреннего класса параметр для ссылки на
 * экземпляр обрамляющего класса */


/* ОБРАЩЕНИЕ
 * - из внутреннего к обрамляющему:
 *      - только из нестатического контекста:
 *          - либо по имени
 *          - либо через ИмяОбрамляющегоКласса.this.поле/метод (в случае затемнения)
 * - к внутреннему из обрамляющего:
 *      - из нестатического контекста:
 *          - через объект внутреннего
 *      - из статического контекста:
 *          - через объект внутреннего, привязанный к объекту обрамляющего
 * - к внутреннему извне обрамляющего:
 *      - из статического и нестатического контекста:
 *          - через объект внутреннего, привязанный к объекту обрамляющего */


/* НЕ МОЖЕТ ИМЕТЬ СТАТИЧЕСКИХ ЧЛЕНОВ
 * - т.к. ассоциирован с экземпляром обрамляющего класса
 * - в т.ч. не может иметь перечислений и интерфейсов (т.к. это статические члены)
 * - !! но может их унаследовать
 * - !! также может иметь переменные-константы:
 *      - это переменные-примитивы или String, которые объявлены как final и инициализированы
 *      константным выражением во время компиляции (т.е. может быть проверено во время компиляции):
 *          - напр. 3 + 5, или "стро" + "ка"
 *      - todo это как-то связанно с замыканием
 *      - todo несмотря на то, что предполагается получить однозначный экземпляр статического поля,
 *      для каждого внешнего объекта имеется отдельный экземпляр внутреннего класса. Если бы поле
 *      не было конечным, оно могло бы и не стать однозначным*/


/* МОЖЕТ НАХОДИТСЯ В ЛЮБОМ (В Т.Ч. СТАТИЧЕСКОМ) БЛОКЕ ОБРАМЛЯЮЩЕГО КЛАССА
 * - (хоть в for)*/


/* ДРУГИЕ ОСОБЕННОСТИ
 * - обращение с внутренними классами происходит на уровне компилятора, а не JVM. Для их обозначения
 * используется знак $, разделяющий имена внешних и внутренних классов. В результате компиляции
 * получаются 2 класса Main и Main$Inner. Таким образом, для JVM внутренние классы неотличимы от
 * внешних
 *
 * - todo сериализация любых внутренних классов не приветствуется (из-за разных имплементаций компилятором
 * синтетических конструкций (для классов, методов, членов и т.д. - нужны, чтоб не трогать код JVM
 * при новых фичах) может возникнуть проблемы совместимости при обратной десериализации в другом JRE) */



/*ИмяКласса.this ссылка на обрамляющий*/
/*ссылкаНаОбрамляющий.new */
/* */

@Ntrstn("компилятор автоматически добавляет в конструктор внутреннего класса параметр для ссылки на " +
        "экземпляр обрамляющего класса")
@Ntrstn("внутренние классы не могут иметь статические члены, но могут иметь static final константы " +
        "времени копмиляции или могут унаследовать статические члены")
public class InnerMain {
    int var; // есть доступ
    static int staticVar; // есть доступ
    private int privateVar; // есть доступ
    private static int privateStaticVar; // есть доступ

    /*ВНУТРЕННИЙ МОЖЕТ БЫТЬ В ЛЮБОМ БЛОКЕ (ТОГДА ОН СТАНОВИТСЯ ЛОКАЛЬНЫМ ИЛИ АНОНИМНЫМ) */ {
        for (int i = 0; i < 1; i++) {
            class InnerClassLoop { // может быть даже в цикле
            }
            /*ВНУТРЕННИЙ ЛОКАЛЬНЫЙ, АНОНИМНЫЙ И ЛЯМБДА НЕ МОЖЕТ ИМЕТЬ МОДИФИКАТОР ДОСТУПА*/
//            public class InnerClassLoop2 {
//            }
        }
    }

    public InnerMain() { // есть доступ
    }

    private InnerMain(int var) { // есть доступ
    }

    void meth() { // есть доступ
        /* ОБРАЩЕНИЕ К ВНУТРЕННЕМУ ИЗ ОБРАМЛЯЮЩЕГО ИЗ НЕСТАТИЧЕСКОГО КОНТЕКСТА */
        MyInnerClass myInnerClass = new MyInnerClass();
        myInnerClass.innerMeth(); // через объект внутреннего
    }

    static void staticMeth() { // есть доступ
    }

    private void privateMeth() { // есть доступ
    }

    private static void privateStaticMeth() { // есть доступ
    }

    /*ВОЗМОЖНЫЕ УРОВНИ ДОСТУПА - ТАКИЕ ЖЕ КАК И ДРУГИХ ЧЛЕНОВ*/
    public class MyInnerClass {
        /* КОМПИЛЯТОР АВТОМАТИЧЕСКИ ЗАДАЕТ В КОНСТРУКТОРЕ ССЫЛКУ НА ЭКЗЕМПЛЯР ОБРАМЛЯЮЩЕГО КЛАССА*/
        public MyInnerClass() {
        }


        /* ЕСТЬ ДОСТУП КО ВСЕМ КОНСТРУКТОРАМ И ВСЕМ ЧЛЕНАМ
         * - в т.ч. приватным!!*/
        void innerMeth() {
            /* ОБРАЩЕНИЕ К ОБРАМЛЯЮЩЕМУ КЛАССУ ИЗ ВНУТРЕННЕГО */
            int innerVar3 = var; // напрямую по имени
            int innerVar = staticVar;
            int innerVar2 = privateStaticVar; // есть доступ к приватным членам
            new InnerMain(); // есть доступ к конструктору
            new InnerMain(3); // есть доступ к приватному конструктору
            InnerMain.this.meth(); // через ОбрамляющийКласс.this.поле/метод
            privateMeth();
            staticMeth();
            privateStaticMeth();
        }

        /* МОЖЕТ ИМЕТЬ ТОЛЬКО НЕ СТАТИЧЕСКИЕ ЧЛЕНЫ */
        int innerVar;
        //        static int innerStaticVar;
//        enum InnerEnum {} // enum - статический элемент
//        interface InnerInterface { } // interface - статический элемент


        /* СТАТИЧЕСКИЕ ЧЛЕНЫ МОГУТ БЫТЬ УНАСЛЕДОВАНЫ*/
        class MyInnerInnerClass extends InnerMain {
            void meth2() {
                staticVar = 4;
            }
        }


        /* МОЖЕТ ИМЕТЬ КОНСТАНТЫ ВРЕМЕНИ КОМПИЛЯЦИИ - НАПР. STATIC FINAL ПОЛЯ*/
        static final int innerStaticVar = 2; // значение известно при компиляции
        static final String innerStaticVar2 = "стр" + "ока"; // значение известно при компиляции
//        static final Integer innerStaticVar3 = 2; // значение неизвестно при компиляции
//        static final int staticFinal() { }; // только поля, не методы
    }


    /*МОЖЕТ БЫТЬ УНАСЛЕДОВАН ОТДЕЛЬНО ПРОСТЫМ КЛАССОМ*/
    class InnerChild extends MyInnerClass {
    }

    /*НЕ МОЖЕТ БЫТЬ УНАСЛЕДОВАН ОТДЕЛЬНО СТАТИЧЕСКИМ КЛАССОМ*/
//    static class StaticInnerClass extends Main.MyInnerClass {
//    }


    /* МОЖЕТ БЫТЬ В ПЕРЕЧИСЛЕНИИ */
    enum MyEnum {
        ONE, TWO;

        class EnumInnerClass {
            int enumVar;

            void enumMeth() {
            }
        }
    }

    public static void main(String[] args) {
        /*ОБРАЩЕНИЕ К ВНУТРЕННЕМУ КЛАССУ ИЗ ОБРАМЛЯЮЩЕГО В СТАТИЧЕСКОМ КОНТЕКСТЕ*/
        InnerMain.MyInnerClass myInnerClass = new InnerMain().new MyInnerClass();
        myInnerClass.innerMeth(); // через объект внутреннего класса, привязанный к объекту обрамляющего
        MyEnum.ONE.new EnumInnerClass().enumMeth(); // через объект внутреннего класса, привязанный к объекту обрамляющего
    }
}


class AnotherClass {
    void method() {
        /*ОБРАЩЕНИЕ К ВНУТРЕННЕМУ КЛАССУ ИЗВНЕ ОБРАМЛЯЮЩЕГО В НЕСТАТИЧЕСКОМ КОНТЕКСТЕ */
        InnerMain.MyInnerClass myInnerClass = new InnerMain().new MyInnerClass();
        myInnerClass.innerMeth(); // через объект внутреннего класса, привязанный к объекту обрамляющего
    }

    public static void main(String[] args) {
        /*ОБРАЩЕНИЕ К ВНУТРЕННЕМУ КЛАССУ ИЗВНЕ ОБРАМЛЯЮЩЕГО В СТАТИЧЕСКОМ КОНТЕКСТЕ*/
        InnerMain.MyInnerClass myInnerClass = new InnerMain().new MyInnerClass(); // автоматическая привязка
        myInnerClass.innerMeth(); // через объект внутреннего класса, привязанный к объекту обрамляющего


        /* ВНУТРЕННИЕ КЛАССЫ, ОПРЕДЕЛЕННЫЕ В ИНТЕРФЕЙСАХ, АВТОМАТИЧЕСКИ СЧИТАЮТСЯ static public */
        SomeInterface.InterfaceInnerClass interfaceInnerClass = new SomeInterface.InterfaceInnerClass();
        int v = interfaceInnerClass.var;
        int v2 = SomeInterface.InterfaceInnerClass.var2;
    }
}

interface SomeInterface {
    /* АВТОМАТИЧЕСКИ СТАНОВИТСЯ СТАТИЧЕСКИМ ОТКРЫТЫМ*/
    class InterfaceInnerClass {
        int var = 4;
        static int var2 = 4;
    }
}