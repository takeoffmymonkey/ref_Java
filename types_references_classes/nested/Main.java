package types_references_classes.nested;

import types_references_annotations.my_annotations.Ntrstn;


/* ВЛОЖЕННЫЙ КЛАСС - КЛАСС ВНУТРИ ДРУГОГО КЛАССА */


/* ИСПОЛЬЗОВАНИЕ
 * - похож на локальный:
 *      - когда нужно создавать более 1 его экземляра
 *      - когда нужно иметь доступ к его конструктору (напр. в анонимном нельзя добавлять конструктор)
 *      - todo когда нужно представить новый именованный тип (потому что, напр., нужно вызывать
 *      дополнительные методы потом)
 * - но класс нужен более доступный (не только в там, где он объявлен)
 * - и не нужен доступ к локальным переменным или параметрам метода (он есть у локальных и анонимных)*/


/* ВИДЫ
 * - статический: с модификатором static
 *
 * - нестатический (внутренний): без модификатора static
 *      - ДОПОЛНИТЕЛЬНЫЕ (ОСОБЫЕ) подвиды: ведут себя иначе
 *          - локальный: внутри блока кода (класс нужен только там)
 *          - анонимный: внутри блока кода, но без имени (переопределенный класс нужен одноразово)*/


/* ОСОБЕННОСТИ ВЛОЖЕННЫХ КЛАССОВ
 * - являются членами обрамляющего класса (т.е. наследуются)
 *      - вложенный класс может имплементировать любой интерфейс
 *      - вложенный класс может наследовать любой класс
 *          - в т.ч. нестатическим статический
 *      - вложенный класс можно наследовать отдельно
 *          - в т.ч. нестатическим статический
 * - как и другие члены, могут иметь любые модификаторы доступа
 *      - члены вложенных классов могут иметь любые модификаторы доступа
 *      - в интерфейсе автоматически становится статическим открытым
 * - все это не относится к внутренним локальным, анонимным и лямбда-выражениям */


/*ВНУТРЕННИЕ ЛОКАЛЬНЫЕ, АНОНИМНЫЕ И ЛЯМБДА-ВЫРАЖЕНИЯ ЯВЛЯЮТСЯ ЛОКАЛЬНЫМИ ЭЛЕМЕНТАМИ
 * - т.е. не являются членами (т.е. не наследуются), НО:
 *      - могут имплементировать любой интерфейс
 *      - могут наследовать любой класс
 *          - в т.ч. статический
 * - не могут иметь модификатор доступа
 *      - но их члены могут иметь любой модификатор доступа
 * - могут использоваться только после объявления*/


/* СТАТИЧЕСКИЙ
 * - имеет модификатор static
 * - может находится только на уровне других членов обрамляющего класса
 * - может существовать независимо от экземпляра обрамляющего класса
 * - обращение извне происходит через имя обрамляющего класса
 * - может иметь и статические члены и нестатические
 * - обрамляющий класс имеет непрямой (через имя) доступ к статическим членам
 * - имеет прямой доступ ко всем конструкторам и только к статическим членам обрамляющего класса:
 *      - в т.ч. к приватным статическим */


/* НЕСТАТИЧЕСКИЙ (ВНУТРЕННИЙ)
 * - не имеет модификатор static
 * - может находится в любом блоке (в т.ч. статическом) обрамляющего класса (хоть в for)
 * - не может существовать независимо от экземпляра обрамляющего класса
 * - обращение извне происходит через экземпляр обрамляющего класса
 * - не может иметь статических членов (т.к. ассоциирован с экземпляром обрамляющего класса)
 * - обрамляющий класс не имеет прямого доступа к членам внутреннего класса
 * - имеет прямой доступ ко всем членам и конструкторам обрамляющего класса:
 *      - в т.ч. к статическим
 *      - в т.ч. к приватным */


/* УДОБСТВО ИСПОЛЬЗОВАНИЯ
 * - логическая группировка классов, используемых только в одном месте ("машина", "двигатель")
 * - улучшение инкапсуляции (нужные "двигателю" элементы "машины" могут оставаться private)*/


@Ntrstn("внутренние классы можно объявлять в любом блоке, даже в блоке for")
@Ntrstn("внутренние классы можно объявлять даже в интерфейсе (автоматически становится public static)")
public class Main {
    int var;
    static int staticVar;
    private int privateVar;
    private static int privateStaticVar;

    public Main() {
    }

    private Main(int var) {
    }

    /*ВНУТРЕННИЙ МОЖЕТ БЫТЬ В ЛЮБОМ БЛОКЕ*/ {
        for (int i = 0; i < 1; i++) {
            /* ЛОКАЛЬНЫЙ КЛАСС */
            class InnerClassLoop { // может быть даже в цикле
            }
            /*ВНУТРЕННИЙ ЛОКАЛЬНЫЙ, АНОНИМНЫЙ И ЛЯМБДА НЕ МОЖЕТ ИМЕТЬ МОДИФИКАТОР ДОСТУПА*/
//            public class InnerClassLoop2 {
//            }
        }
    }

    /*ВНУТРЕННИЙ МОЖЕТ БЫТЬ И СТАТИЧЕСКОМ БЛОКЕ*/
    static {
        class InnerClass {
        }
    }

    void meth() {
    }

    static void staticMeth() {
    }

    private void privateMeth() {
    }

    private static void privateStaticMeth() {
    }

    /*ВОЗМОЖНЫЕ УРОВНИ ДОСТУПА - ТАКИЕ ЖЕ КАК И ДРУГИХ ЧЛЕНОВ*/
    protected class Inner {
        /*ЕСТЬ ДОСТУП КО ВСЕМ ЧЛЕНАМ И К КОНСТРУКТОРАМ
         * - в т.ч. статическим и приватным */
        /* У ЧЛЕНОВ ВЛОЖЕННЫХ ТАКЖЕ ЛЮБЫЕ УРОВНИ ДОСТУПА */
        private void innerMeth() {
            int innerVar = var;
            int innerVar2 = staticVar;
            int innerVar3 = privateVar;
            int innerVar4 = privateStaticVar;
            new Main();
            new Main(3);
            meth();
            privateMeth();
            staticMeth();
            privateStaticMeth();
        }

        int innerVar;
        // у внутреннего класса не может быть статических членов
    }

    static class StaticInner {
        /*ЕСТЬ ДОСТУП ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ И К КОНСТРУКТОРАМ
         * - в т.ч. приватным*/
        void innerMeth() {
            int innerVar = staticVar;
            int innerVar2 = privateStaticVar;
            new Main();
            new Main(3);
            staticMeth();
            privateStaticMeth();
        }

        int innerVar;
        static int innerStaticVar;
    }


    /*ВЛОЖЕННЫЙ КЛАСС МОЖНО НАСЛЕДОВАТЬ ОТДЕЛЬНО
     * - в т.ч. статический нестатическим*/
    class InnerChild extends Inner {

    }

    /* НЕСТАТИЧЕСКИЙ НАСЛЕДУЕТ СТАТИЧЕСКИЙ*/
    class StaticInnerChild extends StaticInner {

    }

    public static void main(String[] args) {
        /*НЕТ ПРЯМОГО ДОСТУПА К ЧЛЕНАМ ВНУТРЕННЕГО КЛАССА*/
        //        innerVar;


        /*ЕСТЬ НЕПРЯМОЙ ДОСТУП К СТАТИЧЕСКИМ ЧЛЕНАМ ВЛОЖЕННОГО СТАТИЧЕСКОГО КЛАССА*/
        System.out.println(StaticInner.innerStaticVar); //
//        System.out.println(StaticInner.innerVar);
    }
}

class MainSon extends Main {
    /*НАСЛЕДУЕТСЯ*/
    void mainSonMeth() {
        Inner inner = new Inner();
        StaticInner inner1 = new StaticInner();
    }
}

class AnotherClass {
    public static void main(String[] args) {
        /*ВНУТРЕННИЙ НЕ МОЖЕТ СУЩЕСТВОВАТЬ НЕЗАВИСИМО ОТ ЭКЗЕМПЛЯРА ОБРАМЛЯЮЩЕГО КЛАССА*/
        Main.Inner inner = new Main().new Inner(); // сначала создается экземпляр обрамляющего


        /*ВЛОЖЕННЫЙ СТАТИЧЕСКИЙ МОЖЕТ СУЩЕСТВОВАТЬ НЕЗАВИСИМО ОТ ЭКЗЕМПЛЯРА ОБРАМЛЯЮЩЕГО КЛАССА*/
        Main.StaticInner staticInner = new Main.StaticInner(); // сразу создается нужный объект


        /*К СТАТИЧЕСКИМ ЧЛЕНАМ СТАТИЧЕСКОГО КЛАССА ЕСТЬ НЕПРЯМОЙ ДОСТУП ВНЕ ОБРАМЛЯЮЩЕГО КЛАССА*/
        int var = Main.StaticInner.innerStaticVar; // есть доступ


        /* ВНУТРЕННИЕ КЛАССЫ, ОПРЕДЕЛЕННЫЕ В ИНТЕРФЕЙСАХ, АВТОМАТИЧЕСКИ СЧИТАЮТСЯ static public */
        SomeInterface.InterfaceInnerClass interfaceInnerClass = new SomeInterface.InterfaceInnerClass();
    }
}


interface SomeInterface {
    /* АВТОМАТИЧЕСКИ СТАНОВИТСЯ СТАТИЧЕСКИМ ОТКРЫТЫМ*/
    class InterfaceInnerClass {
        int var = 4;
        static int var2 = 4;
    }
}