package types_references_classes.nested.static_;

import types_references_annotations.my_annotations.Ntrstn;

/*СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС - КЛАСС С МОДИФИКАТОРОМ STATIC, ВЛОЖЕННЫЙ В ДРУГОЙ КЛАСС*/


/* СТАТИЧЕСКИЕ КЛАССЫ ВЕРХНЕГО УРОВНЯ ЗАПРЕЩЕНЫ
 * - а статический вложенный ведет себя как обычный класс верхнего уровня, вложенный в другой класс
 * верхнего уровня просто для удобства */


/* ИСПОЛЬЗОВАНИЕ
 * - когда не нужен доступ к непубличным полям или методам обрамляющего класса */


/* КАК ВСЕ ВЛОЖЕННЫЕ
 * - являются членами обрамляющего класса (т.е. наследуются)
 *      - вложенный класс может имплементировать любой интерфейс
 *      - вложенный класс может наследовать любой класс
 *          - в т.ч. нестатическим статический
 *      - вложенный класс можно наследовать отдельно
 *          - в т.ч. нестатическим статический
 * - как и другие члены, могут иметь любые модификаторы доступа
 *      - члены вложенных классов могут иметь любые модификаторы доступа
 *      - в интерфейсе автоматически становится статическим открытым */


/* НАСЛЕДОВАНИЕ
 * - может быть унаследован отдельно другим статическим и нестатическим классом*/


/* ДОСТУП
 * - вложенный статический класс имеет прямой доступ:
 *      - ко всем конструкторам обрамляющего класса
 *          - в т.ч. к приватным!!
 *      - только к статическим членам обрамляющего класса:
 *          - в т.ч. к приватным статическим!!
 *
 * - обрамляющий класс имеет непрямой (через имя) доступ:
 *      - только к статическим членам вложенного статического класса */


/* ВЕДЕТ СЕБЯ КАК ОБЫЧНЫЙ ВЫСОКОУРАВНЕВЫЙ СТАТИЧЕСКИЙ КЛАСС
 *  - может существовать независимо от экземпляра обрамляющего класса
 *  - применяется, когда доступ к обрамляющему классу не требуется
 *      - напр. "машина" и "аккумулятор": "аккумулятор* можно подключать к другим устройствам */


/* ОБРАЩЕНИЕ
 * - из статического вложенного к обрамляющему
 *      - из статического и нестатического контекста:
 *          - можно только к статическим:
 *              - напрямую по имени
 *              - либо через ИмяОбрамляющего.поле/метод (в случае затемнения)
 *
 * - к статическому вложенному из обрамляющего:
 *      - из статического и нестатического контекста:
 *          - к статическим элементам:
 *              - через имя статического вложенного класса
 *          - к нестатическим элементам:
 *              - через объект статического вложенного класса
 *
 * - к статическому вложенному извне обрамляющего
 *      - из статического и нестатического контекста:
 *          - к статическим элементам - через ИмяОбрамляющего.ИмяСтатическогоВложенного
 *          - к нестатическим элементам - через объект ИмяОбрамляющего.ИмяСтатическогоВложенного */


/* МОЖЕТ ИМЕТЬ СТАТИЧЕСКИЕ И НЕ СТАТИЧЕСКИЕ ЧЛЕНЫ
 * - в т.ч. интерфейсы и перечисления*/


/* МОЖЕТ НАХОДИТСЯ ТОЛЬКО НА УРОВНЕ ДРУГИХ ЧЛЕНОВ ОБРАМЛЯЮЩЕГО КЛАССА */


/* КЛАСС ВЕРХНЕГО УРОВНЯ НЕ МОГУТ БЫТЬ СТАТИЧЕСКИМИ */
//static class Static {
//}

@Ntrstn("Статические классы верхнего уровня запрещены. Статический класс может быть только вложенным " +
        "и ведет себя как класс верхнего уровня, вложенный в другой класс верхнего уровня для " +
        "удобства.")

@Ntrstn("Для создания вложенного класса не нужен объект внешнего")

@Ntrstn("Нельзя обращаться к членам (нестатическим?) нестатического объекта внешнего класса из " +
        "объекта вложенного класса")

@Ntrstn("В отличие от внутренних классов, поля и методы могут быть static")

@Ntrstn("Любой внутренний класс, помещенный в интерфейс, автоматически становится public и static, " +
        "т.е. вложенным")

@Ntrstn("Вложенный в интерфейс класс может быть реализацией этого интерфейса")

@Ntrstn("Также как и внутренний, имеет доступ ко всем членам обрамляющего класса. (Если нужен " +
        "доступ к нестатическим членам, тогда через объект обрамляющего)")

public class Main {
    int var; // нет доступа
    static int staticVar; // есть доступ
    private int privateVar; // нет доступа
    private static int privateStaticVar; // есть доступ


    public Main() { // есть доступ
    }

    private Main(int var) { // есть доступ
    }

    void meth() { // нет доступа
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ НЕСТАТИЧЕСКОГО КОНТЕКСТА ОБРАМЛЯЮЩЕГО */
        int v = StaticInner.innerStaticVar; // к статическим элементам - через имя статического вложенного
        new StaticInner().innerStaticMeth(); // к нестатическим элементам - через объект статического вложенного
    }

    static void staticMeth() { // есть доступ
    }

    private void privateMeth() { // нет доступа
    }

    private static void privateStaticMeth() { // есть доступ
    }

    /*ВОЗМОЖНЫЕ УРОВНИ ДОСТУПА - ТАКИЕ ЖЕ КАК И ДРУГИХ ЧЛЕНОВ*/
    public static class StaticInner {
        /* ЕСТЬ ДОСТУП КО ВСЕМ КОНСТРУКТОРАМ И ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ*/

        /* ОБРАЩЕНИЕ К ОБРАМЛЯЮЩЕМУ КЛАССУ ИЗ НЕСТАТИЧЕСКОГО КОНТЕКСТА ВЛОЖЕННОГО СТАТИЧЕСКОГО*/
        void meth() {
            int innerVar = staticVar; // обращение напрямую по имени
            int innerVar2 = privateStaticVar; // есть доступ к приватным членам
            new Main(); // есть доступ к конструктору
            new Main(3); // есть доступ к приватному конструктору
            privateStaticMeth();
            Main.staticMeth();  // через ИмяОбрамляющего.поле/метод
        }

        /* ОБРАЩЕНИЕ К ОБРАМЛЯЮЩЕМУ КЛАССУ ИЗ СТАТИЧЕСКОГО КОНТЕКСТА ВЛОЖЕННОГО СТАТИЧЕСКОГО*/
        static void innerStaticMeth() {
            privateStaticMeth(); // напрямую по имени
            Main.staticMeth(); // либо через ИмяОбрамляющего.поле/метод
        }

        /* МОЖЕТ ИМЕТЬ СТАТИЧЕСКИЕ И НЕСТАТИЧЕСКИЕ ЧЛЕНЫ */
        int innerVar;
        static int innerStaticVar;

        enum InnerEnum {} // в т.ч. enum

        interface InnerInterface {
        } // в т.ч. interface

    }


    /*МОЖЕТ БЫТЬ УНАСЛЕДОВАН ОТДЕЛЬНО ПРОСТЫМ КЛАССОМ*/
    class StaticInnerChild extends StaticInner {
    }


    /*МОЖЕТ БЫТЬ УНАСЛЕДОВАН ОТДЕЛЬНО СТАТИЧЕСКИМ КЛАССОМ*/
    static class StaticStaticInnerChild extends StaticInner {
    }

    /* МОЖЕТ БЫТЬ В ПЕРЕЧИСЛЕНИИ */
    enum MyEnum {
        ONE, TWO;

        static class EnumInnerClass {
            int enumVar;

            static void enumMeth() {
            }
        }
    }

    public static void main(String[] args) {
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ СТАТИЧЕСКОГО КОНТЕКСТА ОБРАМЛЯЮЩЕГО*/
        int v = StaticInner.innerStaticVar; // к статическим элементам - через имя статического вложенного
        new StaticInner().meth(); // к нестатическим элементам - через объект статического вложенного
        MyEnum.EnumInnerClass.enumMeth(); // к статическим элементам - через имя статического вложенного
        int v2 = new MyEnum.EnumInnerClass().enumVar; // к нестатическим элементам - через объект статического вложенного
    }
}


class AnotherClass {
    void meth() { // нет доступа
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ НЕСТАТИЧЕСКОГО КОНТЕКСТА ВНЕ ОБРАМЛЯЮЩЕГО */
        int v = Main.StaticInner.innerStaticVar; // к статическим элементам - через ИмяОбрамляющего.ИмяСтатическогоВложенного
        new Main.StaticInner().meth(); // к нестатическим элементам - через объект ИмяОбрамляющего.ИмяСтатическогоВложенного
    }

    public static void main(String[] args) {
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ СТАТИЧЕСКОГО КОНТЕКСТА ВНЕ ОБРАМЛЯЮЩЕГО */
        int v = Main.StaticInner.innerStaticVar; // к статическим элементам - через ИмяОбрамляющего.ИмяСтатическогоВложенного
        new Main.StaticInner().meth(); // к нестатическим элементам - через объект ИмяОбрамляющего.ИмяСтатическогоВложенного


        /*ВЛОЖЕННЫЙ СТАТИЧЕСКИЙ МОЖЕТ СУЩЕСТВОВАТЬ НЕЗАВИСИМО ОТ ЭКЗЕМПЛЯРА ОБРАМЛЯЮЩЕГО КЛАССА*/
        Main.StaticInner staticInner = new Main.StaticInner(); // сразу создается нужный объект


        /* ВНУТРЕННИЕ КЛАССЫ, ОПРЕДЕЛЕННЫЕ В ИНТЕРФЕЙСАХ, АВТОМАТИЧЕСКИ СЧИТАЮТСЯ static public */
        SomeInterface.InterfaceInnerClass interfaceInnerClass = new SomeInterface.InterfaceInnerClass();
    }
}

interface SomeInterface {
    /* АВТОМАТИЧЕСКИ СТАНОВИТСЯ СТАТИЧЕСКИМ ОТКРЫТЫМ*/
    class InterfaceInnerClass {
        int var = 4;
        static int var2 = 4;
    }
}