package types_references_classes.classes_inside.inner;

import java.io.Serializable;

import types_references_annotations.my_annotations.Ntrstn;

/* ЛОКАЛЬНЫЙ КЛАСС - ОПРЕДЕЛЕН В ЛЮБОМ БЛОКЕ КОДА
 * - простом блоке
 * - статическом блоке
 * - в методе
 * - в конструкторе
 * - блоке if, for и т.д.
 * - в перечислении
 * - в интерфейсе:
 *      - только в дефолтной имплементации метода
 *          - в других местах любые блоки кода запрещены*/


/* СХОДСТВО С ВНУТРЕННИМ КЛАССОМ:
 * - является его особым подвидом
 * - так же не может существовать без экземпляра обрамляющего класса
 * - так же имеет доступ ко всем членам и конструкторам обрамляющего класса (в т.ч приватным)
 *      - если объявлен в статическом блоке (в т.ч. интерфейсе и перечислении) - только к
 *      статическим членам и конструкторам
 * - так же не может иметь статических членов, потому что ассоциирован с экземпляром обрамляющего
 * класса:
 *      - при этом так же может унаследовать статические члены
 *      - при этом так же может иметь статические переменные-константы */


/* ЭТО ЛОКАЛЬНАЯ ЕДИНИЦА
 * - (т.е. как и локальная переменная):
 *      - не является членом класса
 *          - полностью скрыт от внешнего кода
 *          - но может наследовать любой класс
 *              - в т.ч. статический
 *          - но может имплементировать любой интерфейс
 *      - может использоваться только после объявления
 *      - не может иметь модификаторов доступа
 *          - но его члены могут иметь любой модификатор доступа
 *      - область действия всегда ограничивается блоком, в котором он объявлен:
 *          - уничтожается после выполнения блока или оператора, в котором он был создан
 *          - может затемнять и конфликтовать с именами из обрамляющих блоков */


/* ДОСТУП
 * - имеет доступ ко всем членам и конструкторам обрамляющего класса (в т.ч. приватным и статическим)
 *      - если объявлен в статическом блоке (в т.ч. интерфейсе и перечислении) - только к
 *      статическим членам и конструкторам
 *
 * - имеет доступ только к финализированным другим локальным переменным или параметрам
 *      - т.к. при таком обращении локальный класс захватывает переменную или параметр
 *      - с J8 может обращаться без final, если переменная или параметр эффективно финализированы:
 *          - т.е. их значение не меняется после инициализации) */


/* ОБРАЩЕНИЕ
 * - вне блока кода обратиться нельзя */


@Ntrstn("Локальный класс является специальным подтипом внутреннего. Он действует подобно локальной " +
        "переменной, при этом лишаясь статуса члена класса")

@Ntrstn("Как и локальная переменная - он может быть объявлен в любом блоке кода, доступен только " +
        "после объявления и только в рамках блока, в котором объявлен (умирает после завершения " +
        "блока), и не может использовать в объявлении модификаторы доступа (но могут его внутренние " +
        "члены)")

@Ntrstn("Так как имя локального класса недоступно за пределами его зоны видимости, единственным " +
        "доводом в его пользу (против анонимного) может быть только необходимость в именованном " +
        "конструкторе и/или перегруженных конструкторах; безымянные внутренние классы вправе " +
        "задействовать только инициализацию экземпляра. Единственная причина использования " +
        "локального вместо анонимного класса - возможность создания более чем 1 объекта такого класса")

@Ntrstn("Ключевой особенностью всех внутренних классов является то, что они не могут существовать " +
        "без экземпляра обрамляющего класса. Компилятор автоматически добавляет в конструктор " +
        "внутреннего класса параметр для ссылки на экземпляр обрамляющего класса. При необходимости, " +
        "получить эту ссылку можно с помощью ВнешКласс.this. Т.е. внутренний класс по сути является " +
        "объектно-ориентрированным замыканием, т.к. он содержит не только информацию об объекте " +
        "внешнего класса (место создания), но также у него есть ссылка на весь объект внешнего " +
        "класса, с помощью которой он может манипулировать всеми членами этого объекта")

@Ntrstn("Так как внутренние классы не могут существовать без экземпляров внешних классов, они не " +
        "могут иметь статические члены (иначе пришлось бы создавать экземляр внешнего класса). Но " +
        "они могут иметь static final константы времени копмиляции (переменные-примитивы или String, " +
        "которые объявлены как final и инициализированы константным выражением во время компиляции) " +
        "или могут унаследовать статические члены")

@Ntrstn("Как и для всех подклассов, чтобы обратиться к их нестатическим членам извне, сначала нужно " +
        "создать экземпляр такого подкласса. Создать экземпляр такого класса можно только внутри " +
        "блока, где он объявлен")

@Ntrstn("Обрамляющий класс не имеет доступа к нестатическим членам подклассов. Следовательно, ни к " +
        "каким членам внутреннего класса обратиться напрямую нельзя (т.к. у него могут быть только " +
        "нестатические члены)")

@Ntrstn("Одним из преимуществ подклассов является то, что они имеют прямой доступ ко всем членам и " +
        "конструкторам (!) обрамляющего класса. Доступ есть даже к приватным членам! Но если " +
        "локальный класс объявлен в статическом блоке, его доступ становится таким же, как у " +
        "вложенных (статических классов): без экземпляра обрамляющего класса доступ есть только к " +
        "его статическим членам и конструкторам")

@Ntrstn("Локальные классы могут использовать другие локальные переменные из блока, в котором " +
        "объявлены, только если они финализированы или эффективно финализированы (т.е. значения не " +
        "меняются после инициализации)")

@Ntrstn("Локальный класс может быть унаследован только в своей области действия другим локальным " +
        "классом или анонимным классом")

@Ntrstn("Все виды подклассов могут независимо от обрамляющего класса наследовать любой класс или " +
        "имплементировать любой интерфейс - это важное преимущество - т.к. тем самым они " +
        "обеспечивают множественность реализации. Обычно так и происходит: внутренний класс " +
        "наследует от класса или реализует интерфейс, а код внутреннего класса манипулирует объектом " +
        "внешнего класса, в котором он был создан.")

@Ntrstn("К остальным преимуществам подклассов относится возможность группировать классы логически, " +
        "т.е. внутри класса Машина будут подклассы Руль, Колесо и т.д. Кроме этого, улучшается " +
        "инкапсуляция - нужные Двигателю подклассы Машины могут оставаться скрытыми для Машины")

@Ntrstn("Обращение с внутренними классами происходит на уровне компилятора, а не JVM. Для их " +
        "обозначения используется знак $, разделяющий имена внешних и внутренних классов. В " +
        "результате компиляции получаются 2 класса __Implicit_Synthetic_Bridge.class и __Implicit_Synthetic_Bridge$Inner.class. Таким образом, для " +
        "JVM внутренние классы неотличимы от внешних.")


public class Local {
    int var; // есть доступ
    static int staticVar; // есть доступ
    private int privateVar; // есть доступ
    private static int privateStaticVar; // есть доступ
    int shadow;


    /*МОЖЕТ БЫТЬ В БЛОКЕ КОДА*/ {
        /*МОЖЕТ БЫТЬ РАСШИРЕНИЕМ КАКОГО-ТО КЛАССА*/
        /*МОЖЕТ РЕАЛИЗОВЫВАТЬ КАКОЙ-ТО ИНТЕРФЕЙС*/
        /*НЕ МОЖЕТ ОБЪЯВЛЯТЬ ОБ ИМПЛЕМЕНТАЦИИ КАКОГО-ТО ИНТЕРФЕЙСА*/
        class InnerLocal extends ExternalClass implements Serializable {
            /* МОЖЕТ ИМЕТЬ ТОЛЬКО НЕСТАТИЧЕСКИЕ ЧЛЕНЫ */
            int v;

            void method() {
            }

            class InnerInnerLocal { // можно объявлять внутренние классы
            }

            {
                class InnerLocal2 { // можно объявлять внутренние локальные классы
                }
            }
            // static int v2;
            // static void meth () {}
            // static class StaticInner {}
            // enum InnerEnum {ONE, TWO}
            // interface InnerInterface {}

            /*МОЖЕТ УНАСЛЕДОВАТЬ СТАТИЧЕСКИЕ ЧЛЕНЫ*/
            void m() {
                staticExtVar = 2;
                staticExtMeth();
            }

            /* МОЖЕТ ИМЕТЬ ПЕРЕМЕННЫЕ-КОНСТАНТЫ*/
            final static int v4 = 34 + 54;


            /* ЕСТЬ ДОСТУП КО ВСЕМУ ИЗ ОБРАМЛЯЮЩЕГО КЛАССА*/
            /* ЧЛЕНЫ МОГУТ ИМЕТЬ ЛЮБОЙ МОДИФИКАТОР ДОСТУПА*/
            private int anVar = var;
            protected int anVar2 = staticVar;
            public int anInt3 = privateVar;
            int anInt4 = privateStaticVar;
            Local local = new Local();
            Local local2 = new Local(3);
            MyEnum myEnum = MyEnum.ONE;
            MyInterface myInterface = new MyInterface() {
            };
            /*МОЖЕТ ПРОИСХОДИТЬ ЗАТЕМНЕНИЕ*/
            int shadow = 5; // затемняет shadow из внешней области
        }


        /* МОЖНО ИСПОЛЬЗОВАТЬ ТОЛЬКО ПОСЛЕ ОБЪЯВЛЕНИЯ */
        InnerLocal innerLocal = new InnerLocal();
        innerLocal.m();


        /* МОЖЕТ БЫТЬ В ЛЮБОМ БЛОКЕ, НАПР. IF*/
        if (true) {
            class InnerLocal2 {
            }
        }
    }


    /* МОЖЕТ БЫТЬ В СТАТИЧЕСКОМ БЛОКЕ КОДА */
    static {
        class InnerLocal {
            /* В СТАТИЧЕСКОМ БЛОКЕ ДОСТУП ЕСТЬ ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ И КОНСТРУКТОРАМ */
            // int v = var;
            int v2 = staticVar;
            Local anonymous = new Local();
            Local anonymous2 = new Local(3);
        }
    }


    /* МОЖЕТ БЫТЬ В КОНСТРУКТОРЕ */
    public Local() { // есть доступ
        class InnerLocal {
        }
    }


    /* ИМЕЕТ ДОСТУП ТОЛЬКО К (ЭФФЕКТИВНО) ФИНАЛИЗИРОВАННЫМ ДРУГИМ ЛОКАЛЬНЫМ ПЕРЕМЕННЫМ И ПАРАМЕТРАМ*/
    private Local(int parameter) { // есть доступ
        int localVar = 0;
//        localVar = 6; // не должно меняться или должно быть финализировано
        {
            class InnerLocal {
                int v = localVar;
                int v2 = parameter;
            }
        }
    }


    /* МОЖЕТ БЫТЬ В МЕТОДЕ */
    void meth() { // есть доступ
        class InnerLocal {
        }
    }


    /* В ИНТЕРФЕЙСЕ МОЖЕТ БЫТЬ ТОЛЬКО МЕТОДЕ С ДЕФОЛТНОЙ ИМПЛЕМЕНТАЦИЕЙ */
    interface MyInterface { // есть доступ
        default void meth() {
            class MyInterfaceInnerLocal {
                /* В СТАТИЧЕСКОМ БЛОКЕ ДОСТУП ЕСТЬ ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ И КОНСТРУКТОРАМ */
                // int v = var;
                int v2 = staticVar;
                Local anonymous = new Local();
                Local anonymous2 = new Local(3);
            }
        }
    }


    /* МОЖЕТ БЫТЬ В ПЕРЕЧИСЛЕНИИ */
    enum MyEnum { // есть доступ
        ONE, TWO;

        {
            class InnerLocal {
                /* В СТАТИЧЕСКОМ БЛОКЕ ДОСТУП ЕСТЬ ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ И КОНСТРУКТОРАМ */
                // int v = var;
                int v2 = staticVar;
                Local anonymous = new Local();
                Local anonymous2 = new Local(3);
            }
        }
    }
}


class ExternalClass {
    static int staticExtVar;

    static void staticExtMeth() {
    }
}