package types_references_classes.classes_inside.nested_static;

import _types_references_annotations.my_annotations.Ntrstn;

/* СТАТИЧЕСКИЙ ВЛОЖЕННЫЙ КЛАСС - КЛАСС С МОДИФИКАТОРОМ STATIC, ВЛОЖЕННЫЙ В ДРУГОЙ КЛАСС, ИНТЕРФЕЙС
 * ИЛИ ПЕРЕЧИСЛЕНИЕ */


/* СТАТИЧЕСКИЕ КЛАССЫ ВЕРХНЕГО УРОВНЯ ЗАПРЕЩЕНЫ
 * - а статический вложенный ведет себя как обычный класс верхнего уровня, вложенный в другой класс
 * верхнего уровня просто для удобства */


/* ВЕДЕТ СЕБЯ КАК ОБЫЧНЫЙ ВЫСОКОУРАВНЕВЫЙ СТАТИЧЕСКИЙ КЛАСС
 *  - может существовать независимо от экземпляра обрамляющего класса
 *  - применяется, когда доступ к обрамляющему классу не требуется
 *      - напр. "машина" и "аккумулятор": "аккумулятор* можно подключать к другим устройствам */


/* КАК ВСЕ ВЛОЖЕННЫЕ
 * - являются членами обрамляющего класса (т.е. наследуются)
 *      - вложенный класс может имплементировать любой интерфейс
 *      - вложенный класс может наследовать любой класс
 *          - в т.ч. нестатическим статический
 *      - вложенный класс можно наследовать отдельно
 *          - в т.ч. нестатическим статический
 *
 * - как и другие члены, могут иметь любые модификаторы доступа
 *      - члены вложенных классов могут иметь любые модификаторы доступа
 *      - в интерфейсе автоматически становится статическим открытым */


/* НАСЛЕДОВАНИЕ
 * - не может быть унаследован только классом верхнего уровня, внутри которого он объявлен*/


/* ДОСТУП
 * - вложенный статический класс имеет прямой доступ:
 *      - ко всем конструкторам обрамляющего класса
 *          - в т.ч. к приватным!!
 *      - только к статическим членам обрамляющего класса:
 *          - в т.ч. к приватным статическим!!
 *
 * - обрамляющий класс имеет непрямой (через имя) доступ:
 *      - только к статическим членам вложенного статического класса */


/* ОБРАЩЕНИЕ
 * - из статического вложенного к обрамляющему
 *      - из статического и нестатического контекста:
 *          - можно только к статическим:
 *              - напрямую по имени
 *              - либо через ИмяОбрамляющего.поле/метод (в случае затемнения)
 *          - к нестатическим можно только через экземпляр обрамляющего
 *              - зато тоже по имени
 *
 * - к статическому вложенному из обрамляющего:
 *      - из статического и нестатического контекста:
 *          - к статическим элементам:
 *              - через имя статического вложенного класса
 *          - к нестатическим элементам:
 *              - через объект статического вложенного класса
 *
 * - к статическому вложенному извне обрамляющего
 *      - из статического и нестатического контекста:
 *          - к статическим элементам - через ИмяОбрамляющего.ИмяСтатическогоВложенного
 *          - к нестатическим элементам - через объект ИмяОбрамляющего.ИмяСтатическогоВложенного */


/* МОЖЕТ ИМЕТЬ СТАТИЧЕСКИЕ И НЕ СТАТИЧЕСКИЕ ЧЛЕНЫ
 * - в т.ч. интерфейсы и перечисления*/


/* МОЖЕТ НАХОДИТСЯ ТОЛЬКО НА УРОВНЕ ДРУГИХ ЧЛЕНОВ ОБРАМЛЯЮЩЕГО КЛАССА */


@Ntrstn("Статический подкласс может быть только членом обрамляющего класса, интерфейса или " +
        "перечисления. Он не может быть объявлен в любом блоке кода, в отличие от нестатических")

@Ntrstn("Статические классы верхнего уровня запрещены. Статический класс может быть только вложенным " +
        "и ведет себя как класс верхнего уровня, вложенный в другой класс верхнего уровня для " +
        "удобства.")

@Ntrstn("Статический подкласс называется вложенным и в объявлении имеет слово static. В отличие от " +
        "других подклассов, ему не нужен экземпляр обрамляющего класса для существования.")

@Ntrstn("В отличие от других подклассов, вложенный класс может также иметь статические члены, т.к. " +
        "существует независимо от экземпляра обрамляющего класса (и такой экземляр не приходится " +
        "создавать при обращении)")

@Ntrstn("Как и для других подклассов, чтобы обратиться к нестатическим членам статического подкласса " +
        "извне, сначала нужно создать его экземпляр. Внутри обрамляющего класса экземпляр можно " +
        "создать по простому имени вложенного класса. Снаружи обрамляющего класса, экземпляр можно " +
        "создать по следующему синтаксису: new ВнешнийКласс.ВнутреннийКласс(). К статическим членам " +
        "всегда можно обратиться по полному имени.")

@Ntrstn("Как и у всех подклассов, у вложенного есть полный доступ к членам обрамляющего класса и к " +
        "его конструктору, но обратиться к нестатическим членам без экземпляра обрамляющего класса " +
        "внутри вложенного нельзя, т.к. вложенный класс является статическим контекстом. Т.е. через " +
        "экземпляр сохраняется доступ даже к приватным членам!")

@Ntrstn("Вложенные классы являются членами обрамляющего класса - т.е. передаются при наследовании. " +
        "Кроме того, они могут быть унаследованы отдельно, и независимо от обрамляющего класса " +
        "наследовать любой класс или имплементировать любой интерфейс - этим они могут обеспечить " +
        "множественность реализации. Также, как члены класса, они могут иметь любые модификаторы " +
        "доступа и должны находиться на уровне других членов")

@Ntrstn("Вложенный класс не может быть унаследован только классом верхнего уровня, внутри которого " +
        "он объявлен")

@Ntrstn("К остальным преимуществам подклассов относится возможность группировать классы логически, " +
        "т.е. внутри класса Машина будут подклассы Руль, Колесо и т.д. Кроме этого, улучшается " +
        "инкапсуляция - нужные Двигателю подклассы Машины могут оставаться скрытыми для Машины")

@Ntrstn("Если подкласс объявить внутри интерфейса, то он автоматически станет public static - т.е. " +
        "вложенным. В то же время, внутри перечисления подкласс может быть как статическим, так и " +
        "нестатическим. Т.е. члены перечисления не становятся автоматически static")

@Ntrstn("Вложенный в интерфейс класс может быть реализацией этого интерфейса")


public class Main {
    private int var; // есть доступ через экземпляр
    static int staticVar; // есть доступ
    private int privateVar; // нет доступа
    private static int privateStaticVar; // есть доступ


    public Main() { // есть доступ
    }

    private Main(int var) { // есть доступ
    }

    void meth() { // нет доступа
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ НЕСТАТИЧЕСКОГО КОНТЕКСТА ОБРАМЛЯЮЩЕГО */
        int v = StaticInner.innerStaticVar; // к статическим элементам - через имя статического вложенного
        new StaticInner().innerStaticMeth(); // к нестатическим элементам - через объект статического вложенного
    }

    static void staticMeth() { // есть доступ
    }

    private void privateMeth() { // есть доступа через
    }

    private static void privateStaticMeth() { // есть доступ
    }

    /*ВОЗМОЖНЫЕ УРОВНИ ДОСТУПА - ТАКИЕ ЖЕ КАК И ДРУГИХ ЧЛЕНОВ*/
    public static class StaticInner {
        /* ЕСТЬ ДОСТУП КО ВСЕМ КОНСТРУКТОРАМ И ТОЛЬКО К СТАТИЧЕСКИМ ЧЛЕНАМ*/

        /* ОБРАЩЕНИЕ К ОБРАМЛЯЮЩЕМУ КЛАССУ ИЗ НЕСТАТИЧЕСКОГО КОНТЕКСТА ВЛОЖЕННОГО СТАТИЧЕСКОГО*/
        void meth() {
            int innerVar = staticVar; // обращение напрямую по имени
            int innerVar2 = privateStaticVar; // есть доступ к приватным членам
            new Main(); // есть доступ к конструктору
            new Main(3); // есть доступ к приватному конструктору
            privateStaticMeth();
            Main.staticMeth();  // через ИмяОбрамляющего.поле/метод
            /* К НЕСТАТИЧЕСКОМУ МОЖНО ОБРАТИТЬСЯ ТОЛЬКО ЧЕРЕЗ ЭКЗЕМЛЯР ОБРАМЛЯЮЩЕГО */
            int v = new Main().var; // прямое (через экземпляр) обращение по имени даже к private
        }

        /* ОБРАЩЕНИЕ К ОБРАМЛЯЮЩЕМУ КЛАССУ ИЗ СТАТИЧЕСКОГО КОНТЕКСТА ВЛОЖЕННОГО СТАТИЧЕСКОГО*/
        static void innerStaticMeth() {
            privateStaticMeth(); // напрямую по имени
            Main.staticMeth(); // либо через ИмяОбрамляющего.поле/метод
        }

        /* МОЖЕТ ИМЕТЬ СТАТИЧЕСКИЕ И НЕСТАТИЧЕСКИЕ ЧЛЕНЫ */
        int innerVar;
        static int innerStaticVar;

        enum InnerEnum {} // в т.ч. enum

        interface InnerInterface {
        } // в т.ч. interface

    }


    /*МОЖЕТ БЫТЬ УНАСЛЕДОВАН ОТДЕЛЬНО ПРОСТЫМ КЛАССОМ*/
    class StaticInnerChild extends StaticInner {
    }


    /*МОЖЕТ БЫТЬ УНАСЛЕДОВАН ОТДЕЛЬНО СТАТИЧЕСКИМ КЛАССОМ*/
    static class StaticStaticInnerChild extends StaticInner {
    }

    /* МОЖЕТ БЫТЬ В ПЕРЕЧИСЛЕНИИ */
    enum MyEnum {
        ONE, TWO;

        static class EnumInnerClass {
            int enumVar;

            static void enumMeth() {
            }
        }
    }

    public static void main(String[] args) {
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ СТАТИЧЕСКОГО КОНТЕКСТА ОБРАМЛЯЮЩЕГО*/
        int v = StaticInner.innerStaticVar; // к статическим элементам - через имя статического вложенного
        new StaticInner().meth(); // к нестатическим элементам - через объект статического вложенного
        MyEnum.EnumInnerClass.enumMeth(); // к статическим элементам - через имя статического вложенного
        int v2 = new MyEnum.EnumInnerClass().enumVar; // к нестатическим элементам - через объект статического вложенного
    }
}
//static class Static {
/* КЛАСС ВЕРХНЕГО УРОВНЯ НЕ МОГУТ БЫТЬ СТАТИЧЕСКИМИ */

//}


class AnotherClass {
    void meth() { // нет доступа
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ НЕСТАТИЧЕСКОГО КОНТЕКСТА ВНЕ ОБРАМЛЯЮЩЕГО */
        int v = Main.StaticInner.innerStaticVar; // к статическим элементам - через ИмяОбрамляющего.ИмяСтатическогоВложенного
        new Main.StaticInner().meth(); // к нестатическим элементам - через объект ИмяОбрамляющего.ИмяСтатическогоВложенного
    }

    public static void main(String[] args) {
        /* ОБРАЩЕНИЕ К СТАТИЧЕСКОМУ ВЛОЖЕННОМУ ИЗ СТАТИЧЕСКОГО КОНТЕКСТА ВНЕ ОБРАМЛЯЮЩЕГО */
        int v = Main.StaticInner.innerStaticVar; // к статическим элементам - через ИмяОбрамляющего.ИмяСтатическогоВложенного
        new Main.StaticInner().meth(); // к нестатическим элементам - через объект ИмяОбрамляющего.ИмяСтатическогоВложенного


        /*ВЛОЖЕННЫЙ СТАТИЧЕСКИЙ МОЖЕТ СУЩЕСТВОВАТЬ НЕЗАВИСИМО ОТ ЭКЗЕМПЛЯРА ОБРАМЛЯЮЩЕГО КЛАССА*/
        Main.StaticInner staticInner = new Main.StaticInner(); // сразу создается нужный объект


        /* ВНУТРЕННИЕ КЛАССЫ, ОПРЕДЕЛЕННЫЕ В ИНТЕРФЕЙСАХ, АВТОМАТИЧЕСКИ СЧИТАЮТСЯ static public */
        SomeInterface.InterfaceInnerClass interfaceInnerClass = new SomeInterface.InterfaceInnerClass();
    }
}

interface SomeInterface {
    /* АВТОМАТИЧЕСКИ СТАНОВИТСЯ СТАТИЧЕСКИМ ОТКРЫТЫМ*/
    class InterfaceInnerClass {
        int var = 4;
        static int var2 = 4;
        int test = new Main.StaticInner().innerVar;
    }
}