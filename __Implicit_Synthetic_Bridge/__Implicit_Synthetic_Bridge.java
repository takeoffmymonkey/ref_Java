package __Implicit_Synthetic_Bridge;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;

/*можно обнаруживать с помощью рефлексии*/

/*
 * у неявного конструктора параметры также неявные
 * Дефолтный конструктор всегда неявный
 * у поля нет опции неявными
 * и у метода и конструктора тоже!
 * isImplicit() не работает блядь!
 *
 * The implicit parameter in Java is the object that the method belongs to. It's passed by specifying the reference or variable of the object before the name of the method.

An implicit parameter is opposite to an explicit parameter, which is passed when specifying the parameter in the parenthesis of a method call.

If a parameter isn't explicitly defined, the parameter is considered implicit.
 *
 *
 * */

/*
* Uses of Java Synthetic
It might be useful in debugging sessions, when we see those synthetic stuff in stack trace we can understand what it is.
AOP, generics, enums uses Java synthetic.
Java reflection API exposes method to check if an element is synthetic.
A regular java application programmer will not require synthetic for day to day programming.
This knowledge may be required in interviews but that doesn’t mandate that you will use it in the project.*/


/*I think that the concept of synthetic classes has simply proven to be not useful, i.e. nobody cares whether a class is synthetic. With fields and methods, it's probably used in exactly one place: to determine what to show in an IDE class structure view - you want normal methods and fields to show up there, but not the synthetic ones used to simulate nested classes. OTOH, you DO want anonymous classes to show up there.*/

/*

Synthetic fields and constructors are used to implement nested classes (there is not concept of nested classes in byte code, only in source code).

 * synthetic field
A compiler-created field that links a local inner class to a block's local variable or reference type parameter.
 *
 * Constructs emitted by a Java compiler are marked as synthetic if they do not correspond to a
 * construct declared explicitly or implicitly in source code, unless they are class lang_blocks
 * methods. Synthetic constructs are artifacts generated by compilers that vary among different
 * implementations.
 *
 *
 * If there is a getter method available in source then this synthetic method will not be created.
 *
 *
 * When the Java compiler encounters an enum construct, it creates several methods that are compatible
 * with the .class io.io_nio_nio2 structure and provide the expected functionality of the enum construct.
*
* The formal parameters for the default constructor of an enum construct are not implicitly declared
* because different compilers need not agree on the form of this constructor; another Java compiler
* might specify different formal parameters for it. When compilers compile expressions that use enum
* constants, they rely only on the public static fields of the enum construct, which are implicitly
* declared, and not on their constructors or how these constants are initialized)
*
*
* A synthetic field is a compiler-created field that links a local inner class to a block's local
* variable or reference type parameter. The compiler synthesizes certain hidden fields and methods
* in order to implement the scoping of names. These fields are private unless noted otherwise, or
* they are at most of package scope. You can get more information here and in JLS

A class member that does not appear in the source code must be marked using a Synthetic attribute,
or else it must have its ACC_SYNTHETIC flag set. The only exceptions to this requirement are
compiler-generated methods which are not considered implementation artifacts, namely the instance
lang_blocks method representing a default constructor of the Java programming language (§2.9),
the class lang_blocks method (§2.9), and the Enum.values() and Enum.valueOf() methods..
*
* */

/* synthetic (compiler-generated)
bridge method (compiler-generated to support generic interfaces)
* */

/*Notice that the output for String.compareTo() contains two methods. The method declared in String.java:

public int compareTo(String anotherString);
and a second synthetic or compiler-generated bridge method. This occurs because String implements the parameterized interface Comparable. During type erasure, the argument type of the inherited method Comparable.compareTo() is changed from java.lang.Object to java.lang.String. Since the parameter types for the compareTo methods in Comparable and String no longer match after erasure, overriding can not occur. In all other circumstances, this would produce a compile-time error because the interface is not implemented. The addition of the bridge method avoids this problem.*/


public class __Implicit_Synthetic_Bridge {
    static Class c;
    static Field[] fs;
    static Constructor[] cs;
    static Method[] ms;
    static Parameter[] ps;

    private InnerClass ic;
    private int i;

    /* НЕЯВНЫЙ ДЕФОЛТНЫЙ КОНСТРУКТОР
    public __Implicit_Synthetic_Bridge() {
    }
    */


    void createInner() {
        // The Compiler has to create a synthetic method
        // to construct a new InnerClass because the constructor
        // is private.
        // --> synthetic "constructor" method
        ic = new InnerClass();

        // The Compiler has to create a synthetic method
        // to doSomething on MyInner object because this
        // method is private.
        // --> synthetic "doSomething" method
        ic.innerM();
    }



    /*СИНТЕТИЧЕСКИЙ МЕТОД ДЛЯ ДОСТУПА ВНУТРЕННЕГО КЛАССА К ПРИВАТНОМУ ПОЛЮ
    int access$002(__Implicit_Synthetic_Bridge arg0, int arg1){}
    * */


    public class InnerClass {
        /*СИНТЕТИЧЕСКОЕ ПОЛЕ
        final MethodParameterExamples parent;*/

        /*НЕЯВНЫЙ ДЕФОЛТНЫЙ КОНСТРУКТОР
        InnerClass(final MethodParameterExamples this$0) { // НЕЯВНЫЙ ПАРАМЕТР ДЛЯ ДЕФОЛТНОГО КОНСТРУКТОРА
            parent = this$0;
        }*/

        void innerM(){
            i = 4;
        }
    }


    enum Colors {
        RED, WHITE;
    }

    /* ПЕРЕЧИСЛЕНИЕ (ВИД .CLASS ФАЙЛА ПОСЛЕ КОМПИЛЯЦИИ)
    final class Colors extends java.lang.Enum<Colors> {
    public final static Colors RED = new Colors("RED", 0);
    public final static Colors BLUE = new Colors("WHITE", 1);

    private final static values = new Colors[]{ RED, BLUE };

    // НЕЯВНЫЙ ДЕФОЛТНЫЙ КОНСТРУКТОР (НО ПАРАМЕТРЫ СИНТЕТИЧЕСКИЕ!)
    private Colors(String name, int ordinal) {
        super(name, ordinal);
    }

    // НЕЯВНЫЙ МЕТОД values()
    public static Colors[] values(){
        return values;
    }

    // НЕЯВНЫЙ МЕТОД valueOf С НЕЯВНЫМ ПАРАМЕТРОМ String name
    public static Colors valueOf(String name){
        return (Colors)java.lang.Enum.valueOf(Colors.class, name);
    }
}*/


    public static void main(String[] args) {
        c = __Implicit_Synthetic_Bridge.class;
//        c = __Implicit_Synthetic_Bridge.InnerClass.class;
//        c = __Implicit_Synthetic_Bridge.Colors.class;

//        printGeneralClassInfo(c);
//        printFieldsInfo(c);
//        printConstructorsInfo(c);
        printMethodsInfo(c);
    }


    public static void printGeneralClassInfo(Class c) {
        System.out.println("===================");
        fs = c.getDeclaredFields();
        cs = c.getDeclaredConstructors();
        ms = c.getDeclaredMethods();
        System.out.println("Class: " + c.getName());
        System.out.println("Number of fields: " + fs.length);
        System.out.println("Number of constructors: " + cs.length);
        System.out.println("Number of methods: " + ms.length);
    }


    public static void printFieldsInfo(Class c) {
        System.out.println("===================");
        fs = c.getDeclaredFields();
        System.out.println("Number of fields: " + fs.length);
        for (Field field : fs) {
            System.out.println("Field name: " + field.getName());
            System.out.println("Field type: " + field.getType());
            System.out.println("Field modifiers: " + Modifier.toString(field.getModifiers()));
            System.out.println("Field is synthetic: " + field.isSynthetic());
            System.out.println("======");
        }
    }

    public static void printConstructorsInfo(Class c) {
        System.out.println("===================");
        cs = c.getDeclaredConstructors();
        System.out.println("Number of constructors: " + cs.length);

        for (Constructor constructor : cs) {
            System.out.println("=========");
            System.out.println("Constructor name: " + constructor.getName());
            System.out.println("Constructor modifiers: " + Modifier.toString(constructor.getModifiers()));
            System.out.println("Constructor is synthetic: " + constructor.isSynthetic());
            System.out.println("Constructor is varargs: " + constructor.isVarArgs());
            System.out.println("Constructor is accessible: " + constructor.isAccessible());
            ps = constructor.getParameters();
            System.out.println("Parameters number: " + ps.length);

            for (Parameter parameter : ps) {
                System.out.println("===");
                System.out.println("Parameter name: " + parameter.getName());
                System.out.println("Parameter type: " + parameter.getType());
                System.out.println("Parameter modifiers: " + Modifier.toString(parameter.getModifiers()));
                System.out.println("Parameter is synthetic: " + parameter.isSynthetic());
                System.out.println("Parameter is implicit: " + parameter.isImplicit());
                System.out.println("Parameter is varargs: " + parameter.isVarArgs());
                System.out.println("Parameter has proper name: " + parameter.isNamePresent());
            }
        }
    }


    static void printMethodsInfo(Class c) {
        System.out.println("===================");
        ms = c.getDeclaredMethods();
        System.out.println("Methods number: " + ms.length);

        for (Method method : ms) {
            System.out.println("=========");
            System.out.println("Method name: " + method.getName());
            System.out.println("Method return type: " + method.getReturnType());
            System.out.println("Method modifiers: " + Modifier.toString(method.getModifiers()));
            System.out.println("Method is synthetic: " + method.isSynthetic());
            System.out.println("Method is bridge: " + method.isBridge());
            System.out.println("Method is default: " + method.isDefault());
            System.out.println("Method is varargs: " + method.isVarArgs());
            ps = method.getParameters();
            System.out.println("Parameters number: " + ps.length);

            for (Parameter p : ps) {
                System.out.println("===");
                System.out.println("Parameter name: " + p.getName());
                System.out.println("Parameter type: " + p.getType());
                System.out.println("Parameter modifiers: " + Modifier.toString(p.getModifiers()));
                System.out.println("Parameter is synthetic: " + p.isSynthetic());
                System.out.println("Parameter is implicit: " + p.isImplicit());
                System.out.println("Parameter is varargs: " + p.isVarArgs());
                System.out.println("Parameter has proper name: " + p.isNamePresent());
            }
        }
    }
}


/*Synthetic constructors are rare; however the SyntheticConstructor example illustrates a typical situation where this may occur:


public class SyntheticConstructor {
    private SyntheticConstructor() {}
    class Inner {
	// Compiler will generate a synthetic constructor since
	// SyntheticConstructor() is private.
	Inner() { new SyntheticConstructor(); }
    }
}*/