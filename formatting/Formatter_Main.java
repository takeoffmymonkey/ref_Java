package formatting;

import java.util.Date;
import java.util.Formatter;

import types_references_annotations.my_annotations.Ntrstn;

/* КЛАСС
 * public final class Formatter
 * extends Object
 * implements Closeable, Flushable
 *
 * - не потокобезопасен*/


/* КАЖДОМУ ФОРМАТИРУЮЩЕМУ МЕТОДУ НУЖНЫ ФОРМАТНАЯ СТРОКА И СПИСОК АГРУМЕНТОВ */


/* ФОРМАТНАЯ СТРОКА
 * - объект String c фиксированным текстом
 * - а также 1 или больше спецификатором формата*/


/* СПЕЦИФИКАТОР ФОРМАТА
 * - указывает:
 *      - КАК должен быть обработан соответствующий аргумент
 *      - КУДА должен быть вставлен соответствующий аргумент
 *
 * - может быть 1 или больше
 *
 * - синтаксис:
 *      - для аргументов общих, символьных и числовых типов:
 *           %[индекс_аргумента$][флаги][ширина][.точность]символ_преобразования
 *
 *      - для аргументов типа времени и даты:
 *           %[индекс_аргумента$][флаги][ширина]символы_преобразования
 *
 *      - для спецификаторов, не соответствующих типу аргумента
 *           %[флаги][ширина]символ_преобразования */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


/* ИНДЕКС АРГУМЕНТА
 * - целочисленное значение, указывающее порядковый номер аргумента в списке аргументов:
 *          - первый аргумент "1$"
 *          - второй аргумент "2$"
 *          - и т.д.
 *
 * - применим только для общих, символьных и числовых типов аргумента и даты и времени
 *
 * - в случае применения к другим типам - исключение
 *
 * - опциональный
 *
 * - альтернатива - флаг '<' ('\u003c'):
 *      - приводит к использованию аргумента из предыдущего спецификатора формата
 *      - напр. %1$tm %1$te,%1$tY = %1$tm %<te,%<tY */


/* ФЛАГИ
 * - набор символов, которые изменяют формат вывода
 *
 * - набор зависит от символа преобразования
 *
 * - применимы ко всем типам
 *
 * - опциональны
 *
 * - символы, не указанные ниже, запрещены (зарезервированны)
 *
 *- ВИДЫ:
 *      '-' (результат будет выровнен по левой стороне), для:
 *          - общий
 *          - символьный
 *          - целочисленный
 *          - вещественный
 *          - дата и время
 *
 *      '#' (результат должен использовать альтернативную форму в зависимости от символа
 *      преобразования), для:
 *          - общий (зависит от определения Formattable)
 *          - целочисленный (только для символов преобразования 'o', 'x' и 'X')
 *          - вещественный
 *
 *      '+' (результат всегда будет со знаком), для:
 *          - целочисленный
 *          - вещественный (для символов преобразования 'd', 'o', 'x' и 'X', примененных к BigInteger
 *          или для символа преобразования 'd', примененного к byte, Byte, short, Short, int, Integer,
 *          long и Long)
 *
 *      ' ' (результ будет с начальным пробелом для положительных значений), для:
 *          - целочисленный
 *          - вещественный (для символов преобразования 'd', 'o', 'x' и 'X', примененных к BigInteger
 *          или для символа преобразования 'd', примененного к byte, Byte, short, Short, int, Integer,
 *          long и Long)
 *
 *      '0' (результат будет отодвинут вправо на указанное число), для:
 *          - целочисленный
 *          - вещественный
 *
 *      ',' (результат будет с групповыми разделителями, зависящими от локали), для:
 *          - целочисленный (только для символа преобразования 'd')
 *          - вещественный (только для символов преобразования 'e', 'E', 'f', 'g' и 'G2')
 *
 *      '(' (результат будет помещать отрицательные числа в скобки)
 *      - целочисленный (для символов преобразования 'd', 'o', 'x' и 'X', примененных к BigInteger
 *          или для символа преобразования 'd', примененного к byte, Byte, short, Short, int, Integer,
 *          long и Long)
 *      - вещественный (только для символов преобразования 'e', 'E', 'f', 'g' и 'G2') */


/* ШИРИНА
 * - положительное целочисленное, указывающее минимальное число символов, которые будут выведены
 *
 * - применима ко всем типам, кроме разделителя строк:
 *      - в случае указания - исключение
 *
 * - опциональна */


/* ТОЧНОСТЬ
 * - положительное целочисленное, обычно для ограничения количества выводимых символов
 *
 * - применима только для общих, символьных и числовых типов аргумента
 *
 *  - в случае применения к другим типам - исключение
 *
 * - опциональна
 *
 * - для аргументов общего типа:
 *      - максимальное количество символов для вывода
 *
 * - для вещественных:
 *      - 'a', 'A', 'e', 'E', 'f': количество цифр после запятой
 *      - 'g', 'G2': общее число цифр - результирующая величина после округления*/


/* СИМВОЛЫ ПРЕОБРАЗОВАНИЯ
 * - для общих, символьных и числовых типов аргумента:
 *      - символ, указывающий как нужно отформатировать аргумент
 *      - набор допустимых символов_преобразования зависит от типа аргумента
 *
 * - для типов агрумента даты и времени:
 *      - последовательность из 2 символов
 *      - первый символ t или T
 *      - второй символ указывает, какой нужно использовать формат
 *
 * - для типов, не соответствующих аргументу:
 *      - символ, указывающий содержание, которое должно быть вставлено в вывод
 *
 * - обязателен
 *
 * - строчность:
 *      - если символ с заглавной буквы, его результат тот же, что и для тех, что с маленькой, но
 *      он будет преобразован в заглавные буквы в соответствии с правилами локали
 *
 *      - результат аналогичен вызову метода String.toUpperCase()
 *
 * - символы, не указанные ниже, запрещены (зарезервированны)
 *
 * - ТИПЫ:
 *      - общий: может применятся к любому типу
 *
 *      - символьные: может применятся к базовым типам, представляющим символы Unicode:
 *          - char, Character, byte, Byte, short, и Short
 *          - также int и Integer, когда Character.isValidCodePoint(int) возвращает true
 *
 *      - числовые:
 *          - целые: byte, Byte, short, Short, int, Integer, long, Long, BigInteger (но не char или
 *          Character)
 *          - вещественные: float, Float, double, Double, BigDecimal
 *
 *      - дата/время: типы, которые могут кодировать дату или время:
 *          - long, Long, Calendar, Date, TemporalAccessor
 *
 *      - процент:
 *          - выводит литерал '%' ('\u0025')
 *
 *      - разделитель строк:
 *          - выводит разделить строки для данной платформы
 *
 * - ВИДЫ:
 *      - Общий:
 *          'b', 'B': если аргумент null, то результат "false". Если аргумент - boolean или Boolean,
 *          то результат - строка, возвращаемая String.valueOf(arg). Иначе результат "true"
 *
 *          'h', 'H': если аргумент null, то результат "null". Иначе результат будет получен вызовом
 *          Integer.toHexString(arg.hashCode())
 *
 *          's', 'S': если аргумент null, то результат "null". Если аргумент имплементирует
 *          Formattable, то вызывается его formatTo(). Иначе результат получается вызовом toString()
 *
 *      - Символьный:
 *          'c', 'C': результат - символ Unicode
 *
 *      - Целочисленный:
 *          'd': результат отформатирован как 10-чное целочисленое
 *          'o': результат отформатирован как 8-чное целочисленное
 *          'x', 'X': результат отформатирован как 16-чное целочисленное
 *
 *      - Вещественный:
 *          'e', 'E': результат отформатирован как 10-тичное число в компьютеризированной научной
 *          форме
 *          'f': результат отформатирован как 10-тичное число
 *          'g', 'G2': результат отформатирован при помощи компьютеризорованной научной формы или
 *          в 10-чной форме, в зависимости от точности и значения после округления
 *          'a', 'A': результат отформатирован как 16-чное вещественное число с мантиссой и степенью.
 *          Не поддерживается типом BigDecimal, несмотря на то, что он относится к категории
 *          вещественных аргументов
 *
 *      - Время/Дата:
 *          't', 'T': префикс
 *          - время:
 *              'H': час суток в 24-часовой системе, отформатированный как 2 цифры с предшествуюшими
 *              нулями при необходимости (00 - 23).
 *              'I': час в 12-часовой системе, отформатированный как 2 цифры с предшествуюшими нулями
 *              при необходимости (01 - 12).
 *              'k': час суток в 24-часовой системе (0 - 23).
 *              'l': час суток в 12-часовой системе (1 - 12).
 *              'M': минуты в часе, отформатированные как 2 цифры с предшествуюшими нулями при
 *              необходимости (00 - 59).
 *              'S': секунты в минуте, отформатированные как 2 цифры с предшествуюшими нулями при
 *              необходимости (00 - 60) ("60" - специальное значение для поддержки утекающих секунд).
 *              'L': миллисекунды в секунде, отформатированные как 3 цифры с предшествуюшими нулями
 *              при необходимости (000 - 999).
 *              'N': наносекунды в секунде, отформатированные как 9 цифр с предшествуюшими нулями
 *              при необходимости (000000000 - 999999999).
 *              'p': зависящий от локали маркер утра и дня строчными буквами ("am" или "pm").
 *              Использование префикса 'T' приводит к выводу заглавными.
 *              'z': числовой сдвиг временной зоны от GMT в стиле RFC 822 (напр. -0800). Значение
 *              будет подстроено как надо с учетом перевода часов. Для long, Long и Date используется
 *              дефолтная временная зона для данного экземпляра JVM.
 *              'Z': аббревиатура временной зоны. Значение будет с учетом перевода. Для long, Long и
 *              Date используется дефолтная временная зона для данного экземпляра JVM. Локаль
 *              класса Formatter будет заменять локаль аргумента (если она будет).
 *              's': Секунды с начала эпохи с 1 января 1970 00:00:00 UTC (от Long.MIN_VALUE/1000 до
 *              Long.MAX_VALUE/1000).
 *              'Q': Миллисекунды с начала эпохи с 1 января 1970 00:00:00 UTC (от Long.MIN_VALUE до
 *              Long.MAX_VALUE).
 *
 *          - дата:
 *              'B': зависящее от локали полное имя месяца, (напр. "January", "February").
 *              'b': зависящее от локали сокращенное имя месяца, (напр. "Jan", "Feb").
 *              'h': то же, что и 'b'.
 *              'A': зависящее от локали полное имя дня недели, (напр. "Sunday", "Monday")
 *              'a': зависящее от локали сокращенное имя дня недели, (напр. "Sun", "Mon")
 *              'C': 4-циферный год, деленный на 100, форматированный как 2 цифры с предшествуюшими
 *              нулями при необходимости (00 - 99)
 *              'Y': год, форматированный минимум как 4 цифры с предшествуюшими нулями при
 *              необходимости (напр. 0092, т.е. 92 год Григорианского календаря).
 *              'y': последние 2 цифры года с предшествуюшими нулями при необходимости (00 - 99).
 *              'j': день года, форматированный как 3 цифры с предшествуюшими нулями при
 *              необходимости, (001 - 366 для Грегорианского календаря).
 *              'm': месяц, форматированный как 2 цифры с предшествуюшими нулями при необходимости
 *              (01 - 13).
 *              'd': день месяца, форматированный как 2 цифры с предшествуюшими нулями при
 *              необходимости (01 - 31)
 *              'e': день месяца, форматированный как 2 цифры (1 - 31)
 *
 *          - дата и время:
 *              'R': время, форматированное для 24-часовой системы как "%tH:%tM"
 *              'T': время, форматированное для 24-часовой системы как "%tH:%tM:%tS".
 *              'r': время, форматированное для 12-часовой системы как "%tI:%tM:%tS %Tp". Место для
 *              утреннего или дневного маркера ('%Tp') может зависить от локали.
 *              'D': дата, форматированная как "%tm/%td/%ty".
 *              'F': полная дата по ISO 8601, форматированная как "%tY-%tm-%td".
 *              'c': дата и время, форматированные как "%ta %tb %td %tT %tZ %tY"
 *              ("Sun Jul 20 16:17:00 EDT 1969").
 *
 *      - Процентный:
 *           '%': литерал '%' ('\u0025')
 *
 *      - Разделитель строки:
 *           'n': разделить строки для данной платформы*/


/* У STRING ЕСТЬ СВОЙ МЕТОД FORMAT()*/


/* ОСНОВНЫЕ МЕТОДЫ
 * - format(String format, Object... args): записывает форматированную строку в место назначения
 * данного объекта при помощи указанной форматной строки и аргументов
 *
 * - toString(): возвращает результат вызова toString() для места назначения для вывода */

@Ntrstn("Форматирование позволяет изменить строку в указанный формат. Для работы с форматированием " +
        "существует класс Formatter, а также есть несколько методов, которые работают на его основе " +
        "и позволяющих обойтись без создания объекта Formatter. Это метод String.format() - " +
        "преобразует строку в нужный формат и System.out.printf() - то же, но еще и выводит эту " +
        "строку. Кроме того, можно написать свой класс, который можно будет форматировать - для " +
        "этого он должен реализовать интерфейс Formattable и его метод formatTo()")

@Ntrstn("Каждый форматирующий метод принимает на вход форматную строку и список аргументов. " +
        "Форматная строка - это объект String, который в себе, помимо текста, содержит 1 или " +
        "несколько спецификаторов формата. Каждый спецификатор выполняет 2 задачи: " +
        "1 - указывает КАК должен применится соответствующий ему аргумент, переданный в метод, к " +
        "данной строке" +
        "2 - указывает КУДА он должен быть вставлен в данной строке." +
        "Напр. String.format(\"Мне %+d лет\", 33)")

@Ntrstn("Для разных типов аргументов предлагается разный синтаксис:" +
        "1 - для аргументов общих, символьных и числовых типов: " +
        "   %[индекс_аргумента$][флаги][ширина][.точность]символ_преобразования" +
        "2 - для аргументов типа времени и даты:" +
        "   %[индекс_аргумента$][флаги][ширина]символы_преобразования" +
        "3 - для спецификаторов, не соответствующих типу аргумента" +
        "   %[флаги][ширина]символ_преобразования" +
        "где: " +
        "индекс_аргумента - целочисленное значение, указывающее порядковый номер аргумента в " +
        "списке аргументов" +
        "флаги - набор символов, которые изменяют формат вывода" +
        "ширина - положительное целочисленное, указывающее минимальное число символов, которые будут " +
        "выведены" +
        "точность - положительное целочисленное, обычно для ограничения количества выводимых символов" +
        "символ преобразования - (для общих, символьных и числовых типов аргумента) символ, " +
        "указывающий как нужно отформатировать аргумент, (для типов агрумента даты и времени) - " +
        "последовательность из 2 символов, где первый t или T, а второй указывает, какой нужно " +
        "использовать формат, (для типов, не соответствующих аргументу) -  символ, указывающий " +
        "содержание, которое должно быть вставлено в вывод")

@Ntrstn("Если в качестве символа преобразования указан boolean, но при этом передается не булеан, " +
        "то всегда будет выводиться true")


public class Formatter_Main {
    static String stringFormat;
    static Formatter formatter = new Formatter();

    static int intArg;
    static boolean boolArg;
    static Object objArg = new Object();
    static Object objArgNull;
    static String stringArg;
    static double doubleArg;
    static long longArg;
    static Date dateArg = new Date();


    public static void main(String[] args) {
        /*~~~~~~~~~~~~~~~~~~~~~~~ПРИМЕРЫ~~~~~~~~~~~~~~~~~~~~~~~*/
        /*ВЫЗОВ TOSTRING ДЛЯ ОБЪЕКТА*/
        stringFormat = "%s\n"; // вызов toString для объекта + переход на новую строку
        intArg = 33;
        formatter.format(stringFormat, intArg); // 33


        /*НЕСКОЛЬКО СПЕЦИФИКАТОРОВ*/
        stringFormat = "%s %d\n";
        stringArg = "мне уже";
        intArg = 33;
        formatter.format(stringFormat, stringArg, intArg); // мне уже 33


        /*НЕСКОЛЬКО СПЕЦИФИКАТОРОВ В УКАЗАННОМ ПОРЯДКЕ*/
        stringFormat = "%2$d %1$s\n"; //
        stringArg = "мне уже";
        intArg = 33;
        formatter.format(stringFormat, stringArg, intArg); // 33 мне уже


        /*ФЛАГИ*/
        intArg = 5;
        stringFormat = "всегда показывать знак:%+d\n";// +5
        formatter.format(stringFormat, intArg); // пробел 5 символов:    5


        /*ШИРИНА*/
        stringFormat = "пробел 5 символов:%5d\n";// ширина отступы
        formatter.format(stringFormat, intArg); // пробел 5 символов:    5
        stringFormat = "пробел 5 символов:%-5d, текст\n";// отступы и выравнивание по левому краю
        formatter.format(stringFormat, intArg); // пробел 5 символов:5    , текст


        /*ТОЧНОСТЬ*/
        doubleArg = 2.4532423523325233242342;
        stringFormat = "ограничить число символов до 5: %+.5f\n";// точность
        formatter.format(stringFormat, doubleArg); // ограничить число
        // символов до 5: 2.45324


        /*~~~~~~~~~~~~~~~~~~~~~~~ПРИМЕРЫ~~~~~~~~~~~~~~~~~~~~~~~*/
        /*%[индекс_аргумента$][флаги][ширина]символы_преобразования*/
        /* ВРЕМЯ
         * - а также альтернативная форма указания индекса */
        longArg = System.currentTimeMillis();
        stringFormat = "текущее время: %1$tH часов %<tM минут %<tS секунд (%1$tZ)\n";
        formatter.format(stringFormat, longArg); // текущее время: 17
        // часов 00 минут 38 секунд (EET)


        /*ДАТЫ И ВРЕМЕНИ*/
        stringFormat = "сегодня это %tc\n";
        formatter.format(stringFormat, dateArg); // Fri Mar 09 16:49:17 EET 2018


        /* А ТЕПЕРЬ ВЫВЕСТИ ВСЕ*/
        System.out.println(formatter.toString());


        /* У КЛАССА STRING ЕСТЬ СВОЙ СТАТИЧЕСКИЙ МЕТОД FORMAT()*/
        String formattedString = String.format("Мне уже %s года", 33);
        System.out.println(formattedString);
    }
}
