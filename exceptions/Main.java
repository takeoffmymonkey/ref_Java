package exceptions;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;

import types_references_annotations.my_annotations.Ntrstn;
/* ИСКЛЮЧЕНИЕ
 * - исключительное событие, которое происходит во время исполнения программы и нарушает нормальный
 * ход ее инструкций
 *
 * - оборачивается в объект-исключение и передается runtime системе
 *
 * - исключения могут происходить как в методах, так и в конструкторах
 *      - дальше под методами буду подразумевать оба*/


/* КЛАСС THROWABLE
 * public class Throwable
 * extends Object
 * implements Serializable
 * - является родителем всех классов ошибок и исключений
 * - только он или его наследники могут быть выброшены или словлены
 * - содержит снимок стека вызовов в момент возникновения исключительной ситуации
 * - может содержать дополнительную информацию об ошибке
 * - может включать подавленные исключения (см. ниже)
 * - может содержать исключение-причину
 *      - т.е. другой объект Throwable, который привел к созданию текущего
 *      - называется "цепь исключений"
 *      - напр. если исключение случилось на глубоком уровне абстракции
 *          - стоит изменить его для более высокого и подходящего
 *              - напр. чтобы скрыть детали реализации
 *      - ассоциируется с другим Throwable через:
 *          - либо конструктор, который принимает причину в качестве параметра
 *          - либо метод initCause(Throwable), который инициализирует причину по переданному параметру */


/* НЕКОТОРЫЕ МЕТОДЫ THROWABLE
 * - void addSuppressed(Throwable exception): добавляет указанное исключение к подавленным
 *
 * - Throwable getCause(): возвращает исключение, которое вызвало данное исключение или null, если
 * такого не было
 *
 * - String getMessage(): возвращает строку с деталями для данного исключения
 *
 * - StackTraceElement[] getStackTrace(): возвращает массив элементов стек трейса, каждый для
 * соответствующего фрейма
 *      - нулевой элемент - вершина стека, т.е. последний вызванный метод
 *
 * - Throwable[] getSuppressed(): возвращает массив всех исключений, которые были подавлены
 *
 * - Throwable initCause(Throwable cause): инициализирует причину исключения к указанному значению.
 *      - может быть вызван не более раза
 *      - не может быть вызван, если исключение было создано конструкторами Throwable(Throwable) или
 *      Throwable(String,Throwable)
 *      - обычно вызывается из конструктора или сразу после создания исключения
 *
 * - void printStackTrace(): печатает исключение и его обратный стек в стандартный ошибковый поток
 * (System.err)
 *      - первая строка - результат toString()
 *      - дальше данные, предварительно записанные методом fillInStackTrace()
 *          - ... означает, что остаток стек трейса исключения, которое вызвало данное, совпадает с
 *          вызванным
 *              - поэтому они заменяются на ...
 *                  - т.е. если стек внутреннего исключения A-B-C-D-E-F-G2, а внешнего A-B-C-Z
 *                      - то для внешнего будет показан стек Z-C-B-A
 *                      - а для внутреннего G2-F-E-D-C ... 'then 2 more'
 *          - с Java 7 снизу стек трейса печатаются подавленные исключения
 *              - что к чему относится видно по отступам
 *
 * - String toString(): краткое описание исключение:
 *      - имя класса-исключения : результат метода getLocalizedMessage() */


/* ОБРАБОТКА СИСТЕМОЙ
 * - проходит в обратном порядке от метода с исключением назад по стеку вызовов
 * - ищет в этих методах подходящий обработчик для типа объекта-исключения
 *      - если подходящий не найден - прерывается работа программы */


/* ТРЕБОВАНИЕ CATCH OR SPECIFY
 * - если код может вызвать ПРОВЕРЯЕМОЕ исключение, он должен быть заключен:
 *      - либо в try statement, которое ловит исключение соответствующим обработчиком
 *      - либо в метод, который указывает, что он может выбросить соответствующее исключение
 *          - (с помощью спецификатора throws)
 *
 * - весь Java код должен соответствовать данному требованию */


/* ВИДЫ ИСКЛЮЧЕНИЙ
 * - ПРОВЕРЯЕМОЕ (checked):
 *      - т.е. проверяемое компилятором
 *      - относится к требованию Catch or Specify
 *      - все исключения, кроме Error, RuntimeException и их подклассов
 *      - их можно предвидить при написании, но их возникновение не зависит от кода и от них можно
 *      восстановиться
 *
 * - НЕПРОВЕРЯЕМОЕ (unchecked):
 *      - т.е. не проверяемое компилятором
 *      - не относится к требованию Catch or Specify
 *      - Error, RuntimeException и их подклассы
 *      - от них либо нельзя восстановиться либо можно предвидеть и их возникновение зависит от кода
 *          - тогда нужно исправить сам код*/


/* СОЗДАНИЕ СОБСТВЕННОГО КЛАССА
 * - напр. для своей библиотеки
 * - называют обычно ClassNameException
 * - должны быть унаследованы от Throwable или более подходящего класса
 *      - не обязательно добавлять туда какой-либо функционал
 *      - если можно восстановиться от ошибки - исключение должно быть проверяемым
 *      - если нет - непроверяемым */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~РУЧНАЯ ОБРАБОТКА~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* БЛОК TRY
 * - код, генерирующий проверяемое исключение, должен быть заключен в блок try
 *
 * - после возникновения исключения дальнейший код в блоке не выполняется
 *      - но выполняется код обработчика в блоке catch
 *          - если catch генерирует соответствующий тип
 *              - если catch вообще есть
 *
 * - блок может быть отдельно для каждого объекта-исключения
 *      - нужно предоставить отдельный обработчик для каждого из них
 *
 * - может быть 1 для нескольких исключений
 *      - нужно предоставлять отдельные обработчики для разных типов объектов-исключений
 *
 * - может быть вложенным
 *      - если отсутствует оператор catch для нужного исключения, он ищется в обрамляющем блоке try
 *          - пока не будет найден подходящий саtch
 *              - или не закончатся все уровни вложенности
 *
 * - может иметь только finally либо только catch, либо и тот и другой
 *      - сам по себе try не может быть */


/* БЛОК CATCH
 * - ассоциируется с блоком try
 *      - может вообще отсутствовать
 *          - тогда обязательно должен быть finally
 *      - между блоками try и сatch не может быть другого кода
 *
 * - является обработчиком исключения
 *
 * - тип обрабатываемого исключения указывается аргументом в скобках ()
 *      - должен быть наследником Throwable
 *
 * - общается с объектом-исключением по имени переменной
 *      - идет в скобках после типа
 *
 * - пропускается, если:
 *      - в try не возникло исключения
 *      - тип обрабатываемого исключения не соответствует вызванному в блоке try
 *          - ищется подходящий обработчик выше по иерархии try / стека вызовов
 *      - выбрасывание происходит в catch на том же уровне иерархии
 *          - ищется подходящий обработчик выше по иерархии try / стека вызовов
 *
 * - выполнение программы продолжается с оператора, следующего сразу после блока операторов
 * try/catch
 *
 * - может быть несколько для 1 try:
 *      - либо несколько блоков 1 один за другим
 *      - либо 1 блок catch, но типы разделяются оператором ИЛИ |
 *          - начиная с Java 7
 *          - параметр неявно считается конечным (final)
 *          - не делает код ни проще, ни эффективнее
 *             - todo итоговые байт-коды содержат единственный блок общего оператора catch
 *
 * - на пути поиска подходящего типа обработчика используется первый подходящий
 *      - остальные пропускаются
 *      - родительский тип перехватит тип наследника!
 *          - для 1 try:
 *              - в 1 блоке catch:
 *                  - ошибка компилятора
 *              - в нескольких блоках catch:
 *                  - ошибка компилятора
 *          - при переходе вверх по иерархии (в т.ч. по вложенным try ):
 *              - checked:
 *                  - ошибка компилятора
 *              - unchecked:
 *                  - перехват
 *                      - дальнейшие саtch пропускаются
 *
 * - исключение можно генерировать и в блоке catch
 *      - обычно, чтобы изменить тип исключения
 *      - образуется цепочка исключений
 *      - обработчик ищется выше по иерархии, а не в следующих блоках catch на том же уровне */


/* БЛОК FINALLY
 * - ассоциируется с блоком try
 *      - может вообще отсутствовать
 *          - тогда обязательно должен быть catch
 *      - между блоками try и finally может быть только сatch
 *      - может быть не больше 1
 *
 * - выполняется всегда по завершении блока try/catch
 *     - сразу за ним
 *     - даже без возникновения исключения
 *     - даже с исключением другого типа
 *     - даже без обработки исключения
 *
 * - сюда полезно помещать код для освобождения ресурсов
 *      - т.к. можно забыть где-нибудь return, continue или break
 *      - но лучше воспользоваться try-with-resources
 *
 * - может не выполниться
 *      - если JVM выйдет в момент выполнения кода в try или catch
 *      - или будет прерван или убит поток
 *          - даже если программа будет работать и дальше
 *
 * - следует избегать return в блоке finally
 *      - т.к. возвращаемое отсюда значение может замаскировать возвращаемое значение из try/catch */



/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ВЫБРАСЫВАНИЕ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* THROWS
 * - метод может сообщать компилятору, какие исключения в нем могут произойти
 *      - компилятор требует ему сообщать только о выбрасывании проверяемых исключений
 *          - т.е. если в теле метода есть бросание непроверяемого исключения, то об этом даже не
 *          обязательно объявлять
 *      - к декларации метода после списка аргументов и перед фигурной скобкой нужно добавить throws
 *      и через запятую список выбрасываемых исключений
 *
 * - todo при вызове такого метода стоит перехватывать только то, что действительно стоит обработать
 *
 * - когда родительский ничего не выбрасывает или выбрасывает непроверяемое исключение, то метод
 * наследника:
 *      - может ничего не выбрасывать
 *      - может выбрасывать любое непроверяемое исключение
 *      - не может выбрасывать проверяемое исключение
 *          - ошибка компилятора
 *
 *  - когда родительский выбрасывает проверяемое исключение, то метод наследника:
 *      - может ничего не выбрасывать
 *      - может выбрасывать любое непроверяемое исключение
 *      - не может выбрасывать другое или более обобщенное проверяемое исключение
 *          - ошибка компилятора*/


/* THROW
 * - любой код, выбрасывающий исключение, использует throw
 *
 * - поток исполнения программы прерывается после throw
 *      - все последующие операторы не выполняются
 *          - компилятор даже не требует возвращения заявленного типа из метода!
 *      - компилятор предупреждает
 *
 * - throw нужен единственный аргумент - объект типа Throwable */


/*~~~~~~~~~~~~~~~~~~~~~~~~~~КЛАССЫ ИСКЛЮЧЕНИЙ + ИЕРАРХИЯ~~~~~~~~~~~~~~~~~~~~~~~~~~*/

/* НУЖНО ОБРАБАТЫВАТЬ (ПРОВЕРЯЕМЫЕ)
 * - ошибки, которые можно предвидеть в момент написания кода
 *      - но они не зависят от самого кода
 *          - в отличие от RuntimeException
 * - программа сможет продолжить работу в случае их возникновения
 *      - в отличие от Error
 *
 * - иерархия:
 *      - ReflectiveOperationException (суперкласс исключений, связанных с рефлексией)
 *          - IllegalAccessException
 *              - доступ к классу не разрешен
 *          - ClassNotFoundException
 *              - класс не найден
 *          - NoSuchMethodException
 *              - запрашиваемый метод не существует
 *          - NoSuchFieldException
 *              - запрашиваемое поле не существует
 *          - InstantiationException
 *              - попытка создать объект абстрактного класса или интерфейса
 *      - IOException (указывает на обшую ошибку ввода-вывода)
 *          - EOFException
 *              - неожиданное завершение файла или потока во время ввода
 *          - FileNotFoundException
 *              - не удалось открыть файл по указанному пути
 *      - SQLException
 *          - общие ошибки доступа к БД или другого рода
 *      - CloneNotSupportedException
 *          - попытка клонировать объект из класса, не реализующего Cloneable
 *      - InterruptedException
 *          - 1 поток исполнения прерван другим потоком */


/* ERROR И ПОДКЛАССЫ (НЕ НУЖНО ОБРАБАТЫВАТЬ)
 * - внутренние ошибки и ситуации, связанные с нехваткой ресурсов в испольняющей системе Java
 * - выбрасывается самой JVM
 * - обычно нельзя предугадать и обработать
 *      - можно попробовать, чтобы сообщить пользователю
 * - нельзя продолжить работу программы
 * - нельзя сгенерировать самостоятельно
 * - иерархия:
 *      - Error (в основном ненормальные условия программы)
 *          - ThreadDeath
 *              - выбрасывается в "потоке-жертве", когда вызывается устаревший Thread.stop()
 *              - несмотря, что это "нормальное" условие, его не нужно обрабатывать
 *          - VirtualMachineError (JVM сломалась или закончились ресурсы для дальнейшей работы)
 *              - UnknownError
 *                  - в JVM было выброшено неизвестное, но серьезное исключение
 *              - StackOverflowError
 *                  - стек переполнен из-за слишком глубой рекурсии
 *              - OutOfMemoryError
 *                 - JVM не может создать новый объект из-за нехватки памяти, а сборщик мусора не
 *                 может предоставить нужный объем */


/* RUNTIMEEXCEPTION (НЕ НУЖНО ОБРАБАТЫВАТЬ)
 * - неправильное использование API
 * - возникновение зависит от самого кода
 *      - поэтому должны быть исправлены в коде
 * - иногда можно и самому бросить NullPointerException
 *      - если, напр., в качестве аргумента ошибочно предоставлен null
 * - иерархия:
 *          - RuntimeException (исключения, которые могут быть выброшены в ходе нормальной работы JVM)
 *              - NoSuchElementException
 *                  - элемент по запросу метода отсутствует
 *              - IndexOutOfBoundsException
 *                  - выход за пределы (напр.) массива
 *              - ArithmeticException
 *                  - неверная арифметическая операция
 *              - ClassCastException
 *                  - неверное приведение типов
 *              - NullPointerException
 *                  - попытка обратиться к объекту по пустой ссылке null
 *              - IllegalArgumentException
 *                  - в метод передан запрещенный или не подходящий аргумент */


@Ntrstn("Исключение - исключительное событие, которое происходит во время исполнения программы и " +
        "нарушает нормальный ход ее инструкций. Такое событие оборачивается в объект-исключение и " +
        "передается runtime системе. Объект содержит информацию о событии: снимок стека вызовов в " +
        "момент возникновения исключительной ситуации, дополнительная информация об ошибке, а также, " +
        "возможно, другие подавленные исключения и причины-исключения (приведшие к данному)")

@Ntrstn("Исключения, зависящие от кода, могут возникать как в методах, так и в конструкторах. Далее " +
        "под методами будут подразумеваться оба")

@Ntrstn("Система пытается обработать исключение, для чего в обратном порядке от метода, вызвавшего " +
        "исключение, назад по стеку вызовов идет поиск в этих методахподходящего обработчика для " +
        "возникшего исключения")

@Ntrstn("Существует требование Catch or Specify, которое указывает, что если код способен вызвать " +
        "проверяемое исключение, то он должен быть заключен либо в try statement, которое ловит " +
        "исключение соответствующим обработчиком, либо в метод, который указывает, что он может " +
        "выбросить соответствующее исключение с помощью спецификатора throws. Данное требование " +
        "соблюдать обязательно")

@Ntrstn("Механизм исключений Java предназначен не только для обработки ошибок, происходящих во " +
        "время работы программы, т.е. тех, которые нельзя предусмотреть, но он также необходим для " +
        "обнаружения логических ошибок, которые не могут быть обнаружены компилятором")

@Ntrstn("Компилятор требует обрабатывать только проверяемые (компилятором) исключения - т.е. те, " +
        "которые можно предвидеть в момент написания кода, при возникновении которых программа сможет " +
        "работать дальше и их возникновение не зависит от кода самой программы - напр, невозможность " +
        "прочесть файл, из-за того, что он испорчен. Непроверяемые исключения не требуется " +
        "обрабатывать: это класс Error (и подклассы) - ошибки, при которых работу программы " +
        "невозможно продолжить - напр. из-за нехватка памяти; и класс RuntimeException (и подклассы) - " +
        "исключения, связанные с некачественным кодом программы, - напр. обращение к null-объекта " +
        "или выход за границы массива, - такие проблемы нужно исправлять в коде, а не обрабатывать")

@Ntrstn("Любой объект-исключение является объектом класса, унаследованного от класса Throwable, у " +
        "которого ключевыми являются методы: printStackTrace(): печатает исключение и его " +
        "обратный стек в стандартный ошибковый поток (System.err), getMessage() - возвращает строку " +
        "с деталями для данного исключения, toString() - краткое описание исключение, getCause() - " +
        "возвращает исключение, которое вызвало данное исключение или null, если такого не было, " +
        "getStackTrace(): возвращает массив элементов стек трейса, каждый для соответствующего фрейма")

@Ntrstn("Результат метода printStackTrace(): 1ая строка - результат toString(), затем стек трейс. " +
        "... 2 more - это для вложенных исключений - означает, что после места встречи стеков, они " +
        "совпадают (и поэтому не выводятся снова для второго метода). По отступам видно, где " +
        "вложенные")

@Ntrstn("Например, при написании собственной библиотеки может понадобится свой класс ошибок. Для " +
        "этого следует унаследоваться от Throwable или более подходящего класса. При это добавлять " +
        "дополнительный функционал не обязательно. Если можно восстановиться от ошибки - исключение " +
        "должно быть проверяемым, если нет - непроверяемым")

@Ntrstn("Блок try используется для заключения кода, способного вызвать проверяемое исключение. Он " +
        "также может быть вложенным. При этом после него обязательно должен идти либо блок catch " +
        "(любое количество) либо finally (только 1) либо оба. Между блоками try и catch не может " +
        "быть другого кода. Между блоками " +
        "try и finally может быть только код catch. После возникновения исключения дальнейший код в " +
        "блоке не выполняется, а ищется подходящий обработчик (блок catch)")

@Ntrstn("Поиск подходящего обработчика производится в блоках catch, которые ассоциированы с блоками " +
        "try (т.е. не могут существовать отдельно без try, при этом их может быть несколько, либо " +
        "1 для нескольких типов исключений (начиная с Java 7 можно перечислять | (оператором ИЛИ) - " +
        "при этом параметр неявно считается конечным (final)) либо вообще отстутствовать - в таком " +
        "случае обязательно должен быть блок finally). Между блоками try и catch не может быть " +
        "другого кода. После выполнения обработки, выполнение программы продолжается с оператора, " +
        "следующего сразу за блоком catch")

@Ntrstn("Тип обрабатываемого блоком catch исключения указывается рядом с аргументом в скобках () и " +
        "он должен быть наследником Throwable. К самому объекту внутри блока можно обратиться по " +
        "передаваемой в качестве аргумента переменной.")

@Ntrstn("Обработчик catch пропускается в 3 случаях: если в try не возникло исключения, если тип " +
        "обрабатываемого исключения не соответствует вызванному в блоке try и если выбрасывание " +
        "происходит в catch на том же уровне иерархии. В последних 2 случаях ищется подходящий " +
        "обработчик выше по иерархии try / вызовов")

@Ntrstn("На пути поиска подходящего типа обработчика используется первый подходящий, в т.ч. " +
        "родительского типа (обо всех родительских перехватах предупреждает компилятор, кроме " +
        "перехода вверх по иерархии (в т.ч. по вложенным try), и когда исключение при этом " +
        "непроверяемое)")

@Ntrstn("Выбросить исключение можно и в блоке catch, напр. чтобы переопределить его тип")

@Ntrstn("Блок finally также ассоциирован с блоком try. Блоков finally может быть 1 или 0 (в таком " +
        "случае обязательно должен быть catch)")

@Ntrstn("Блок finally выполняется почти всегда - даже без возникновения исключения или без его " +
        "обработки, поэтому сюда полезно помещать код, освобождающий занятые ресурсы (но лучше " +
        "воспользоваться блоком try-with-resources). Однако блок может не выполниться, если JVM " +
        "выйдет не дойдя до него, или будет прерван или убит поток (а программа может при этом " +
        "продолжать работу)")

@Ntrstn("Следует избегать return в блоке finally, т.к. возвращаемое отсюда значение может " +
        "замаскировать возвращаемое значение из try/catch")

@Ntrstn("Метод может сообщать о том, что он способен выбросить исключение (слово throws после скобок " +
        "и перед телом метода и (необязательно) слово throw в самом теле), но компилятор требует ему " +
        "сообщать только о выбрасывании проверяемых исключений, т.е. если в теле метода есть бросание " +
        "непроверяемого исключения, то об этом даже не обязательно объявлять перед телом метода")

@Ntrstn("Указывать выбрасывыемые исключения, которые на самом деле метод в своем теле не выбрасывает, " +
        "можно чтобы была возможность добавить их в будущем (если это, например, библиотека)")

@Ntrstn("Если в теле метода есть инструкция throw, то дальнейший код выполнен не будет (об этом " +
        "предупреждает компилятор), но это позволяет не возвращать из метода заявленный тип - т.е. " +
        "инструкция return вообще может отстутсвовать без жалоб компилятора!")

@Ntrstn("При переопределении родительского метода, бросающего исключения, метод-наследник может " +
        "ничего не выбрасывать, выбрасывать любое непроверяемое исключение, либо только проверяемое " +
        "исключение из родительского метода (или наследников его типа). Если родительский метод " +
        "ничего не бросает, то метод в наследнике может только ничего не выбрасывать или выбрасывать " +
        "любое непроверяемое исключение, но никакое проверяемое")

@Ntrstn("Конструктор может выкинуть любое исключение, не обращая внимание на то, какие исключения " +
        "выкидывает родительский конструктор. Тем не менее, он все равно обязан указать все " +
        "родительские исключения")

@Ntrstn("Когда не знаешь, что делать с выбрасываемым исключением, оберни его в RuntimeException")

public class Main {

    /* КОНСТРУКТОР ТОЖЕ МОЖЕТ ВЫБРАСЫВАТЬ ИСКЛЮЧЕНИЕ */
    public Main() throws IOException {
    }

    class SubMain extends Main {
        /*ПРИ НАСЛЕДОВАНИИ ОБЯЗАТЕЛЬНО УКАЗЫВАЕТСЯ ИСКЛЮЧЕНИЕ ИЗ РОДИТЕЛЬСКОГО КОНСТРУКТОРА*/
        public SubMain() throws IOException {
        }
    }


    /* ~~~~~~~~~~~~~~~~~~~~~~ОБРАБОТКА~~~~~~~~~~~~~~~~~~~~~~*/
    /* TRY МОЖЕТ БЫТЬ БЕЗ FINALLY, НО ТОГДА ДОЛЖЕН БЫТЬ CATCH*/
    static void tryWithoutFinally() {
        try {
        } catch (Exception e) {
        }
    }


    /* TRY МОЖЕТ БЫТЬ БЕЗ CATCH, НО ТОГДА ДОЛЖЕН БЫТЬ FINALLY*/
    static void tryWithoutCatch() {
        try {
        }
        //        int i = 3; // между try и finally может быть только catch
        finally {
        }
    }


    /* TRY МОЖЕТ БЫТЬ ВМЕСТЕ С CATCH И FINALLY ОДНОВРЕМЕННО */
    static void tryWithCatchAndFinally() {
        try {
        } catch (Exception e) {
        } finally {
        }
    }


    /* TRY МОЖЕТ БЫТЬ ВЛОЖЕННЫМ */
    /* ПОИСК ПОДХОДЯЩЕГО CATCH ИДЕТ ВВЕРХ ПО СТЕКУ*/
    static void tryNested() {
        try {
            try {
                try {
                    File file = null;
                    FileReader fileReader = new FileReader(file);
                } catch (ArithmeticException e) { // игнорируется
                }
            } catch (Exception e) { // будет словлено здесь
                throw new Throwable();
            } catch (Throwable e) { // игнорируется
            }
        } catch (Throwable e) { // будет словлено здесь
        }
    }


    /* ВЫПОЛНЕНИЕ БЛОКА TRY ПРЕРЫВАЕТСЯ ПОСЛЕ ВОЗНИКНОВЕНИЯ ИСКЛЮЧЕНИЯ */
    static void tryCodeIgnored() {
        try {
            System.out.println("try"); // будет выполнен
            int i = 2 / 0;
            System.out.println("try again"); // не будет выполнен
        } catch (Exception e) {
            System.out.println("catch"); // будет выполнен
        } finally {
            System.out.println("finally"); // будет выполнен
        }
    }


    /* НА 1 TRY МОЖЕТ БЫТЬ НЕСКОЛЬКО CATCH */
    static void oneTrySeveralCatch() {
        try {
            int i = 2 / 0;
            File file = null;
            FileReader fileReader = new FileReader(file);
        } catch (ArithmeticException e) {
        } catch (IOException e) {
        }
    }


    /* НА 1 TRY МОЖЕТ БЫТЬ НЕСКОЛЬКО CATCH - НАЧИНАЯ С JAVA 7 */
    static void oneTrySeveralCatch2() {
        try {
            int i = 2 / 0;
            File file = null;
            FileReader fileReader = new FileReader(file);
        } catch (ArithmeticException | IOException e) {
        }
    }


    /* ~~~~~~~~~~~~~~~ПЕРЕХВАТ РОДИТЕЛЕМ~~~~~~~~~~~~~~~*/
    static void parentCatch() {
        /* В 1 БЛОКЕ TRY / 1 БЛОКЕ CATCH - (UNCHECKED EXCEPTION)*/
//        try {
//            int i = 2 / 0;
//        } catch (ArithmeticException | Exception e) { // ошибка компилятора - родственники вместе
//        }

        /* В 1 БЛОКЕ TRY / 1 БЛОКЕ CATCH - (CHECKED EXCEPTION)*/
//        try {
//        File file = null;
//        FileReader fileReader = new FileReader(file);
//        } catch (IOException | Exception e) { // ошибка компилятора - родственники вместе
//        }

        /* В 1 БЛОКЕ TRY / НЕСКОЛЬКИХ БЛОКАХ CATCH - UNCHECKED EXCEPTION */
//        try {
//            int i1 = 2 / 0;
//        } catch (Exception e) {
//        } catch (ArithmeticException e) { // ошибка компилятора - уже есть перехват
//        }

        /* В 1 БЛОКЕ TRY / НЕСКОЛЬКИХ БЛОКАХ CATCH - CHECKED EXCEPTION */
//        try {
//            File file = null;
//            FileReader fileReader = new FileReader(file);
//        } catch (Exception e) {
//        } catch (IOException e) { // ошибка компилятора - уже есть перехват
//        }

        /* ВО ВЛОЖЕННЫХ TRY - UNCHECKED EXCEPTION */
        try {
            try {
                int i1 = 2 / 0;
            } catch (Exception e) { // перехват здесь
            }
        } catch (ArithmeticException e) { // сюда не дойдет
        }

        /* ВО ВЛОЖЕННЫХ TRY - CHECKED EXCEPTION */
//        try {
//            try {
//                File file = null;
//                FileReader fileReader = new FileReader(file);
//            } catch (Exception e) {
//            }
//        } catch (IOException e) { // ошибка компилятора
//        }

        /* ПРИ ПЕРЕХОДЕ ВВЕРХ ПО СТЕКУ ВЫЗОВОВ - UNCHECED EXCEPTION*/
        class Inner {
            void meth() {
                try {
                    int i1 = 2 / 0;
                } catch (Exception e) { // перехват здесь
                }
            }
        }
        Inner inner = new Inner();
        try {
            inner.meth();
        } catch (ArithmeticException e) { // сюда не дойдет
        }

        /* ПРИ ПЕРЕХОДЕ ВВЕРХ ПО СТЕКУ ВЫЗОВОВ - UNCHECED EXCEPTION*/
//        class Inner2 {
//            void meth() {
//                try {
//                File file = null;
//                FileReader fileReader = new FileReader(file);
//                } catch (Exception e) {
//                }
//            }
//        }
//        Inner2 inner2 = new Inner2();
//        try {
//            inner2.meth();
//        } catch (IOException e) { // ошибка компилятора
//        }
    }


    /* ИСКЛЮЧЕНИЯ МОЖНО ГЕНЕРИРОВАТЬ И В БЛОКЕ CATCH */
    static void catchException() {
        try {
            int i1 = 2 / 0;
        } catch (Exception e) {
            throw new ArithmeticException(e.getMessage()); // смена типа
        }
    }


    /* БЛОК FINALLY ОБЯЗАТЕЛЬНО ВЫПОЛНИТСЯ */
    static void finallyCodeNotIgnored() {
        try {
            try { // нет кода
            } finally { // нет обработки исключения
                System.out.println("finally"); // будет выполнен
            }
        } catch (Exception e) {
        }
    }


    /* МАСКИРОВКА ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ В FINALLY*/
    static int returnCollisions() {
        try {
            return 1; // не вернет 1
        } finally {
            return 0; // вернет 0
        }
    }


    /* ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДА, ГЕНЕРИРУЮЩЕГО ИСКЛЮЧЕНИЕ */
    static void overrideThrowing() {
        class Parent {
            void meth(int i) throws IOException {
            }
        }
        class Child extends Parent {
            @Override
                /* ВЫБРАСЫВАЕМОЕ ПРОВЕРЯЕМОЕ ИСКЛЮЧЕНИЕ НЕ ДОЛЖНО БЫТЬ ОБОБЩЕННЕЙ, ЧЕМ В РОДИТЕЛЬСКОМ */
            void meth(int i) throws IOException, ArithmeticException {
            }
        }
    }


    /* ПОТОК ВЫПОЛЕНИЯ ПРОГРАММЫ ПРЕРЫВАЕТСЯ ПОСЛЕ THROW */
    static int throwInterruption() {
        throw new ArithmeticException(); // не требует возвращения int
//        System.out.println("After throw"); // ошибка компилятора
    }


    /* ~~~~~~~~~~~~~~~~~~~~~~НЕКОТОРЫЕ МЕТОДЫ THROWABLE~~~~~~~~~~~~~~~~~~~~~~*/
    /*toString()*/
    static void toStringMeth() {
        try {
            int i = 2 / 0;
        } catch (Exception e) {
            System.out.println(e.toString());
//            java.lang.ArithmeticException: / by zero
        }
    }


    /*printStackTrace()*/
    static void printStackTraceMeth() {
        try {
            int i = 2 / 0;
        } catch (Exception e) {
            e.printStackTrace();
//            java.lang.ArithmeticException: / by zero // результат toString()
//            at exceptions.Main.printStackTraceMeth(Main.java:559) // последний метод
//            at exceptions.Main.main(Main.java:596) // предпоследний метод
        }
    }


    /*addSuppressed()*/
    static void addSuppressedMeth() {
        try {
            int i = 2 / 0;
        } catch (Exception e) {
            e.addSuppressed(new Exception("My suppressed"));
            e.printStackTrace();
//            java.lang.ArithmeticException: / by zero
//              at exceptions.Main.addSuppressedMeth(Main.java:579)
//              at exceptions.Main.main(Main.java:598)
//              Suppressed: java.lang.Exception: My suppressed // мое добавленное
//                  at exceptions.Main.addSuppressedMeth(Main.java:581)
//		            ... 1 more // т.е. встреча 2 исключений произошла в addSuppressedMeth,
// а ... 1 more - это Main.main(Main.java:598)
        }
    }

    /*getMessage(), getCause(), initCause()*/
    /* ЦЕПОЧКИ */
    static void getMessageAndGetCauseMeths() {
        try {
            try {
                int i = 2 / 0;
            } catch (Exception e) {
                throw new Exception("Chaining", e);
            }
        } catch (Exception e) {
            System.out.println(e.getMessage()); // Chaining
            System.out.println(e.getCause().toString()); // java.lang.ArithmeticException: / by zero
            try {
                throw new Exception().initCause(e.getCause()); // сохраняю изначальную причину
            } catch (Throwable throwable) {
                System.out.println(e.getCause().toString()); // java.lang.ArithmeticException: / by zero
            }
        }
    }
}