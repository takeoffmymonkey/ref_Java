package _numbers_conversion;

/* АВТОМАТИЧЕСКОЕ (НЕЯВНОЕ, РАСШИРЯЮЩЕЕ) ПРЕОБРАЗОВАНИЕ
 * - происходит:
 *   + при присваивании
 *   + в выражениях
 *
 * - при условии, что:
 *   + длина целевого типа равна или выше исходного
 *   + типы совместимы:
 *      - подписанный не может идти в не подписанный
 *      - c плавающей точкой не может идти в целое
 *      - не должен быть boolean */


/* ПРОДВИЖЕНИЕ ТИПОВ ПРИ ПРИСВАИВАНИИ:
 * - byte минимум в short
 * - short минимум в int
 * - char минимум в int
 * - int только в long или double
 * - int еще в float, но с возможной потерей точности
 * - long только в float или double с возможной потерей точности*/


/* ПРОДВИЖЕНИЕ ТИПОВ В ВЫРАЖЕНИЯХ
 * - 1. Если 1 из операндов в double – оба преобразуются в double
 * - 2. Иначе, если 1 в float – оба в float
 * - 3. Иначе, если в 1 long – оба в long
 * - 4. Иначе оба – в int
 * - (Результат выражения можно присвоить в более объемный тип)*/


/* ДЕФОЛТНЫЙ ТИП ЛИТЕРАЛОВ В ВЫРАЖЕНИЯХ (ВЕДУТ СЕБЯ КАК СООТВЕТСТВУЮЩИЕ ТИПЫ)
 * - Все литералы с плавающей точкой по дефолту относятся к типу double
 * - Все целочисленные литералы по дефолту относятся к типу int */


/* ДЕФОЛТНЫЙ ТИП ЛИТЕРАЛОВ ПРИ НАЗНАЧЕНИЯХ
 * - целочисленные (по дефолту является типом int):
 *   + при назначении в тип меньше, чем int, должен вмещаться в его диапазон или явно приводиться
 *   + при назначении в тип больше, должен быть не больше диапазона int, или явно указать l/L
 *   + преобразование в литерал с плавающей точкой происходит автоматически по целевому типу
 *
 * - с плавающей точкой (по дефолту является типом double):
 *   + при назначении в float, должен явно указать f/F
 *   + для преобразования в целочисленное требуется явное привидение*/


/* В ВЫРАЖЕНИЯХ СОВМЕЩЕННОГО ПРИСВАИВАНИЯ АВТОМАТИЧЕСКОГО ПРОДВИЖЕНИЯ НЕ ПРОИСХОДИТ!!!
 * - но происходит автоматическое приведение!
 * - запись: var @= expr, где @ - любой допустимый оператор (+, -, * и т.д.)
 * - срабатывает по формуле var = (typename) (v @ (expr))
 * - !!! т.е. возможна потеря данных без указания компилятора (переполнение)*/


/* ПОВЕДЕНИЕ ТИПОВ-ОБЕРТОК
 * - продвижение типов при присваивании: аналогично, только если присваивается в примитив
 * - продвижение типов в выражениях: полностью аналогично
 * - в выражениях совмещенного присваивания автоматического продвижения не происходит:
 *      + повышение аналогично не происходит (так же возможна потеря данных)
 *      + но работает не по той же формуле
 *      + операция возможна только с совместимым типом (с учетом повышения некоторых из них в
 * выражениях)*/


/*ТИПЫ
 * - byte (8-bit signed integers); MIN_VALUE: -128; MAX_VALUE: 127
 * - short (16-bit signed integers); MIN_VALUE: -32768; MAX_VALUE: 32767
 * - char (16-bit unsigned integers); MIN_VALUE: 0; MAX_VALUE: 65535
 * - int (32-bit signed integers); MIN_VALUE: -2147483648; MAX_VALUE: 2147483647
 * - long (64-bit signed integers); MIN_VALUE: -9223372036854775808; MAX_VALUE: 9223372036854775807
 * - float (32-bit floating point); MIN_VALUE (не отрицательное): 1.4E-45; MAX_VALUE: 3.4028235E38
 * - double (64-bit floating point); MIN_VALUE (не отрицательное): 4.9E-324; MAX_VALUE: 1.7976931348623157E308
 * - boolean (32-bit signed integers); false, true*/

public class Automatic {

    static byte byteA = 1;
    static short shortA = 1;
    static int intA = 1;
    static char charA = 1;
    static long longA = 1L;
    static float floatA = 1f;
    static double doubleA = 1;

    static Byte byteB = 1;
    static Short shortB = 1;
    static Integer intB = 1;
    static Character charB = 1;
    static Long longB = 1L;
    static Float floatB = 1f;
    static Double doubleB = 1d;


    public static void main(String[] args) {
        /* ПРОДВИЖЕНИЕ ПРИ ПРИСВАИВАНИИ */

        /* BYTE (8-bit signed integers) МИНИМУМ В SHORT (16-bit signed integers)*/
        shortA = byteA; // ok
        intA = byteA; // ok
        longA = byteA; // ok
        floatA = byteA; // ok
        doubleA = byteA; // ok
        // charA = byteA; // не совместимы из-за отсутствия подписи у char

        /* SHORT (16-bit signed integers) МИНИМУМ В INT (32-bit signed integers)*/
        intA = shortA; // ok
        longA = shortA; // ok
        floatA = shortA; // ok
        doubleA = shortA; // ok
        // charA = shortA; // не совместимы из-за отсутствия подписи у char
        // byteA = shortA; // сужающее

        /* CHAR (16-bit unsigned integers) МИНИМУМ В INT (32-bit signed integers)*/
        intA = charA; // ok
        longA = charA; // ok
        floatA = charA; // ok
        doubleA = charA; // ok
        //byteA = charA; //сужающее
        //shortA = charA; //не совместимы из-за отсутствия подписи у char

        /* INT БЕЗ ПОТЕРЬ ТОЛЬКО В LONG (64-bit signed integers) ИЛИ DOUBLE (64-bit floating point)
         * INT (32-bit signed integers) В FLOAT (32-bit floating point) С ВОЗМОЖНОЙ ПОТЕРЕЙ ТОЧНОСТИ*/
        longA = intA; // ok
        doubleA = intA; // ok
        floatA = intA; // ok, но возможны потери! (см. ниже)
        // byteA = intA; // сужающее
        // shortA = intA; // сужающее
        // charA = intA; // сужающее

        /* LONG (64-bit signed integers) ТОЛЬКО В FLOAT (32-bit floating point)
         * ИЛИ DOUBLE (64-bit floating point) И C ВОЗМОЖНОЙ ПОТЕРЕЙ ТОЧНОСТИ*/
        floatA = longA; // ok, но возможны потери! (см. ниже)
        doubleA = longA; // ok, но возможны потери! (см. ниже)
        // byteA = longA; // сужающее
        // shortA = longA; // сужающее
        // intA = longA; // сужающее
        // charA = longA; // сужающее

        /*ВОЗМОЖНЫЕ ПОТЕРИ ТОЧНОСТИ
         * - порядок останется тем же, но снизится точность
         * - потому что у чисел с плавающей точкой некоторые биты заняты для указания степени
         * - остается только мантисса (т.е. биты, выделенные под целую часть - остальное будет усечено)
         * - float использует 23-битную мантиссу (т.е. 2^23 или 8_388_608)
         * - double ипользует 52-битную мантиссу (т.е. 2^52 или 4_503_599_627_370_496)*/
        //TODO: разобраться, почему именно теряется точность
        /* INT В FLOAT */
        int intLongerThan23bit = 123_456_789;
        floatA = intLongerThan23bit;
        System.out.println(floatA); // даст 1.23456792E8, т.е. 123_456_792
        /* LONG В FLOAT И DOUBLE */
        long intLongerThan52bit = 123_456_789_123_456_789L;
        floatA = intLongerThan52bit;
        doubleA = intLongerThan52bit;
        System.out.println(floatA); // даст 123_456_791
        System.out.println(doubleA); // даст 123_456_789_123_456_784


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /*ПРОДВИЖЕНИЕ В ВЫРАЖЕНИЯХ*/

        /*1. ЕСЛИ 1 ИЗ ТИПОВ В DOUBLE - ОБА ПРЕОБРАЗУЮТСЯ В DOUBLE*/
        doubleA = doubleA + byteA;
        doubleA = doubleA + shortA;
        doubleA = doubleA + charA;
        doubleA = doubleA + intA;
        doubleA = doubleA + longA;
        doubleA = doubleA + floatA;
        // byteA = doubleA + byteA; // сужение, нельзя
        // shortA = doubleA + shortA; // сужение, нельзя
        // charA = doubleA + charA; // сужение, нельзя
        // intA = doubleA + intA; // сужение, нельзя
        // longA = doubleA + longA; // сужение, нельзя
        // floatA = doubleA + floatA; // сужение, нельзя

        /*2. ИНАЧЕ, ЕСЛИ 1 В FLOAT - ОБА ПРЕОБРАЗУЮТСЯ В FLOAT */
        floatA = floatA + byteA;
        floatA = floatA + shortA;
        floatA = floatA + charA;
        floatA = floatA + intA;
        floatA = floatA + longA;
        // byteA = floatA + byteA; // сужение, нельзя
        // shortA = floatA  + shortA; // сужение, нельзя
        // charA = floatA + charA; // сужение, нельзя
        // intA = floatA + intA; // сужение, нельзя
        // longA = floatA + longA; // сужение, нельзя

        /*3. ИНАЧЕ, ЕСЛИ 1 В LONG - ОБА ПРЕОБРАЗУЮТСЯ В LONG*/
        longA = longA + byteA;
        longA = longA + shortA;
        longA = longA + charA;
        longA = longA + intA;
        // byteA = floatA + byteA; // сужение, нельзя
        // shortA = floatA  + shortA; // сужение, нельзя
        // charA = floatA + charA; // сужение, нельзя
        // intA = floatA + intA; // сужение, нельзя

        /*4. ИНАЧЕ ОБА ПРЕОБРАЗУЮТСЯ В INT*/
        intA = intA + byteA;
        intA = intA + shortA;
        intA = intA + charA;
        // byteA = byteA + byteA; // сужение, нельзя
        // shortA = shortA + shortA; // сужение, нельзя
        // charA = charA + charA; // сужение, нельзя

        /* РЕЗУЛЬТАТ МОЖНО ЗАПИСАТЬ В БОЛЕЕ ОБЪЕМНЫЙ ТИП*/
        doubleA = byteA + shortA;
        floatA = charA + intA;
        longA = intA + intA;


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /* ДЕФОЛТНЫЙ ТИП ЛИТЕРАЛОВ В ВЫРАЖЕНИЯХ (ВЕДУТ СЕБЯ КАК СООТВЕТСТВУЮЩИЕ ТИПЫ)
         * - Все литералы с плавающей точкой по дефолту относятся к типу double
         * - Все целочисленные литералы по дефолту относятся к типу int */
        System.out.println(((Object) 5555.4).getClass().getName()); // даст java.lang.Double
        System.out.println(((Object) 55555).getClass().getName()); // даст java.lang.Integer
        doubleA = byteA + 2.342; // 2.342d - double, следовательно byteA повышается до double
        doubleA = shortA + 2.342; // аналогично
        doubleA = charA + 2.342d; // аналогично
        // floatA = byteA + 2.342d; // нельзя из-за сужения
        // floatA = shortA + 2.342d; // нельзя из-за сужения
        // floatA = charA + 2.342d; // нельзя из-за сужения
        intA = byteA + 2; // 2 - int, следовательно byteA повышается до int
        intA = shortA + 2; // аналогично
        intA = charA + 2; // аналогично
        // byteA = byteA + 2; // нельзя из-за сужения
        // shortA = shortA + 2; // нельзя из-за сужения
        // charA = charA + 2; // нельзя из-за сужения


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /* ДЕФОЛТНЫЙ ТИП ЛИТЕРАЛОВ ПРИ НАЗНАЧЕНИЯХ
         * - целочисленные (по дефолту является типом int):
         *   + при назначении в тип меньше, чем int, должен вмещаться в его диапазон или явно приводиться
         *   + при назначении в тип больше, должен быть не больше диапазона int или явно указать l/L
         *   + преобразование в литерал с плавающей точкой происходит автоматически по целевому типу
         *
         * - с плавающей точкой (по дефолту является типом double):
         *   + при назначении в float, должен явно указать f/F
         *   + для преобразования в целочисленное требуется явное привидение*/
        /*ЦЕЛОЧИСЛЕННЫЕ*/
        intA = 123123; // ок, так как по дефолту int
        byteA = 127; // ок, так как 127 вмещается в byte
        // byteA = 128; // ошибка компилятора, требуется явное приведение
        longA = 1231231; // ок, так как не превышает диапазон int
        // longA = 1231231234344; // ошибка компилятора
        // longA = (long) 1231231234344; // все равно ошибка компилятора
        longA = 1231231234344L; // ок, так как явно указано l/L
        doubleA = 132; // авто-преобразование, не требует явного указания типа (выводится?)
        floatA = 132; // авто-преобразование, не требует явного указания типа (выводится?)

        /*С ПЛАВАЮЩЕЙ ТОЧКОЙ*/
        doubleA = 33.3; // ок, так как по дефолту double
        doubleA = 33.3f; // ок, так как целевой тип шире исходного
        // floatA = 33.3; // сужение, нужно указать тип float явно
        floatA = 33.3f; // ок, тип указан явно
        //byte b = 234.4; // требуется явное приведение
        byteA = (byte) 234.4; // ок


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /*В ВЫРАЖЕНИЯХ СОВМЕЩЕННОГО ПРИСВАИВАНИЯ АВТОМАТИЧЕСКОГО ПРОДВИЖЕНИЯ НЕ ПРОИСХОДИТ!!!
         * - но происходит автоматическое приведение!
         * - запись: var @= expr, где @ - любой допустимый оператор (+, -, * и т.д.)
         * - срабатывает по формуле var = (typename) (v @ (expr))*/
        intA = byteA + 129;// ок, т.к. целочисленный литерал это int, byte в выражениях тоже int
        // byteA = byteA + 129; // не ок, т.к. результат int и его нельзя вписать в byte
        byteA = 0;
        byteA += 129; // то же, что byteA = (byte) (byteA + 129)
        // !!! позволяет компилятор, но происходит потеря данных (переполнение)!!!
        System.out.println(byteA); // даст -127


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /*ПОВЕДЕНИЕ ТИПОВ-ОБЕРТОК*/

        /*ПРОДВИЖЕНИЕ ТИПОВ ПРИ ПРИСВАИВАНИИ
         * - примитиву можно присвоить значение обложки по правилам присваивания примитивов
         * - обложке можно присвоить только значение соответствующего типа примитива*/
        shortA = byteB; // ок, примитив принимает значение обложки по стандартным правилам
        doubleA = intB; // ок, примитив принимает значение обложки по стандартным правилам
        // shortA = intB; // не ок, примитив принимает значение обложки по стандартным правилам
        doubleB = doubleA; // обложке можно присвоить только значение соответствующего типа примитива
        // doubleB = intA; // обложке нельзя присвоить значение несоответствующего типа примитива
        // doubleB = floatB; // обложке нельзя присвоить значение обложки другого типа

        /*ПРОДВИЖЕНИЕ ТИПОВ В ВЫРАЖЕНИЯХ
         * - аналогично примитивам*/
        doubleB = doubleA + floatB; // ок, результат double
        // floatA = doubleA + floatB; // не ок, результат double
        floatA = floatB + byteB; // ок, результат float
        longA = longB + shortB; // ок, результат long
        //intB = longB + shortB; // не ок, результат long
        intB = byteB + byteA; // ок, результат int
        // byteB = byteB + byteB; // нет, так как результат int
        // shortB = byteB + byteB; // нет, так как результат int


        /*В ВЫРАЖЕНИЯХ СОВМЕЩЕННОГО ПРИСВАИВАНИЯ АВТОМАТИЧЕСКОГО ПРОДВИЖЕНИЯ НЕ ПРОИСХОДИТ!!!
         * - повышение аналогично не происходит (так же возможна потеря данных)
         * - но работает не по той же формуле
         * - операция возможна только с совместимым типом (с учетом повышения некоторых из них в
         * выражениях)*/
        // byteB = byteB + 1; // аналогично - не дает вписать int в байт
        // byteB += 1; // НЕ АНАЛОГИЧНО - все еще не дает вписать int в байт
        byteB = (byte) (byteB + 1); // формула при этом работает
        // byteB += byteB; // не ок, так как Byte повышается до int
        intB += byteB; // ок, так как Byte повышается до int
        intB += 2_066_666_666; // ок, т.к. обложка принимает тип литерала (возможна потеря данных)
        intB += intB; // ок, так как тип совместим
        //intB += longB;
        longB += 2_066_666_666; // ок, т.к. обложка принимает тип литерала (возможна потеря данных)
        doubleB += 0.3; // ок, т.к. обложка принимает тип литерала (возможна потеря данных)
        floatB += 0.3f; // ок, т.к. обложка принимает тип литерала (возможна потеря данных)
    }
}