package _oop_polymorphism;

import java.util.ArrayList;
import java.util.List;

import _types_references_annotations.my_annotations.Ntrstn;

/* ПОЛИМОРФИЗМ - МНОГООБРАЗИЕ ФОРМ (РЕАЛИЗАЦИИ) И 1 ИНТЕРФЕЙС ВЗАИМОДЕЙСТВИЯ С НИМИ
 * - работает в связке с абстакцией, наследованием, переопределением методов, восходящим приведением
 * и динамической диспетчеризацией методов
 *      - абстракция
 *          - работа с общим (родительским) интерфейсом без деталей реализации (в наследниках)
 *
 *      - наследование
 *          - наследник получает родительские методы с возможностью их переопределить
 *              - наследник здесь - это класс, переопределяющий методы класса-родителя или методы
 *              интерфейса, который он имплементирует
 *
 *      - переопределение родительских методов
 *          - полученным при наследовании методам можно предоставить свою реализацию
 *
 *      - приведение
 *          - возможность назначить родительской ссылке объект-наследник
 *
 *      - динамическая диспетчеризация методов
 *          - вызов правильного метода у наследника по родительской ссылке
 *
 * - позволяет:
 *      - работать с типом как с родителем, игнорируя детали реализации самого наследника
 *          - при помощи восходящего преобразования и переопределения методов в наследниках
 *          - т.е. вызов родительского метода приводит к запуску переопределенного метода в
 *          (неважно каком) наследнике, который находится сейчас по родительской ссылке
 *
 *      - отделить реализацию от интерфейса
 *          - т.е. общим интерфейсом являются родительские методы, а их реализация в наследниках
 *          скрыта
 *
 *      - отделить изменяемое от неизменного
 *          - т.е. код работает с родительским типом и при добавлении нового наследника, код менять
 *          не нужно
 *
 *      - сократить объем кода
 *          - т.е. не нужно писать код для работы с каждым наследником, достаточно 1 кода для работы
 *          с родителем
 *
 * - касается только методов, но не полей класса
 *      - чтобы обратиться к полю класса наследника по ссылке родительского типа, нужно сделать
 *      ручное приведение при обращении */

@Ntrstn("Полиморфизм по сути означает работу с разными реализациями (в наследниках) методов через " +
        "один общий (родительский) интерфейс методов. Т.е. я могу одним образом обратиться к любому " +
        "наследнику")

@Ntrstn("В полиморфизме под наследником подразумевается общий случай реализации (через " +
        "переопределение) методов, полученных свыше. Т.е. это может быть и обычный класс-наследник, " +
        "переопределяющий родительские методы и просто класс, реализующий методы интерфейса")

@Ntrstn("Полиморфизм обеспечивается абстракцией (работа с 1 общим интерфейсом), наследованием (" +
        "получение родительских методов для переопределения), переопределением (полученных от " +
        "родителя) методов, восходящим преобразованием (назначение объекта-наследника родительской " +
        "ссылке) и динамической диспетчеризацией методов (вызов в runtime реального метода в объекте, " +
        "вне зависимости от типа его ссылки)")

@Ntrstn("Полиморфизм позволяет работать с объектом как с его родителем, игнорируя конкретику его " +
        "реализации, отделить реализацию от интерфейса, т.е. изменяемое от неизменного (можно менять " +
        "код конкретной реализации, но места, где он вызывается, не меняются) и сократить объем кода, " +
        "который иначе пришлось бы расходовать на вызовы каждой реализации в наследнике")

@Ntrstn("Динамаческое связывание работает только для методов, но не полей класса! Поэтому по вызову " +
        "поля класса у объекта-наследника через родительскую ссылку, будет вызвано поле родителя. " +
        "Чтобы корректно обратиться к полю в наследнике через такую ссылку, нужно при обращении " +
        "вручную привести его к наследнику")

@Ntrstn("Благодаря полиморфизму можно реализовать паттерн Стратегия - есть метод, который получает " +
        "определенный родительский тип, а внутри метода для переданного объекта вызывается " +
        "конкретная реализация какого-то из переопределенных методов")
class OverloadParent {
    /*ПОЛЕ*/
    String s = "Parent field";

    /* ПЕРЕГРУЖЕННЫЙ МЕТОД РОДИТЕЛЯ ТАКЖЕ НАСЛЕДУЕТСЯ */
    void overload() {
    }
}

class Overload extends OverloadParent {
    String s = "Child field";

    void overload(double d) {
    }

    void overload(String s) {
    }
}

class OverrideParent implements Identifyable {
    void identifyYourself() {
        System.out.println("I am OverrideParent");
    }

    @Override
    public void identifyViaInterface() {
        identifyYourself();
    }
}

class OverrideChild extends OverrideParent {
    @java.lang.Override
    void identifyYourself() {
        System.out.println("I am OverrideChild");
    }

    @Override
    public void identifyViaInterface() {
        identifyYourself();
    }
}

interface Identifyable {
    void identifyViaInterface();
}

public class Main {

    public static void main(String[] args) {
        /* */
        OverloadParent overloadParent = new Overload();
        System.out.println(overloadParent.s); // Parent field
        System.out.println(((Overload) overloadParent).s); // Child field


        /* СТАТИЧЕСКИЙ ПОЛИМОРФИЗМ МЕТОДОВ КЛАССА */
        new Overload().overload(); // родительские методы также учавствуют в перегрузке
        new Overload().overload(0); // может происходить автоматическое приведение
        new Overload().overload("zero");

        /* ДИНАМИЧЕСКИЙ ПОЛИМОРФИЗМ КЛАССОВ */
        List<OverrideParent> list = new ArrayList<>();
        list.add(new OverrideParent());
        list.add(new OverrideChild());

        identifyOverrideClass(list); // 1 метод работает для обоих типов объектов

        /* ДИНАМИЧЕСКИЙ ПОЛИМОРФИЗМ ИНТЕРФЕЙСОВ */
        List<Identifyable> list2 = new ArrayList<>();
        list2.add(new OverrideParent());
        list2.add(new OverrideChild());

        identifyOverrideInterface(list2); // 1 метод работает для обоих типов объектов

    }

    static void identifyOverrideClass(List<OverrideParent> overrideList) {
        for (OverrideParent overrideParent : overrideList) {
            overrideParent.identifyYourself();
        }
    }

    static void identifyOverrideInterface(List<Identifyable> overrideList) {
        for (Identifyable overrideParent : overrideList) {
            overrideParent.identifyViaInterface();
        }
    }
}