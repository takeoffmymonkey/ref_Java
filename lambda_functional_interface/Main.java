package lambda_functional_interface;

import com.sun.istack.internal.NotNull;

import java.util.Arrays;


/* ЛЯМБДА-ВЫРАЖЕНИЕ
 * - можно читать так:
 *      - (что приходит) -> (что выходит)
 * - указывает входящие параметры для метода
 * - реализует данный метод (вероятно, как-то обрабатывая принятые параметры)
 * - данный метод берется из функционального интерфейса (он там единственный)
 * - затем код этой реализации можно использовать отложенно и многократно:
 *      - в отдельном потоке
 *          - напр. действие, которое нужно выполнить в Thread
 *      - при наступлении какого-нибудь события
 *          - напр. щелчка на экранной кнопке
 *          - напр. поступления данных
 *      - в нужный момент по ходу алгоритма
 *          - напр., выполнение операции сравнения при сортировке
 *
 * - использовать нужно в тех местах, где требуется экземпляр класса, реализующий данный Ф.И.:
 *      - напр. как аргумент у метода, которому нужен для работы экземпляр данного функционального
 *      интерфейса
 *      - т.е. получается, что с реализацией метода можно обращаться как с объектом */


/* СИНТАКСИС
 * - Общий вид:
 *       1. В скобках через запятую список параметров, которые требуются в Л-В:
 *           - (String first, String second)
 *               - тип параметра, если он может быть выведен (напр. по типу абстрактного метода Ф.И.),
 *               можно не указывать:
 *                   - (first, second)
 *               - если параметр только 1, скобки можно опустить:
 *                   - first
 *                   - тип параметра указать без скобок не получится
 *               - если параметров нет или больше одного, ставятся скобки
 *                   - ()
 *           - могут иметь аннотации или модификаторы
 *               - только, если полностью указаны параметры:
 *                  - (final String first, @NotNull String second)
 *
 *       2. Стрелочный оператор ->:
 *           - означает "становиться", "переходить"
 *               - т.е. слева от стрелки параметры, а справа - то, что с ними должно произойти
 *
 *       3. Тело выражения:
 *           - должно состоять из:
 *               - либо 1 выражения
 *                  - return не обязателен (он такой же, как у абстрактного метода Ф.И.)
 *               - либо блочного выражения
 *                   - в фигурных скобках
 *                   - может быть пустым
 *                   - нужен return
 *                      - если он есть у соответствующего абстрактного метода Ф.И.
 *
 *
 * - Вид "ссылка на (существующий) метод/конструктор":
 *   - ссылка равнозначна Л-В, снабжающему метод/конструктор параметрами:
 *       - когда тело выражения можно представить существующим методом/конструктором
 *       - и список передаваемых параметров совпадает с параметрами такого метода/конструктора
 *       - допускается указывать ссылку this и super
 *       - виды:
 *           - Объект::метод экземпляра
 *              - когда обобщенный метод указывается как метод экземпляра, его аргумент типа
 *              указывается после :: и перед именем этого метода:
 *                  count = myOp (MyArrayOps::<Integer>countMatching, vals, 4)
 *           - Класс::статический метод
 *               - напр. System.out::println эквивалентно x -> System.out.println(x)
 *               - напр. Math::pow эквивалентно (x, y) -> Math.pow(x, y)
 *           - Класс::new - вызов конструктора класса
 *              - тип[]::new - создание ссылки на конструктор массива
 *
 *   - первый параметр становится целевым объектом метода:
 *       - Класс::метод экземпляра
 *           - String::compareToIgnoreCase - то же, что и (x, y) -> x.compareToIgnoreCase(y) */


/* СУЩНОСТЬ - ГИБРИД ВЛОЖЕННОГО БЛОКА КОДА И МЕТОДА АНОНИМНОГО КЛАССА
 * - все случаи использования Л-В можно заменить анонимным классом
 *      - но код будет выглядеть захламленным
 * - только случаи реализации анонимным классом метода Ф.И. можно заменить на Л-В
 * - так же, как и анонимный класс:
 *      - есть доступ ко всем членам обрамляющего класса
 *      - имеет доступ к локальным переменным, если они final или эффективно финализированы
 *      - не может иметь статических элементов
 *      - локальные переменные не могут иметь модификаторов доступа
 *      - доступ к методу - через экземпляр функционального интерфейса
 *      - todo захватывает переменные
 *
 * - в отличие от анонимного класса:
 *      - все переменные являются только локальными, и не могут быть членами класса
 *          - т.к. это не класс
 *              - поэтому у них не может быть модификаторов доступа
 *      - л-в принадлежит обрамляющему классу, как блок кода:
 *          - this y анонимного ссылается на сам анонимный класс
 *          - this у Л-В ссылается на обрамляющий класс
 *              - поэтому нет проблем с затемнением:
 *                  - не наследует имен от супертипа
 *                  - не вводит новую область действия */


/* ДЛЯ Л-В НУЖЕН СУЩЕСТВУЮЩИЙ ФУНКЦИОНАЛЬНЫЙ ИНТЕРФЕЙС
 * - Ф.И.- имеет только 1 абстрактный метод
 *      - в нем определяется предполагаемое назначение интерфейса
 *          - т.е. представляет 1 действие
 *
 * - может, помимо этого, иметь статические и дефолтные методы
 *      - todo они обычно используются для конкретных реализаций
 *
 * - абстрактный метод должен быть совместим с Л-В по:
 *      - возвращаемому типу
 *      - количеству параметров
 *      - типу параметров:
 *          - тип параметра Л-В должен явно или неявно выводиться из контекста в такой же тип, как у
 *          абстрактного метода
 *      - генерируемым исключениям
 *          - если реализация может вернуть исключение, то:
 *              - либо абстрактный метод должен объявить о выбрасывании такого исключения
 *              - либо реализация сама должна обработать исключение
 *
 * - можно использовать аннотацию @FunctionalInterface
 *      - тогда компилятор удостоверится, что интерфейс имеет только 1 абстрактный метод
 *
 * - может быть обобщенным (см. java.util.function)
 *      - в отличие от самого Л-В
 *          - если не учитывать выведение типов
 *      - в таком случае целевой тип Л-В отчасти определяется аргументом типа или теми аргументами,
 *      которые указываются при объявлении ссылки на Ф.И.
 *      - напр. Consumer <T>*/


/* Л-В МОЖНО ИСПОЛЬЗОВАТЬ ТОЛЬКО В КОНТЕКСТЕ, ГДЕ КОМПИЛЯТОР СМОЖЕТ ОПРЕДЕЛИТЬ ЕГО ЦЕЛЕВОЙ ТИП
 * - ЦЕЛЕВОЙ ТИП - тип, ожидаемый абстрактным методом от Л-В
 *      - т.е. для Л-В целевым типом является тип его Ф.И.
 *
 * - когда Л-В появляется в контексте своего целевого типа, автоматически создается экземпляр
 * класса, реализующего Ф.И., а Л-В определяет поведение его абстрактного метода
 *
 * - КОНТЕКСТЫ, в которых компилятор сможет определить целевой тип Л-В:
 *       - объявление переменных
 *       - назначения значения
 *       - выражения приведения
 *       - тело Л-В
 *       - return statements
 *       - todo условные выражения:
 *       - todo тернарные выражения:
 *       - todo инициализаторы массивов
 *       - аргументы метода или конструктора
 *          - может возникнуть конфликт при выборе правильного из перегруженных:
 *              - todo для определения целевого типа будут использованы:
 *                  - разрешение при перегрузке методов
 *                  - выведение типа аргумента*/


/* ДРУГИЕ ОСОБЕННОСТИ
 * - если блочное выражение кажется слишком длинным для встраивания в вызов метода, то его можно
 * просто присвоить переменной ссылки на Ф.И.
 *
 * - todo открытые методы класса Object считаются неявными членами Ф.И., поскольку они автоматически
 * реализуются экземпляром функционального интерфейса
 *
 * - технически состоит из 3 элементов:
 *      - параметры
 *      - блок кода
 *      - todo значения свободных переменных
 *          - СВОБОДНЫЕ ПЕРЕМЕННЫЕ - не являются параметрами и не определены в блоке кода, но из
 *          блока к ним есть доступ
 *          - Л-В можно преобразовать в объект с 1 методом, а значения свободных переменных
 *          копируются в переменные экземпляра этого объекта
 *          - формально блок кода со значениями свободных переменных называется замыканием
 *              - т.о. в J Л-В служат в качестве замыканий*/


/* ДЛЯ Л-В НУЖЕН СУЩЕСТВУЮЩИЙ ФУНКЦИОНАЛЬНЫЙ ИНТЕРФЕЙС */
@FunctionalInterface
interface IFunctional {
    /* ОБЯЗАТЕЛЬНО СОДЕРЖИТ ТОЛЬКО 1 АБСТРАКТНЫЙ МЕТОД*/
    void onlyMethod(String s);

    /* МОЖЕТ ТАКЖЕ ИМЕТЬ ДЕФОЛТНЫЕ МЕТОДЫ*/
    default void anotherMeth(String s) {
        System.out.println(s);
    }

    /* МОЖЕТ ТАКЖЕ ИМЕТЬ СТАТИЧЕСКИЕ МЕТОДЫ*/
    static void staticAnotherMeth(String s) {
        System.out.println(s);
    }
}


public class Main {
    Main main = new Main();
    int classVar;


    /*~~~~~~~~~~~~СУЩЕСТВУЮЩИЕ МЕТОДЫ ТАКЖЕ МОЖНО ИСПОЛЬЗОВАТЬ В КАЧЕСТВЕ РЕАЛИЗАЦИЙ Ф.И.~~~~~~~~~~~~*/
    void classMeth(String s) {
        System.out.println(s);
    }

    void staticClassMeth(String s) {
        System.out.println(s);
    }


    /*~~~~~~~~~~~~~~~~~~~~~~РЕАЛИЗАЦИЯ ФУНКЦИОНАЛЬНОГО ИНТЕРФЕЙСА~~~~~~~~~~~~~~~~~~~~~~*/
    /* РЕАЛИЗАЦИЯ АНОНИМНЫМ КЛАССОМ */
    IFunctional iFunctional = new IFunctional() {
        @Override
        public void onlyMethod(String s) {
            System.out.println(s);
        }
    };

    /* РЕАЛИЗАЦИЯ Л-ВЫРАЖЕНИЕМ */
    IFunctional iFunctional1 = (s) -> System.out.println(s);


    /*~~~~~~~~~~~~~~ССЫЛКА НА СУЩЕСТВУЮЩИЙ МЕТОД/КОНСТРУКТОР~~~~~~~~~~~~~~*/
    /* ССЫЛКА НА СУЩЕСТВУЮЩИЙ МЕТОД ЭКЗЕМПЛЯРА */
    IFunctional iFunctional2 = main::classMeth; // s -> this.classMethod(s)


    /*ССЫЛКА НА СУЩЕСТВУЮЩИЙ СТАТИЧЕСКИЙ МЕТОД*/
    @FunctionalInterface
    interface IPrintString {
        void print(String s);
    }

    IPrintString iPrintString = System.out::println; // s -> System.out.println(s)


    /*ССЫЛКА НА СУЩЕСТВУЮЩИЙ СТАТИЧЕСКИЙ МЕТОД*/
    @FunctionalInterface
    interface IPower {
        double power(double d1, double d2);
    }

    IPower iPower = Math::pow; // (x, y) -> Math.pow(x, y)

    /*ССЫЛКА НА СУЩЕСТВУЮЩИЙ КОНСТРУКТОР*/
    @FunctionalInterface
    interface IGetObject {
        Object getObject();
    }

    IGetObject iGetObject = Object::new; // () -> Object();


    /*ПЕРВЫЙ ПАРАМЕТР СТАНОВИТСЯ ЦЕЛЕВЫМ ОБЪЕКТОМ МЕТОДА*/
    @FunctionalInterface
    interface ICompareTwoStrings {
        int getObject(String s1, String s2);
    }

    ICompareTwoStrings iCompare = String::compareToIgnoreCase; // (x, y) -> x.compareToIgnoreCase(y)


    /*~~~~~~~~~~~~~~~~~~~~АБСТРАКТНЫЙ МЕТОД МЕТОД ДОЛЖЕН БЫТЬ СОВМЕСТИМ С Л-В~~~~~~~~~~~~~~~~~~~~*/
    @FunctionalInterface
    interface ICompatibility {
        /* - ПО ТИПУ ПАРАМЕТРОВ
         * - ПО КОЛИЧЕСТВУ ПАРАМЕТРОВ
         * - ПО ВОЗВРАЩАЕМОМУ ТИПУ
         * - ПО ГЕНЕРИРУЕМЫМ ИСКЛЮЧЕНИЯМ */
        double compatibility(int v, double v2, String operation) throws InterruptedException;
    }

    /*МОГУТ ИМЕТЬ МОДИФИКАТОРЫ И АННОТАЦИИ*/
    // типы параметров должны совпадать
    ICompatibility iCompatibility = (int a, final double b, @NotNull String s) -> {
        // количество параметров должно совпадать
        Thread.sleep(1000); // метод может вернуть InterruptedException
        return a; // должен возвращать тот же return type (или автоматически в него конвертировать)
    };


    /*~~~~~~~~~~~~~~КОНТЕКСТЫ, В КОТОРЫХ КОМПИЛЯТОР СМОЖЕТ ОПРЕДЕЛИТЬ ЦЕЛЕВОЙ ТИП~~~~~~~~~~~~~~*/
    @FunctionalInterface
    interface IContext {
        int context(int i);
    }

    @FunctionalInterface
    interface IContext2 {
        IContext context();
    }

    IContext contextMeth(IContext cont) {
        /*ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ*/
        IContext context = i -> i;

        /* НАЗНАЧЕНИЕ ЗНАЧЕНИЯ */
        context = i -> i;

        /* АРГУМЕНТЫ МЕТОДА / КОНСТРУКТОРА */
        contextMeth(i -> i);

        /*ВЫРАЖЕНИЯ ПРИВЕДЕНИЯ*/
        context = (IContext) i -> i;

        /* todo ИНИЦИАЛИЗАТОРЫ МАССИВОВ */
        IContext[] contexts = new IContext[4];
        Arrays.setAll(contexts, i -> i);

        /* ТЕЛО Л-В*/
        IContext2 context2 = () -> i -> i;

        /* todo УСЛОВНЫЙ ОПЕРАТОР */

        /* todo ТЕРНАРНЫЕ ВЫРАЖЕНИЯ */

        /* ИНСТРУКЦИИ RETURN */
        return i -> i;
    }


    /*~~~~~~~~~~~~~~КОНФЛИКТ ПЕРЕГРУЖЕННЫХ МЕТОДОВ/КОНСТРУКТОРОВ~~~~~~~~~~~~~~*/
    @FunctionalInterface
    interface IConflict1 {
        void conflict();
    }

    @FunctionalInterface
    interface IConflict2 {
        void conflict(int i);
    }

    @FunctionalInterface
    interface IConflict3 {
        int conflict(int i);
    }

    @FunctionalInterface
    interface IConflict4 {
        String conflict(int i);
    }

    void methConflict(Object o) {
    }

    void methConflict(IConflict1 c) {
    }

    void methConflict(IConflict2 c) {
    }

    void methConflict(IConflict3 c) {
    }

    void methConflict(IConflict4 c) {
    }

    void testMeth() {
        methConflict(() -> { // вызывает methConflict(IConflict1 c)
        }); // только он ничего не принимает и ничего не отдает

        methConflict(i -> { // вызывает methConflict(IConflict2 c)
        }); // только он принимает int и ничего не отдает

        // todo methConflict(System.out::println); // methConflict(IConflict1 c) или methConflict(IConflict2 c)

        // todo methConflict(i -> i); // methConflict(IConflict3 c) или methConflict(IConflict4 c)

        // todo methConflict(i -> "kva"); // methConflict(IConflict3 c) или methConflict(IConflict4 c)
    }

    /*~~~~~~~~~~~~~~ЯВЛЯЕТСЯ ГИБРИДОМ ВЛОЖЕННОГО БЛОКА И АНОНИМНОГО КЛАССА~~~~~~~~~~~~~~*/
    @FunctionalInterface
    interface Hybrid {
        void printClass();
    }

    void classMeth2(int parameter) {
        int localVar = 0;
        int shadow = 0;

        /* АНОНИМНЫЙ КЛАСС */
        Hybrid hybrid = new Hybrid() {
            private int anonMemberVar; // может иметь члены класса

            public void someMeth() {
            } // члены класса могут иметь различные модификаторы доступа

            @Override
            public void printClass() {
                System.out.println(getClass().getSimpleName()); // имени не будет
                System.out.println(this); // ссылается на этот анонимный класс
//                public int anonVar = 4; // локальные переменные не могут иметь модификаторы доступа
                classVar = 56; // есть доступ ко всем членам обрамляющего класса
                classMeth("34"); // есть доступ ко всем членам обрамляющего класса
//            static int f = 5; // не может иметь статических членов
                int innerVar = parameter; // есть доступ к эффективно финализированным локальным переменным
                int innerVar2 = localVar; // есть доступ к эффективно финализированным локальным переменным
                int shadow = 3; // происходит затемнение переменной из области выше
            }
        };

        /* Л-В */
        Hybrid hybrid2 = () -> {
            // у л-в не может быть членов, все переменные - локальные
            System.out.println(getClass().getSimpleName()); // имя Main
            System.out.println(this); // ссылается на обрамляющий класс
//                public int anonVar = 4; // локальные переменные не могут иметь модификаторы доступа
            classVar = 4; // есть доступ ко всем членам обрамляющего класса
            classMeth("34"); // есть доступ ко всем членам обрамляющего класса
//            static int f = 5; // не может иметь статических членов
            int innerVar = parameter; // есть доступ к эффективно финализированным локальным переменным
            int innerVar2 = localVar; // есть доступ к эффективно финализированным локальным переменным
//            int shadow = 3; // КОМПИЛЯТОР НЕ ДАЕТ ЗАТЕМНИТЬ ПЕРЕМЕННУЮ
        };

        hybrid.printClass(); // доступ к методу - через экземпляр функционального интерфейса
        hybrid2.printClass(); // доступ к методу - через экземпляр функционального интерфейса
    }
}