package collections;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.ListIterator;
import java.util.SortedSet;
import java.util.TreeSet;

import types_references_annotations.my_annotations.Ntrstn;

/* =======================================ОБЩЕЕ======================================= */
/* ВИДЫ ИМПЛЕМЕНТАЦИЙ
 * - общего назначения:
 *      - наиболее используемые
 *      - поддерживают все опциональные (модификационные) методы
 *      - допускают null элементы, ключи, значения
 *          - имплементации Queue обычно не разрешают null
 *      - не синхронизированы
 *      - имеют fail-fast итераторы
 *          - при изменении коллекции после получения итератора быстро и чисто падают
 *              - чтобы избежать непоняток
 *      - Serializable
 *      - поддерживают метод clone
 *
 * - специального назначения:
 *      - особые ситуации с нестандартными характеристиками скорости, поведения, ограничений
 *
 * - многопоточные (java.util.concurrent):
 *      - поддержка высокоуравневой многопоточности
 *          - обычно на скорости однопоточного исполнения
 *      - на основе интерфейса Queue
 *          - чем дольше в очереди, тем ближе к ее голове
 *
 * - оберточного назначения:
 *      - добавление/ограничение функционала других имплементаций (обычно общиего назначения)
 *          - как паттерн декоратор
 *
 * - для удобства:
 *      - мини-имплементации, доступные через статичные фабричные методы
 *      - удобные/эффективные альтернативы общим имплементациям
 *          - напр., Collections.singleton вернет неизменяемый set только с указанным объектом
 *
 * - абстрактные:
 *      - скелетные имплементации, способствующие созданию кастомных имплементаций
 *      - мало кому понадобятся
 *
 * - (какие-то имплементации могут не реализовывать какие-то опциональные методы)
 *      - при вызове UnsupportedOperationException */


/* ИЕРАРХИЯ КОЛЛЕКЦИЙ (* - общего назначения)
 * - <<Collection>>: группа элементов
 *      - <<List>>: последовательная группа элементов - обращение к элементам по индексу, контроль
 *      места вставки
 *          - ArrayList*: [Array], быстрый
 *          - LinkedList*: [Doubly-Linked List], <<Deque>> (FIFO), гибкий
 *          - CopyOnWriteArrayList: [Array], потокобезопасный
 *
 *      - <<Set>>: группа элементов без дубликатов
 *          - HashSet*: [Hash table], неупорядочена
 *              - LinkedHashSet*: [Hash Table], [Doubly-Linked List], порядок как добавлялось
 *          - EnumSet: [Bit Vector], для Enum, по порядку объявления, высокоэффективен, типобезопасен
 *          - CopyOnWriteArraySet: [Array], потокобезопасный
 *          - <<SortedSet>>: упорядоченная группа (натуральный порядок/компаратор)
 *              <<NavigableSet>>: навигационные методы (поиск по первому совпадению)
 *                  - TreeSet*: [Red-Black Tree]
 *                  - ConcurrentSkipListSet: [SkipList], эффективный, потокобезопасный, атомические
 *                  операции, естественный порядок/компаратор
 *
 *      - <<Queue>>: 1-сторонняя очередь (обычно FIFO), коллекция элементов для обработки
 *          - PriorityQueue*: [Priority (Binary) Heap], натуральный порядок/компаратор
 *          - ConcurrentLinkedQueue: [Linked List], потокобезопасен, эффективный неблокирующий алгоритм
 *          - <<Deque>>: двусторонняя очередь (FIFO, LIFO)
 *              - ArrayDeque*: [Array], быстрый
 *              - LinkedList*: [Doubly-Linked List], <<Deque>> (FIFO), более гибкий
 *          - <<BlockingQueue>>: многопоточный; можно ждать появления элемента/освобождения места
 *              - LinkedBlockingQueue: [Linked List], опционально ограничеваемая
 *              - ArrayBlockingQueue: [Array], ограниченная
 *              - PriorityBlockingQueue: аналогично PriorityQueue
 *              - DelayQueue: [Priority (Binary) Heap], элемент можно извлечь только после задержки
 *              - SynchronousQueue: [нет], чтобы удалить элемент, его кто-то должен туда ложить, а
 *              чтобы ложить элемент, его кто-то должен оттуда забирать
 *              - <<TransferQueue>> : можно ждать, пока другая ветка получит элементы
 *                  - LinkedTransferQueue: [Linked List]
 *
 * - <<Map>>: связь ключ-значение; не может иметь дубликатов ключей; 1 ключ связан только с 1 значением
 *      - HashMap*: [Hash table], неупорядочена, быстрая
 *          - LinkedHashMap*: [Hash Table], [Doubly-Linked List], порядок как добавлялось, чуть медленней
 *      - EnumMap: [Array], для Enum-ключей, по порядку объявления, высокоэффективен, типобезопасен
 *      - WeakHashMap: [Hash table], сборщик мусора удаляет пару, если на ключ не ссылаются извне
 *      - IdentityHashMap: [Hash table], сравнивает только ссылки (без equals)
 *      - <<SortedMap>>: упорядоченная мапа (естественный порядок ключей/компаратор)
 *              - <<NavigableMap>>: навигационные методы (поиск по первому совпадению)
 *                  - TreeMap*: [Red-Black Tree]
 *      - <<ConcurrentMap>>: эффективный, потокобезопасный, атомические операции
 *          - ConcurrentHashMap: [Hash table]
 *          - <<ConcurrentNavigableMap>>: также наследует NavigableMap
 *              - ConcurrentSkipListMap: [SkipList], естественный порядок ключей/компаратор
 *
 * - <<AbstractCollection>>: для дефолтных имплементаций коллекций
 *
 * - <<Comparable>>: имплементирующий объект можно сравнивать с другим такого же типа
 *
 * - <<Comparator>>: описывает порядок объектов в коллекции
 *
 * - <<Iterable>>: возможность использовать коллекцию в foreach (только чтение); возвращает Iterator
 *
 * - <<Iterator>>: итератор по коллекции с возможностью работы с элементами
 *      - <<ListIterator>>: итератор по списку в обе стороны, с возможностью внесения изменений и
 *      получения текущей позиции курсора
 *
 * - Collections: утилитные статические методы для коллекций
 *
 * - Arrays: утилитные статические методы для массивов */


/* СКОРОСТЬ ИМПЛЕМЕНТАЦИЙ
List                 | Add  | Remove | Get  | Contains | Next | Data Structure
---------------------|------|--------|------|----------|------|---------------
ArrayList            | O(1) |  O(n)  | O(1) |   O(n)   | O(1) | Array
LinkedList           | O(1) |  O(1)  | O(n) |   O(n)   | O(1) | Linked List
CopyOnWriteArrayList | O(n) |  O(n)  | O(1) |   O(n)   | O(1) | Array


Set                   |    Add   |  Remove  | Contains |   Next   | Size | Data Structure
----------------------|----------|----------|----------|----------|------|-------------------------
HashSet               | O(1)     | O(1)     | O(1)     | O(h/n)   | O(1) | Hash Table
LinkedHashSet         | O(1)     | O(1)     | O(1)     | O(1)     | O(1) | Hash Table + Linked List
EnumSet               | O(1)     | O(1)     | O(1)     | O(1)     | O(1) | Bit Vector
TreeSet               | O(log n) | O(log n) | O(log n) | O(log n) | O(1) | Red-black tree
CopyOnWriteArraySet   | O(n)     | O(n)     | O(n)     | O(1)     | O(1) | Array
ConcurrentSkipListSet | O(log n) | O(log n) | O(log n) | O(1)     | O(n) | Skip List


Queue                   |  Offer   | peek |   Poll   | Remove | Size | Data Structure
------------------------|----------|------|----------|--------|------|---------------
PriorityQueue           | O(log n) | O(1) | O(log n) |  O(n)  | O(1) | Priority Heap
ArrayDeque              | O(1)     | O(1) | O(1)     |  O(1)  | O(1) | Array
LinkedList            	| O(1)     | O(1) | O(1)     |  O(n)  | O(1) | Linked List
ConcurrentLinkedQueue   | O(1)     | O(1) | O(1)     |  O(n)  | O(n) | Linked List
ArrayBlockingQueue      | O(1)     | O(1) | O(1)     |  O(n)  | O(1) | Array
PriorityBlockingQueue   | O(log n) | O(1) | O(log n) |  O(n)  | O(1) | Priority Heap
SynchronousQueue        | O(1)     | O(1) | O(1)     |  O(n)  | O(1) | None!
DelayQueue              | O(log n) | O(1) | O(log n) |  O(n)  | O(1) | Priority Heap
LinkedBlockingQueue     | O(1)     | O(1) | O(1)     |  O(n)  | O(1) | Linked List


Map                   |   Get    | ContainsKey |   Next   | Data Structure
----------------------|----------|-------------|----------|-------------------------
HashMap               | O(1)     |   O(1)      | O(h / n) | Hash Table
LinkedHashMap         | O(1)     |   O(1)      | O(1)     | Hash Table + Linked List
IdentityHashMap       | O(1)     |   O(1)      | O(h / n) | Array
WeakHashMap           | O(1)     |   O(1)      | O(h / n) | Hash Table
EnumMap               | O(1)     |   O(1)      | O(1)     | Array
TreeMap               | O(log n) |   O(log n)  | O(log n) | Red-black tree
ConcurrentHashMap     | O(1)     |   O(1)      | O(h / n) | Hash Tables
ConcurrentSkipListMap | O(log n) |   O(log n)  | O(1)     | Skip List */



/*==============================ПОРЯДОК И СРАВНЕНИЕ==============================*/
/* NATURAL ORDERING
 * - естественный порядок (как мы привыкли)
 *      - например, алфавитный или возрастающий числовой */


/* COMPARABLE (ФУНКЦИОНАЛЬНЫЙ ИНТЕРФЕЙС)
 * - определяет естественный порядок для объектов имплементирующего класса
 *      - int compareTo(T o): метод естественного сравнения
 *          - вернет:
 *              -1: данный объект меньше указанного
 *              0: объекты равны
 *              1: данный объект больше указанного
 *
 * - Collections.sort()/Arrays.sort(): автоматически сортирует список/массив в натуральный порядок
 *      - если класс содержащихся объектов имплементирует Comparable
 *
 * - имплементирующие объекты могут использоваться как ключи в SortedMap или как элементы в SortedSet
 * без необходимости указывать компаратор
 *
 * - рекомендуется, чтобы естественный порядок совпадал с результатом метода equals
 *      - иначе SortedMap/SortedSet будет нарушать контракт (определен по методу equals)
 *      - все основные классы Java, которые имплементируют Comparable, соблюдают данное правило,
 *      кроме java.math.BigDecimal
 *          - естественное сравнение производится над одинаковыми значеними, но разной точности
 *              - напр. 4.0 и 4.00
 *
 * - основные классы, которые имплементируют Comparable:
 *      - Byte, Character, Long, Integer, Short, Double, Float, BigInteger, BigDecimal, Boolean,
 *      File, String, Date, Chronological, CollationKey
 *          - никакой из этих классов не позволяет межклассовое сравнение
 *
 * - ClassCastException, если класс не имплементит Comparable */


/* COMPARATOR (ФУНКЦИОНАЛЬНЫЙ ИНТЕРФЕЙС)
 * - функция сравнения, которая определяет естественный порядок для какой-то коллекции объектов
 *      - int compare(T o1, T o2)
 *          - аналогично compareTo, где с первым аргументом сравнивается второй
 *
 * - используется, если нужно сортировать в ненатуральном порядке или объекты, которые не
 * имплементируют Comparable
 *      - Collections.sort()/Arrays.sort() принимают также компаратор
 *
 * - можно использовать для структур данных, имеющих порядок
 *      - например, SortedMap и SortedSet
 *
 * - также рекомендуется, чтобы естественный порядок совпадал с результатом метода equals
 *
 * - рекомендуется также имплементировать Serializable, чтобы сохранялся порядок при сериализации
 * Serializable структур данных
 *      - например, TreeSet и TreeMap
 *
 * - в отличие от Comparable может опционально разрешать сравнение null аргументов
 *
 * - есть еще куча дефолтных и статических методов
 *
 * - ClassCastException если сортируется список/массив, чьи элементы нельзя сравнивать при помощи
 * предоставленного компаратора */



/*==============================ПЕРЕБОР ЭЛЕМЕНТОВ==============================*/
/* АГРЕГАТНЫЕ ОПЕРАЦИИ
 * - сначала получить стрим, затем произвести аграгатные операции над ним
 * - обычно используются в сочетации с ЛВ
 * - предпочтительно начиная с J8
 * - в отличие от балковых методов (containsAll, addAll, removeAll), не меняют коллекцию
 * - напр.: myShapesCollection.stream().filter(e -> e.getColor() == Color.RED)
 *          .forEach(e -> System.out.println(e.getName())); */


/* ИНТЕРФЕЙС ITERABLE И КОНСТРУКЦИЯ FOREACH
 * - интерфейс Iterable: простое представление серии элементов, по которым можно пройтись
 *      - нет состояния итерации ("текущий элемент"), а есть только метод, который создает итератор:
 *          - Iterator<T> iterator(): возвращает итератор, для прохода по данной коллекции
 *
 * - если класс объектов в коллекции имплементирует Iterable, ее можно использовать в foreach лупе
 *      - можно только перемещаться по списку, без изменения элементов
 *      - напр.: for (Object o : collection) System.out.println(o);
 *
 * - реализуется любой коллекцией, но не Map
 *
 * - массив не является Iterable и его нельзя передать ВМЕСТО Iterable
 *      - нужно сначала преобразовать в список: Arrays.asList()
 *      - НО при этом foreach все равно работает с массивом */


/* ИНТЕРФЕЙС ITERATOR
 * - объект, позволяющий проходить по коллекции и выбирать каждый элемент
 *      - опционально позволяет удалять элемент
 *      - может перемещаться только вперед
 *
 * - получить итератор - collection.iterator()
 *
 * - методы:
 *      boolean hasNext(); // узнать, есть ли следующий элемент
 *      E next(); // получить следующий элемент
 *      void remove(); // (опциональный), удалить последний полученный элемент
 *          - может быть вызван только 1 раз за шаг итерации
 *
 * - list.listIterator(): вернет расширенную версию
 *      - итерация в обе стороны
 *      - изменения листа в текущей позиции
 *      - получение текущей позиции итератора
 *      - возможность получить итератор с нужной позиции
 *
 * - является паттерном проектирования
 *
 * - напр.: for (Iterator<?> it = c.iterator(); it.hasNext(); )
 *              if (!cond(it.next())) it.remove(); } */



/* ====================================ИНТЕРФЕЙСЫ/ИМПЛЕМЕНТАЦИИ==================================== */
/* COLLECTION
 * - public interface Collection<E> extends Iterable<E>
 *
 * - представляет группу объектов (элементов)
 *
 * - коренной интерфейс в иерархии коллекций
 *      - удобно использовать как генерализированную коллекцию при манипуляциях
 *      - принимается всеми имплементациями в конструктор
 *          - т.е. для конвертации коллекций
 *
 * - не имплементируется напрямую какими-либо коллекциями
 *      - только, разве что, AbstractCollection
 *
 * - методы:
 *      - базовые:
 *          - size: размер коллекции
 *          - isEmpty: проверка на пустоту
 *          - contains: поиск элемента
 *          - add: гарантия добавления элемента; вернет результат добавления
 *          - remove: удаление элемента
 *          - iterator: позволяет итерировать по коллекции
 *
 *      - манипулирование целой коллекцией:
 *          - containsAll: поиск данной коллекции элементов
 *          - addAll: добавление данной коллекции
 *          - removeAll: удаление данной коллекции
 *          - retainAll: удаление всего, кроме данной коллекции
 *          - clear: удаление всего
 *
 *      - операции с массивами
 *          - toArray: перевод коллекции в массив типа Object
 *          - toArray(T[] a): перевод коллекции в массив указанного типа
 *
 *      - стримовые (с J8)
 *          - stream: перевод коллекции в стрим
 *          - parallelStream: перевод коллекции в, возможно, параллельный стрим */


/* LIST
 * - последовательная группа элементов
 *      - например, список покупок
 *
 * - дополнительные методы:
 *      - позиционного доступа: манипуляция элементами по их числовой позиции в списке:
 *          - get, set, add, addAll, remove (удаляет первый совпадающий элемент)
 *      - поиска: поиск указанного объекта в списке и возвращение его позиции:
 *          - indexOf, lastIndexOf
 *      - итерации: расширяет семантику Iterator для работы со списком
 *          - listIterator
 *              - расширяет итератор
 *              - итерация в обе стороны: + previous, hasPrevious
 *              - изменения листа в текущей позиции: add
 *              - получение текущей позиции итератора: index
 *              - возможность получить итератор с нужной позиции
 *      - просмотр диапазона: диапазонные операции над списком:
 *          - sublist (изменения в оригинале отражаются в диапазоне)
 *
 * - итераторы являются fail-fast
 *      - при изменении коллекции после получения иторатора не его методами (remove, add)
 *      выбрасывается ConcurrentModificationException
 *          - не является гарантированным (нельзя основывать на этом логику)
 *
 * - большинство алгоритмов Collections применяются специально к List
 *      - sort: сортировка листа при помощи MergeSort - быстрая и стабильная (не меняет порядок
 *      равных элементов)
 *      - shuffle: рандомно переставляет элементы в листе
 *      - reverse: обращает порядок элементов в списке
 *      - rotate: двигает по кругу элементы на указанную дистанцию
 *      - swap: меняет местами элементы на указанных позициях
 *      - replaceAll: меняет все встречи одного значения на указанное
 *      - fill: переписывает каждый элемент в списке указанным значением
 *      - copy: копирует лист источник в лист цель
 *      - binarySearch: ищет элементы в упорядоченном листе при помощи Binary Search
 *      - indexOfSubList: возвращает индекс первого подлиста одного листа, который равен другому
 *      - lastIndexOfSubList: возвращает индекс последнего подлиста одного листа, который равен другому
 *
 * - реализации:
 *      - общего назначения:
 *          - ArrayList:
 *              - предпочтительней
 *              - основан на Array
 *              - можно менять размер массива
 *              - допускаются дубликаты и null элементы
 *              - скорость:
 *                  - add: O(1) (константное амортизированное время, т.е. O(n)+)
 *                      - т.е. среднее время, если операция повторяется многократно
 *                          - напр. из-за периодического увеличения массива
 *                  - remove: O(n)
 *                  - get: O(1)
 *                  - contains: O(n)
 *                  - next: O(1)
 *
 *          - LinkedList:
 *              - перед использованием, сравнить перформанс с ArrayList
 *              - основан на Doubly-Linked List
 *              - также имплементирует <<Deque>>
 *                  - т.е. есть методы очереди
 *              - допускаются дубликаты и null элементы
 *              - доступ к элементу с начала или конца (зависит от того, что ближе)
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - get: O(n)
 *                  - contains: O(n)
 *                  - next: O(1)
 *
 *      - специального:
 *          - CopyOnWriteArrayList:
 *              - основан на Array
 *              - потокобезопасен: все операции изменения проводятся после создания копии массива
 *                  - т.е. не нужен лок, и даже можно итерировать многопоточно
 *              - подходит только для списков, которые редко меняются, но часто итерируются
 *              - скорость:
 *                  - add: O(n)
 *                  - remove: O(n)
 *                  - get: O(1)
 *                  - contains: O(n)
 *                  - next: O(1)
 *
 * - для большинства имплементаций общего назначения скорость удаления элементов с конца выше
 * удаления с начала */


/* SET + SORTEDSET + NAVIGABLESET
 * - набор элементов без дубликатов
 *      - например, колода карт
 *
 * - меняют поведение Collection, а не добавляет новое
 *      - в отличие от, например, List
 *
 * - содержит только методы Collection
 *
 * - реализации:
 *      - общего назначения:
 *          - HashSet
 *              - основан на Hash table
 *              - нет гарантии порядка
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - contains: O(1)
 *                  - next: O(h/n)
 *                  - size: O(1)
 *
 *          - LinkedHashSet
 *              - наследует HashSet
 *              - основан на Hash Table + Doubly-Linked List
 *              - порядок, в котором добавлялись элементы
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - contains: O(1)
 *                  - next: O(1)
 *                  - size: O(1)
 *
 *      - специального:
 *          - EnumSet
 *              - основан на Bit Vector
 *              - высокоскоростная имплементация для Enum одного типа
 *              - типобезопасен, в отличие от битовых флагов на основе int
 *              - итератор:
 *                  - на основе natural order
 *                      - т.е. порядок создания констант
 *                  - является weakly consistent
 *                      - не выбрасывает ConcurrentModificationException
 *                      - может проявлять эффекты изменения коллекции после создания итератора
 *              - не допускает null элементы
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - contains: O(1)
 *                  - next: O(1)
 *                  - size: O(1)
 *
 *          - CopyOnWriteArraySet:
 *              - основан на Array
 *              - потокобезопасен: все операции изменения проводятся после создания копии массива
 *                  - т.е. не нужен лок, и даже можно итерировать многопоточно
 *              - подходит только для наборов, которые редко меняются, но часто итерируются
 *              - скорость:
 *                  - add: O(n)
 *                  - remove: O(n)
 *                  - contains: O(n)
 *                  - next: O(1)
 *                  - size: O(1)
 *
 * - интерфейсы-наследники:
 *      - SortedSet: упорядоченный набор (натуральный порядок или компаратор)
 *          - например, список слов
 *      - методы:
 *          - те же, что и Set, но:
 *               - iterator вернет итератор, перебирающий по порядку
 *               - toArray вернет упорядоченный массив
 *          - дополнительные:
 *              - конечные точки: first, last
 *                  - вернет первый или последний элемент из набора
 *              - просмотр диапазона: subSet, headSet (от начала до элемента), tailSet (от элемента
 *              до конца)
 *                  - в отличие от List, диапазон остается валидным даже при изменении оригинала
 *                      - т.к. конечные точки являются абсолютными
 *                  - изменения в оригинале и в куске отражаются друг в друге
 *              - доступ к компаратору: comparator
 *                  - вернет компаратор, если он использовался в наборе
 *
 *      - интерфейсы-наследники:
 *          - NavigableSet: упорядоченный набор с навигационными методами (по первому совпадению)
 *              - возможность итерировать/просматривать набор в возрастающем и спадающем порядке
 *                  - операции с возрастающим могут быть быстрее
 *              - дополнительные методы:
 *                  - возрват элементов при помощи сравнения: lower, floor, ceiling, higher
 *                  - удаление первого/последнего элемента: pollFirst, pollLast
 *
 *              - реализации (общего назначения):
 *                  - TreeSet
 *                      - основан на Red-black Tree
 *                      - скорость:
 *                          - add: O(log n)
 *                          - remove: O(log n)
 *                          - contains: O(log n)
 *                          - next: O(log n)
 *                          - size: O(1) */


/* QUEUE + DEQUE + BLOCKINGQUEUE + TRANSFERQUEUE
 * - коллекция объектов, предназначенная для обработки
 *
 * - дополнительные методы: дублируют аналоги Collection, но при неуспехе вернут null или false, а
 * не исключение
 *      - вставка: пытается вставить элемент в конец очереди
 *          - offer(e) - возвращает значение (в случае отсутствия места в ограниченной очереди)
 *              - add(e) - выкидывает исключение
 *      - удаление: пытается удалить элемент с начала очереди
 *          - poll() - возвращает значение (если нет элементов)
 *              - remove() - выкидывает исключение
 *      - просмотр: пытается вернуть элемент с начала очереди (без удаления)
 *          - peek() - возвращает значение (если нет элементов)
 *              - element() - выкидывает исключение
 *
 * - некоторые имплементации из java.util.concurrent можно ограничивать, но никакие из java.util
 *
 * - ОБЫЧНО FIFO
 *      - кроме:
 *          - PriorityQueue
 *              - естественный порядок или компаратор
 *          - Stack
 *              - LIFO
 *      - каждая имплементация Queue обязана указать свойства упорядочивания
 *
 * - обычно не позволяют вставлять null элементы
 *      - исключение LinkedList
 *          - все равно не рекомендуется, чтобы не путать с результатом poll
 *
 * - java.util.concurrent.BlockingQueue расширяет Queue и добавляет методы ожидания появляения
 * элемента/места
 *
 * - реализации:
 *      - общего назначения:
 *          - PriorityQueue:
 *              - основан на Priority (Binary) Heap
 *              - очередь не ограничена
 *              - естественный порядок или компаратор
 *              - головой очереди является ПОСЛЕДНИЙ элемент указанного порядка
 *                  - если несколько равных последних, то головой будет какой-то из них
 *              - итератор НЕ ГАРАНТИРУЕТ определенный порядок!
 *                  - для порядка используй Arrays.sort(pq.toArray())
 *              - скорость:
 *                  - offer: O(log n)
 *                  - peek: O(1)
 *                  - poll: O(log n)
 *                  - remove: O(n)
 *                  - size: O(1)
 *
 *      - многопоточного:
 *          - ConcurrentLinkedQueue:
 *              - основан на Linked List
 *              - эффективный неблокирующий алгоритм
 *              - FIFO
 *              - weakly consistent итератор
 *              - скорость:
 *                  - offer: O(1)
 *                  - peek: O(1)
 *                  - poll: O(1)
 *                  - remove: O(n)
 *                  - size: O(n)
 *
 * - интерфейсы-наследники:
 *      - Deque: двусторонняя очередь (FIFO, LIFO)
 *          - т.е. Queue + Stack
 *          - дополнительные методы:
 *              - вставка:
 *                  - addFirst, offerFirst
 *                  - addLast, offerLast
 *              - удаление:
 *                  - removeFirst(), pollFirst()
 *                  - removeLast(), pollLast()
 *                  - removeFirstOccurrence, removeLastOccurrence
 *              - просмотр:
 *                  - getFirst(), peekFirst()
 *                  - getLast(), peekLast()
 *          - имплементации общего назначения:
 *              - ArrayDeque:
 *                  - на основе Array
 *                  - скорость:
 *                      - offer: O(1)
 *                      - peek: O(1)
 *                      - poll: O(1)
 *                      - remove: O(1)
 *                      - size: O(1)
 *
 *              - LinkedList
 *                  - более гибкий, чем ArrayDeque
 *
 *      - BlockingQueue: многопоточный; можно ждать появления элемента (при чтении) или освобождения
 *      места (при добавлении); чем дольше в очереди, тем ближе к ее голове
 *          - имплементации:
 *              - LinkedBlockingQueue:
 *                  - основан на Linked List
 *                  - опционально ограничеваемый
 *                  - FIFO
 *                  - скорость:
 *                      - offer: O(1)
 *                      - peek: O(1)
 *                      - poll: O(1)
 *                      - remove: O(n)
 *                      - size: O(1)
 *
 *              - ArrayBlockingQueue:
 *                  - основан на Array
 *                  - ограниченный
 *                  - FIFO
 *                  - скорость:
 *                      - offer: O(1)
 *                      - peek: O(1)
 *                      - poll: O(1)
 *                      - remove: O(n)
 *                      - size: O(1)
 *
 *              - PriorityBlockingQueue:
 *                  - аналогично PriorityQueue
 *
 *              - DelayQueue:
 *                  - основан на Priority (Binary) Heap
 *                  - элемент можно извлечь только после дилея
 *                  - скорость:
 *                      - offer: O(log n)
 *                      - peek: O(1)
 *                      - poll: O(log n)
 *                      - remove: O(n)
 *                      - size: O(1)
 *
 *              - SynchronousQueue:
 *                  - не основан на алгоритме
 *                  - чтобы удалить элемент, его кто-то должен туда ложить, а чтобы ложить элемент,
 *                  его кто-то должен оттуда забирать
 *                      - по сути, вместимость даже не 1, а 0
 *                  - скорость:
 *                      - offer: O(1)
 *                      - peek: O(1)
 *                      - poll: O(1)
 *                      - remove: O(n)
 *                      - size: O(1)
 *
 *      - интерфейсы-наследники:
 *          - TransferQueue: можно ждать, пока другая ветка получит элемент
 *              - имплементация:
 *                  - LinkedTransferQueue
 *                     - основан на Linked List
 *                     - скорость:
 *                          - offer: O(1)
 *                          - peek: O(1)
 *                          - poll: O(1)
 *                          - remove: O(n)
 *                          - size: O(1) */


/* MAP + SORTEDMAP
 * - связь ключ-значение
 *
 * - не может иметь дубликатов ключей
 *      - но могут быть дубликаты значений
 *
 * - 1 ключ связан только с 1 значением
 *      - если нужна связь с несколькими - храни их в List
 *
 * - внимательно с mutable ключами
 *
 * - имеет конструктор, который принимает другой Map
 *      - т.е. делает копию
 *
 * - методы просмотра мапы как коллекции (единственный способ итерации по мапе):
 *      - keySet: набор ключей
 *          - пример итерации: for (KeyType key : m.keySet()) System.out.println(key);
 *      - values: коллекция значений
 *          - не набор, т.к. могут быть повторения
 *      - entrySet: набор пар ключей-значений, содержащихся в мапе
 *          - т.е. Set, который содержит экземпляры интерфейса Map.Entry (пара ключ-значение)
 *              - набор валиден только во время итерации
 *              - есть метод setValue - можно менять значение во время итерации
 *
 * - имплементации:
 *      - общего назначения:
 *          - HashMap
 *              - основан на Hash table
 *              - нет гарантии порядка
 *              - скорость мап-коллекций сильно зависит от вместимости (количество корзин) и
 *              размера (количество мап ключ-значение) HashMap
 *                  - для скорости итерации, начальная вместимость не должна быть слишком большой или
 *                  фактор загрузки слишком малым
 *              - скорость:
 *                  - get: O(1)
 *                  - containsKey: O(1)
 *                  - next: O(h/n)
 *
 *              - имплементация-наследник:
 *                  - LinkedHashMap
 *                      - основан на Hash Table + Doubly-Linked List
 *                      - порядок, в котором добавлялись элементы
 *                      - скрость может чуть уступать Hash table
 *                          - но итерация по collection-views происходит пропорционально размеру мапы
 *                          (вне зависимости от вместимости) - лучше чем у HashMap
 *                      - полезно для кеша
 *                      - скорость:
 *                          - get: O(1)
 *                          - containsKey: O(1)
 *                          - next: O(1)
 *
 *      - специального:
 *          - EnumMap
 *              - основан на Array
 *              - остальное аналогично EnumSet
 *              - скорость:
 *                  - get: O(1)
 *                  - containsKey: O(1)
 *                  - next: O(1)
 *
 *          - WeakHashMap
 *              - основан на Hash table
 *              - сборщик мусора удаляет пару, если на ключ не ссылаются извне
 *                  - полезно для "регистровый" стуктрур данных
 *              - скорость:
 *                  - get: O(1)
 *                  - containsKey: O(1)
 *                  - next: O(h/n)
 *
 *          - IdentityHashMap
 *              - основан на Hash table
 *              - быстрый, т.к. сравнивает только ссылки (без equals)
 *              - скорость:
 *                  - get: O(1)
 *                  - containsKey: O(1)
 *                  - next: O(h/n)
 *
 * - интерфейсы-наследники:
 *      - SortedMap: упорядоченная мапа (натуральный порядок ключей/компаратор)
 *          - например, словарь, телефонный справочник
 *          - аналогично SortedSet
 *
 *          - интерфейсы-наследники:
 *              - NavigableMap: упорядоченная мапа с навигационными методами (по первому совпадению)
 *                  - аналогично NavigableSet
 *
 *                  - реализации (общего назначения):
 *                      - TreeMap
 *                          - аналогично TreeSet
 *                          - скорость:
 *                              - get: O(log n)
 *                              - containsKey: O(log n)
 *                              - next: O(log n)
 *
 *     - ConcurrentMap: эффективный, потокобезопасный, атомические операции
 *          - атомические методы: putIfAbsent, remove, replace
 *          - многопоточные имплементации:
 *              - ConcurrentHashMap
 *                  - скорость:
 *                      - get: O(1)
 *                      - containsKey: O(1)
 *                      - next: O(h/n) */



/* ===========================COLLECTIONS И ОСТАЛЬНЫЕ ИМПЛЕМЕНТАЦИИ=========================== */
/* ОБЕРТОЧНЫЕ ИМПЛЕМЕНТАЦИИ
 * - (на основе паттерна Декоратор)
 *
 * - (анонимны)
 *      - создаются от фабричных статических методов Collections
 *
 * - синхронизационные: <T> ...<T> synchronized...(...<T> c)
 *      - вернет синхронизированную версия коллекции
 *      - итерировать по коллекции нужно атомически:
 *          - synchronized(c) {for (Type e : c)foo(e);}
 *      - недостаток: нельзя использовать неинтерфейсные методы обернутой имплементации
 *
 * - неизменяемые: <T> ...<T> unmodifiable...(...<? extends T> c)
 *      - убирают возможность изменять элементы
 *          - перехватывают команды и выбрасывают исключение UnsupportedOperationException
 *      - используются:
 *          - сделать коллекцию неизменяемой при создании
 *              - желательно не сохранять линк на оригинал
 *          - позволить определенным клиентам только чтение
 *
 * - типобезопасные (сhecked): <E> ...<E> checked...(...<E> c, Class<E> type)
 *      - не позволяет вставлять элементы неправильного типа
 *          - т.е. ДИНАМИЧЕСКАЯ проверка (а не только компиляторная)
 *          - иначе ClassCastException */


/* ИМПЛЕМЕНТАЦИИ УДОБСТВА
 * - массив как список: <T> List<T> asList(T... a)
 *      - изменения в одном приводят к изменениям в другом
 *      - размер листа нельзя менять
 *          - иначе UnsupportedOperationException
 *      - полезно:
 *         - в качестве моста между массивом и списком
 *         - когда нужен список фиксированного размера
 *             - он быстрее имплементации списка общего назначения!
 *
 * - неизменяемый список с копиями 1 элемента: <T> List<T> nCopies(int n, T o)
 *      - полезно:
 *          - нужно инициализировать список, который изначально состоит только из null
 *              List<Type> list = new ArrayList<Type>(Collections.nCopies(1000, (Type)null);
 *          - нужно расширить текущий список (в т.ч. вставить в середину)
 *              lovablePets.addAll(Collections.nCopies(69, "fruit bat"));
 *
 * - неизменяемый набор/список/мапа только с 1 указанным элементом: <T> ...<T> singleton...(T o)
 *      - полезно:
 *          - нужно удалить все повторы указанного элемента из коллекции
 *              c.removeAll(Collections.singleton(e));
 *          - нужно удалить все значения для определенного ключа
 *              job.values().removeAll(Collections.singleton(LAWYER));
 *          - нужно передать единичный элемент в аргумент метода, который принимает коллекцию
 *
 * - пустая неизменяемая коллекция/итератор: <T> ...<T> empty...()
 *      - полезно:
 *          - что-то передать в метод, который принимает коллекцию
 *              tourist.declarePurchases(Collections.emptySet()) */


/* ПОЛИМОРФНЫЕ АЛГОРИТМЫ COLLECTIONS (* - только для List)
 * - (большинство для List, но есть и для любых)
 *
 * - сортировка: sort*
 *      - сортировка по естественному порядку/компаратору
 *      - на основе немного оптимизированного Merge Sort
 *          - быстро: log(n)
 *          - стабильно: не меняет порядок равных элементов
 *              - т.е. если сначала сортировать по одному критерию, а потом по другому, порядок
 *              первой сортировки сохранится
 *
 * - перемешивание: shuffle*
 *      - дефолтный источник рандомизации/объект Random
 *
 * - рутинные операции:
 *      - reverse*: обращает порядок элементов в List
 *      - fill*: перезаписывает каждый элемент в List на указанное значение
 *          - полезно для повторной инициализации списка
 *      - copy*: копирует 1 List на другой, перезаписывая элементы
 *      - swap*: поменять местами элементы в List
 *      - addAll: добавляет все элементы в коллекцию
 *          - намного быстрее collection.addAll для большинства имплементаций!
 *          - можно перечислять через запятую
 *
 *
 * - проверка содержания:
 *      - binarySearch*: поиск элемента
 *          - принимает либо List + искомый элемент
 *              - ожидается, что List сортирован в возрастающем естественном порядке
 *                  - т.е. сначала нужно отсортировать (sort)
 *          - либо также Comparator
 *          - вернет:
 *              - индекс элемента, если найден
 *              - отрицательное число, если не найден
 *      - min, max: поиск минимальных и максимальных значений (по естественному порядку/компаратору)
 *      - frequency: количество повторов элемента в коллекции
 *      - disjoint: определяет, являются ли 2 коллекции непересекающимися
 *          - то есть не содержат общих элементов */


@Ntrstn("Правильней называть коллекциями, только то, что относится к интерфейсу Collection (т.е. НЕ " +
        "Map), а вот все вместе - контейнерами")

@Ntrstn("Для печати содержимого контейнера не нужен специальный метод, в отличие от массива")

@Ntrstn("Arrays.asList - методы add, remove не работают, т.к. массивы не меняются, т.е. " +
        "получается нестрандартная имплементация листа")

@Ntrstn("Для добавления групп элементов существуют специальные методы для удобства. Arrays.asList() " +
        "- принимает список элементов через запятую и возвращает контейнер List с ними. Но " +
        "Arrays.asList() создает List, в который нельзя добавлять или удалять элементы в рантайме, " +
        "иначе возникнет UnsupportedOperationException." +
        "Collections.addAll() - добавляет в указанную коллекцию указанные элементы (могут идти как " +
        "через запятую, так и массиве). В отличие от Collections.addAll() метод Collection.addAll() " +
        "может в качестве аргумента получать только другой объект Collection, поэтому он менее удобен")


public class Main {
    public static void main(String[] args) {
        printShuffle(new String[]{"1", "2", "3"});
        findDuplicatesIgnoringCaseByComparator(new String[]{"i", "do", "I"});
        trimmingWithIterator(Arrays.asList("1   ", "2 ", " 3 "));
    }

    static void printShuffle(String[] args) {
        List<String> l = Arrays.asList(args);
        Collections.shuffle(l);

        for (String s : l) {
            System.out.println(s);
        }

        l.stream().forEach(s -> System.out.println(s));
    }

    static void findDuplicatesIgnoringCaseByComparator(String[] args) {
//        SortedSet<String> s = new TreeSet<>(new MyCmprtr());
        SortedSet<String> s = new TreeSet<>(String::compareToIgnoreCase);
        for (String a : args)
            s.add(a);
        System.out.println(s.size() + " distinct words: " + s);
    }

    static void trimmingWithIterator(List<String> l) {
        for (ListIterator<String> li = l.listIterator(); li.hasNext(); ) {
            li.set(li.next().trim());
        }
        System.out.println(l);
    }
}

class MyCmprtr implements Comparator<String> {
    @Override
    public int compare(String o1, String o2) {
        return o1.compareToIgnoreCase(o2);
    }
}