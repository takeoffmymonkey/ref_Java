package numbers_boxing;

/* УПАКОВКА (BOXING)
 * - создание объекта-оболочки из переменной примитивного типа */


/* АВТОУПАКОВКА (AUTOBOXING)
 * - автоматическая упаковка примитивного типа в соответствующую оболочку (не нужно делать вручную)
 * - происходит всегда, когда по контексту требуется объект (присваивание, вызов метода с передачей
 * параметров), но используется значения примитивных типов
 *      + не относится к приведению (см. пример) */


/* РАСПАКОВКА (UNBOXING)
 * - извлечения значения примитивного типа из его оболочки*/


/* АВТОМАТИЧЕСКАЯ РАСПАКОВКА (AUTOUNBOXING)
 * - автоматическое извлечение примитивного типа из соответствующей оболочки (не нужно делать вручную)
 * - происходит всегда, когда по контексту требуется примитив (присваивание, вызов метода с передачей
 * параметров, арифметическое выражение), но используется объект
 * - как только значение распаковано, применяются стандартные правила повышения типов и преобразования
 * - может быть сгенерировано исключение, если ссылки на класс оболочки окажутся пустыми (null) */


/* ДРУГИЕ ОСОБЕННОСТИ
 * - относится ко всем оболочкам, а не только числовым!
 * - помогает избежать лишних ошибок ручного упаковки/распаковки
 * - благодаря автоупаковке и автораспаковке объект Boolean теперь также может применяться для
 * управления всеми циклическими конструкциями Java, а целочисленный в операторе switch
 * - облегчает работу с каркасом коллекций
 * - замедляет быстродействие в арифметических операциях
 * - можно инкрементировать объекты
 * - за упаковку и распаковку отвечает не виртуальная машина, а компилятор - он включает в программу
 * необходимые вызовы, а виртуальная машина лишь выполняет байт-код*/


import java.util.ArrayList;

public class Main {
    static byte byteA;
    static int intA;

    static Byte byteB = 0;
    static Integer intB;


    public static void main(String[] args) {
        /* УПАКОВКА */
        intB = new Integer(100); // примитив упаковывается в объект в ручную


        /* АВТОМАТИЧЕСКАЯ УПАКОВКА
         * - когда по контексту требуется объект */
        intB = 100; // присваивание: требуется объект, 100 автоматически упаковалось в объект и
        // объект присволся ссылке intB
        method(100); // вызов метода, который требует объект Integer
        // byteA = (byte) intB; // хоть по контексту и требуется примитив, () применяется к объекту


        /*РАСПАКОВКА (UNBOXING)*/
        intA = intB.intValue(); // значение примитива достается при помощи метода вручную


        /*АВТОМАТИЧЕСКАЯ РАСПАКОВКА
         * - когда по контексту требуется примитив
         * - после распаковки применяются стандартные правила повышения типов и преобразования
         * - может быть сгенерировано исключение, если ссылки на класс оболочки окажутся пустыми
         * (null)*/
        intA = intB; // присваивание
        method2(intB); // вызов метода, который требует примитив int
        intA = intB - 100; // в арифметических выражениях

        // byteA = intB - 100; // результат int, поэтому не может быть вписан в byte
        // byteA = byteB - 1; // результат так же int (автоматическое преобразование) - не может
        // быть вписан в byte

        byteB = null;
        //intA = byteB + 1; // NullPointerException


        /*~~~~~~~~~~~~~~~~~ДРУГИЕ ОСОБЕННОСТИ~~~~~~~~~~~~~~~~~*/
        /*ОТНОСИТСЯ НЕ ТОЛЬКО К ЧИСЛОВЫМ ОБОЛОЧКАМ*/
        Character c = 'a';
        Boolean b = true;


        /* BOOLEAN МОЖНО ПРИМЕНЯТЬ ДЛЯ УПРАВЛЕНИЯ ОПЕРАТОРАМИ ВСЕХ ЦИКЛОВ (while, for или do/while)*/
        Boolean bool = true;
        while (bool) {
            System.out.println("В цикле");
            b = false;
        }


        /* ЦЕЛОЧИСЛЕННЫЕ МОЖНО ИСПОЛЬЗОВАТЬ В ОПЕРАТОРЕ SWITCH*/
        intB = 2;
        switch (intB) {
            case 1:
                System.out.println("case 1");
                break;
            case 2:
                System.out.println("case 2");
                break;
            default:
                System.out.println("default case");
        }


        /*ОБЛЕГЧАЕТ РАБОТУ С КАРКАСОМ КОЛЛЕКЦИЙ*/
        ArrayList<Integer> arrayList = new ArrayList<>();
        arrayList.add(22); // при этом метод требует объект Integer


        /*МОЖНО ИНКРЕМЕНТИРОВАТЬ/ДЕКРЕМЕНТИРОВАТЬ ОБЪЕКТЫ*/
        intB ++;
        byteB --;

    }


    static void method(Integer integer) {

    }

    static void method2(int i) {

    }


}
