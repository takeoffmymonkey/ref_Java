package __collections;

import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.stream.Collectors;

import types_references_annotations.my_annotations.Ntrstn;

/* СПОСОБЫ ПЕРЕБОРА ЭЛЕМЕНТОВ
 * - 1. агрегатные операции
 *      - желательный способ начиная с J8
 *      - получить стрим и произвести аграгатные операции над ним
 *      - обычно используются в сочетации с ЛВ
 *      - myShapesCollection.stream().filter(e -> e.getColor() == Color.RED)
 *      .forEach(e -> System.out.println(e.getName()));
 *      - разница между новыми агрегатными операциями и существующими балковыми методами (containsAll,
 *      addAll, removeAll), то что старые меняют коллекцию
 * - 2. for-each
 *      - for (Object o : collection) System.out.println(o);
 *      - только чтение
 * - 3. итераторы
 *      - это объект, позволяющий проходить по колекции и выборочно удалять элементы, если нужно
 *      - методы интерфейса итератора
 *          boolean hasNext();
 *          E next();
 *          void remove(); //optional, может вызываться только 1 раз за итерацию
 *      - используется вместо форич, если нужно:
 *          - удалить текущий элемент
 *          - итерировать несколько коллекций параллельно
 *          - например:
 *          static void filter(Collection<?> c) {
    for (Iterator<?> it = c.iterator(); it.hasNext(); )
        if (!cond(it.next()))
            it.remove();
}
 *
 * */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~ИНТЕРФЕЙСЫ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - Иерархия:
 *      - Collection
 *          - Set - набор элементов без повторений
 *              - SortedSet - сортированный по возрастанию Set
 *          - List - упорядоченный список, обращение к элементам по индексу
 *          - Queue - обычно FIFO
 *          - Deque - FIFO или LIFO
 *      - Map - 1 ключ - значение
 *          - SortedMap - сортированный по возрастанию Map
 *
 * - все базовые являются обобщенными
 *      - позволяет проверять тип содержимого при компиляции
 *
 * - какие-то имплементации могут не реализовывать какие-то модификационные методы
 *      - при вызове UnsupportedOperationException
 *      - все имплементации общего назначения поддерживают все опциональные (модификационные) методы
 *      */


/* COLLECTION
 * - содержит группу объектов, т.е. элементы
 * - содержится во всех коллекциях и используется для передачи коллекций и манипулирования, когда
 * требуется максимальная генерализация
 *      - у всех имплементаций общего назначения есть конструктор, который принимает Collection
 *          - т.н. conversion constructor
 *              - т.е. способ конвертации коллекций
 * - не имплементируется конкретно какой-либо коллекцией
 * - базовые методы:
 *      - int size(),
 *      - boolean isEmpty(),
 *      - boolean contains(Object element),
 *      - boolean add(E element) - гарантирует, что элемент будет и вернет результат добавления
 *      - boolean remove(Object element)
 *      - Iterator<E> iterator()
 * - методы манипулирования целой коллекцией:
 *      - boolean containsAll(Collection<?> c)
 *      - boolean addAll(Collection<? extends E> c)
 *      - boolean removeAll(Collection<?> c)
 *      - boolean retainAll(Collection<?> c) - удалить все, чего нет в предоставленной коллекции
 *     - void clear()
 * - методы для операций с массивами
 *      - Object[] toArray()
 *      - <T> T[] toArray(T[] a) - указание типа возвращаемого массива
 * - стримовые методы (с J8)
 *      - Stream<E> stream()
 *      - Stream<E> parallelStream()
 *
 * */


/* SET
 * - коллекция, которая не может содержать дубликатов
 *      - например, колода кард, процессы, которые исполняются на машине и т.д.
 * - содержит только методы Collection
 * - добавляет более сильный контракт на поведение equals и hashCode, позволяя сравнивать сеты даже
 * с разными имплементациями
 *      - сеты одинаковы если содержат одинаковые элементы
 * - имплементации:
 *      - HashSet
 *          - хранит элементы в хештаблице
 *          - наиболее скоростной
 *          - нет гарантии порядка перебора элементов
 *      - TreeSet
 *          - хранит элементы как red-black tree
 *          - порядок элементов основан на их значениях
 *          - значительно медленнее HashSet
 *      - LinkedHashSet
 *          - хранит элементы в хештаблице с линкд листом идущим по ней
 *          - порядок тот, в котором элементы добавлялись
 *          - избавляет клиентов от хаотичного порядка HashSet, немного большей ценой
 * */


/* SORTEDSET
 * - Set, который сохраняет элементы в возрастающем порядке
 * - есть дополнительные операции для удобства пользования порядком
 * - используются для природно упорядоченных Set
 *      - например, список слов
 * */


/* LIST
 * - упорядоченная коллекция
 *      - иногда называется секвенция
 * - может содержать дубликаты
 * - имеет точный контроль над тем, куда в список вставляется элемент и может обращаться к элементам
 * по их индексам
 * - добавляет более сильный контракт на поведение equals и hashCode, позволяя сравнивать листы с
 * разными имплементациями
 *      - листы равны если те же элементы в том же порядке
 * - имеет дополнительные методы:
 *      - позиционного доступа - манипуляция элементами по их числовой позиции в списке: get, set,
 *      add (добавляет в конец списка), addAll(можно указать место добавления, добавляются в порядке,
 *      как работает их итератор), и remove
 *      (всегда удаляет первый попавшийся совпавший элемент)
 *      - поиска - поиск указанного объекта в списке и возвращение его позиции: indexOf, lastIndexOf
 *      - итерации - расширяет семантику Iterator для получения преимуществ последовательной природы
 *      списка: listIterator
 *      - просмотр диапазона - диапазонные операции над списком: sublist (изменения в оригинале
 *      отражаются в диапазоне -> чем меньше времени существует диапазон, тем меньше шансов, что
 *      произойдут изменения в оригинале, которые неожидаемо повлияют на диапазон)
 * - имплементации:
 *      - ArrayList: обычно более быстрая имплементация
 *      - LinkedList: лучше скорость в некоторых условиях
 * - итераторы:
 *      - iterator: итерация в том же порядке
 *      - listIterator: расширяет итератор, итерация в обе стороны (+ previous, hasPrevious),
 *      изменения листа в текущей позиции (add), получение текущей позиции итератора (index), возможность получить итератор
 *      с нужной позиции
 * - для большинства обычных имплементаций листа, например ArrayList, скорость удаления элементов с
 * конца ощутимо выше удаления элементов с начала
 * - большинство алгоритмов Collections применяются специально к List
 *      - sort: сортирвка листа при помощи алгоритма merge sort - быстрая и стабильная сортировка (
 *      т.е. сортировка, которая не меняет порядок равных элементов)
 *      - shuffle: рандомно переставляет элементы в листе.
 *      - reverse: обращает порядок элементов в списке
 *      - rotate: двигает по кругу элементы на указанную дистанцию
 *      - swap: меняет местами элементы на указанных позициях.
 *      - replaceAll: меняет все встречи одного значения на указанное
 *      - fill: переписывает каждый элемент в списке указанным значением
 *      - copy: копирует лист источник в лист цель.
 *      - binarySearch: ищет элементы в упорядоченном листе при помощи binary search алгоритма.
 *      - indexOfSubList: возвращает индекс первого подлиста одного листа, который равен другому.
 *      - lastIndexOfSubList: возвращает индекс последнего подлиста одного листа, который равен другому
 * */


/* QUEUE
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 * - обычно (но не обязятельно) упорядочивает элементы как FIFO
 *      - среди исключений приоритетные очереди, упорядывающие элементы в соответствии с
 *      предоставленным компаратором или натуральным порядком элементов
 *          - при использовании порядка, операциями remove или poll первым будет доставаться head
 *      - каждая очередь должна указывать свои свойства упорядочивания
 *
 * */


/* DEQUE
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 * - может использоваться как FIFO и LIFO
 *      - т.е. все элементы можно вставить/получить из любого из концов
 *
 * */


/* MAP
 * - мапит ключи и значения
 * - не может содержать дубликатов ключей
 *      - каждый ключ замаплен максимум на одно значение
 * */


/* SORTEDMAP
 * - Map, который сохраняет элементы в возрастающем порядке
 * - используются для природно упорядоченных Map
 *      - например, словари и телефонные справочники
 * */


@Ntrstn("Нужно пользоваться где только возможно интерфейсом Collection, а не спец методами имплементаций")
@Ntrstn("Arrays.asList - методы add, remove не работают, т.к. массивы не меняются, т.е. " +
        "получается нестрандартная имплементация листа")
public class Main2 {

    public static void main(String[] args) {
        String[] s = {"dfs", "dfs", "dfd"};
        List<String> l = Arrays.asList(s);
        ListIterator<String> it = l.listIterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }

    }
}
