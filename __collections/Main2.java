package __collections;

import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;

import types_references_annotations.my_annotations.Ntrstn;

/* СПОСОБЫ ПЕРЕБОРА ЭЛЕМЕНТОВ
 * - 1. агрегатные операции
 *      - желательный способ начиная с J8
 *      - получить стрим и произвести аграгатные операции над ним
 *      - обычно используются в сочетации с ЛВ
 *      - myShapesCollection.stream().filter(e -> e.getColor() == Color.RED)
 *      .forEach(e -> System.out.println(e.getName()));
 *      - разница между новыми агрегатными операциями и существующими балковыми методами (containsAll,
 *      addAll, removeAll), то что старые меняют коллекцию
 * - 2. for-each
 *      - for (Object o : collection) System.out.println(o);
 *      - только чтение
 * - 3. итераторы
 *      - это объект, позволяющий проходить по колекции и выборочно удалять элементы, если нужно
 *      - методы интерфейса итератора
 *          boolean hasNext();
 *          E next();
 *          void remove(); //optional, может вызываться только 1 раз за итерацию
 *      - используется вместо форич, если нужно:
 *          - удалить текущий элемент
 *          - итерировать несколько коллекций параллельно
 *          - например:
 *          static void filter(Collection<?> c) {
    for (Iterator<?> it = c.iterator(); it.hasNext(); )
        if (!cond(it.next()))
            it.remove();
}
 *
 * */


/* COMPARABLE, NATURAL ORDERING, COMPARATOR
 * - натуральный порядок, т.е. как мы привыкли
 * - Collections.sort(l) автоматически сортирует листы в натуральном порядке, если классы
 * имплементируют Comparable
 * - основные классы, которые имплементируют Comparable:Byte, Character, Long, Integer, Short,
 * Double, Float, BigInteger, BigDecimal, Boolean, File, String, Date, Chronological, CollationKey
 *      - никакой из этих классов не позволяет межклассовое сравнение
 * - ClassCastException, если класс не имплементит Comparable, или если сортируется лист, чьи
 * элементы нельзя сравнивать при помощи предоставленного компаратора ()
 * - интерфейс Comparable:
 *      - int compareTo(T o); вернет -1, 0, 1
 * - компаратор используется, если нужно сортировать в ненатуральном порядке или объекты, которые не
 * имплементируют Comparable.
 *      - Comparator это интерфейс с 1 методом int compare(T o1, T o2); // ведет себя как и compareTo
 *      - объект Comparator инкапсулирует порядок
 * */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~ИНТЕРФЕЙСЫ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - Иерархия:
 *      - Collection
 *          - Set - набор элементов без повторений
 *              - SortedSet - сортированный по возрастанию Set
 *          - List - упорядоченный список, обращение к элементам по индексу
 *          - Queue - обычно FIFO
 *          - Deque - FIFO или LIFO
 *      - Map - 1 ключ - значение
 *          - SortedMap - сортированный по возрастанию Map
 *
 * - все базовые являются обобщенными
 *      - позволяет проверять тип содержимого при компиляции
 *
 * - какие-то имплементации могут не реализовывать какие-то модификационные методы
 *      - при вызове UnsupportedOperationException
 *      - все имплементации общего назначения поддерживают все опциональные (модификационные) методы
 *      */


/* COLLECTION
 * - содержит группу объектов, т.е. элементы
 * - содержится во всех коллекциях и используется для передачи коллекций и манипулирования, когда
 * требуется максимальная генерализация
 *      - у всех имплементаций общего назначения есть конструктор, который принимает Collection
 *          - т.н. conversion constructor
 *              - т.е. способ конвертации коллекций
 * - не имплементируется конкретно какой-либо коллекцией
 * - базовые методы:
 *      - int size(),
 *      - boolean isEmpty(),
 *      - boolean contains(Object element),
 *      - boolean add(E element) - гарантирует, что элемент будет и вернет результат добавления
 *      - boolean remove(Object element)
 *      - Iterator<E> iterator()
 * - методы манипулирования целой коллекцией:
 *      - boolean containsAll(Collection<?> c)
 *      - boolean addAll(Collection<? extends E> c)
 *      - boolean removeAll(Collection<?> c)
 *      - boolean retainAll(Collection<?> c) - удалить все, чего нет в предоставленной коллекции
 *     - void clear()
 * - методы для операций с массивами
 *      - Object[] toArray()
 *      - <T> T[] toArray(T[] a) - указание типа возвращаемого массива
 * - стримовые методы (с J8)
 *      - Stream<E> stream()
 *      - Stream<E> parallelStream()
 *
 * */


/* SET
 * - коллекция, которая не может содержать дубликатов
 *      - например, колода кард, процессы, которые исполняются на машине и т.д.
 * - содержит только методы Collection
 * - добавляет более сильный контракт на поведение equals и hashCode, позволяя сравнивать сеты даже
 * с разными имплементациями
 *      - сеты одинаковы если содержат одинаковые элементы
 * - имплементации:
 *      - HashSet
 *          - хранит элементы в хештаблице
 *          - наиболее скоростной
 *          - нет гарантии порядка перебора элементов
 *      - TreeSet
 *          - хранит элементы как red-black tree
 *          - порядок элементов основан на их значениях
 *          - значительно медленнее HashSet
 *      - LinkedHashSet
 *          - хранит элементы в хештаблице с линкд листом идущим по ней
 *          - порядок тот, в котором элементы добавлялись
 *          - избавляет клиентов от хаотичного порядка HashSet, немного большей ценой
 * */


/* SORTEDSET
 * - Set, который сохраняет элементы в возрастающем порядке в соответствии с натуральным порядком
 * элементов или в соответствии с предоставленным компаратором во время создания
 * - используются для природно упорядоченных Set
 *      - например, список слов
 * - методы, унаследованные от набора, ведут себя аналогично, за исключением:
 *      - итератор, возвращаемый iterator, перебирает набор по порядку
 *      - массив, возвращаемый toArray, возвращает упорядоченный массив
 * - есть дополнительные операции для удобства пользования порядком
 *      - просмотр диапазона - разные диапазонноые операции
 *          - похожи на аналогичные у листа с 1 большой разницей - диапазон здесь остается валидным
 *          даже при изменении напрямую оригинального сета, т.к. конечные точки являются абсолютными
 *          в просртанстве элементов, а не конкретных элементов в оригинальной коллекции, как у листа
 *              - изменения в оригинале и в куске отражаются друг в друге, поэтому можно долго юзать
 *              диапазон
 *          SortedSet<E> subSet(E fromElement, E toElement);
 *          SortedSet<E> headSet(E toElement); // от начала и до элемента
 *          SortedSet<E> tailSet(E fromElement); // от элемента и до конца
 *      - конечные точки - вернет первый или последний элемент из сортированного набора
 *          E first();
 *          E last();
 *      - доступ к компаратору - вернет компаратор, если таковой использовался в наборе
 *          Comparator<? super E> comparator();
 * */


/* LIST
 * - упорядоченная коллекция
 *      - иногда называется секвенция
 * - может содержать дубликаты
 * - имеет точный контроль над тем, куда в список вставляется элемент и может обращаться к элементам
 * по их индексам
 * - добавляет более сильный контракт на поведение equals и hashCode, позволяя сравнивать листы с
 * разными имплементациями
 *      - листы равны если те же элементы в том же порядке
 * - имеет дополнительные методы:
 *      - позиционного доступа - манипуляция элементами по их числовой позиции в списке: get, set,
 *      add (добавляет в конец списка), addAll(можно указать место добавления, добавляются в порядке,
 *      как работает их итератор), и remove
 *      (всегда удаляет первый попавшийся совпавший элемент)
 *      - поиска - поиск указанного объекта в списке и возвращение его позиции: indexOf, lastIndexOf
 *      - итерации - расширяет семантику Iterator для получения преимуществ последовательной природы
 *      списка: listIterator
 *      - просмотр диапазона - диапазонные операции над списком: sublist (изменения в оригинале
 *      отражаются в диапазоне -> чем меньше времени существует диапазон, тем меньше шансов, что
 *      произойдут изменения в оригинале, которые неожидаемо повлияют на диапазон)
 * - имплементации:
 *      - ArrayList: обычно более быстрая имплементация
 *      - LinkedList: лучше скорость в некоторых условиях
 * - итераторы:
 *      - iterator: итерация в том же порядке
 *      - listIterator: расширяет итератор, итерация в обе стороны (+ previous, hasPrevious),
 *      изменения листа в текущей позиции (add), получение текущей позиции итератора (index), возможность получить итератор
 *      с нужной позиции
 * - для большинства обычных имплементаций листа, например ArrayList, скорость удаления элементов с
 * конца ощутимо выше удаления элементов с начала
 * - большинство алгоритмов Collections применяются специально к List
 *      - sort: сортирвка листа при помощи алгоритма merge sort - быстрая и стабильная сортировка (
 *      т.е. сортировка, которая не меняет порядок равных элементов)
 *      - shuffle: рандомно переставляет элементы в листе.
 *      - reverse: обращает порядок элементов в списке
 *      - rotate: двигает по кругу элементы на указанную дистанцию
 *      - swap: меняет местами элементы на указанных позициях.
 *      - replaceAll: меняет все встречи одного значения на указанное
 *      - fill: переписывает каждый элемент в списке указанным значением
 *      - copy: копирует лист источник в лист цель.
 *      - binarySearch: ищет элементы в упорядоченном листе при помощи binary search алгоритма.
 *      - indexOfSubList: возвращает индекс первого подлиста одного листа, который равен другому.
 *      - lastIndexOfSubList: возвращает индекс последнего подлиста одного листа, который равен другому
 * */


/* QUEUE
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 *      - у каждого из методов 2 формы: одна выбрасывает исключение при неуспехе операции, вторая
 *      возвращает специальное значение при неуспехе (либо null либо false)
 *      - вставка:
 *          - add(e) - выкидывает исключение (в случае отсутствия места в ограниченной очереди)
 *          - offer(e) - возвращает значение (в случае отсутствия места в ограниченной очереди)
 *      - удаление:
 *          - remove() - выкидывает исключение (если нет элементов)
 *          - poll() - возвращает значение (если нет элементов)
 *      - просмотр:
 *          - element() - выкидывает исключение (если нет элементов)
 *          - peek() - возвращает значение (если нет элементов)
 *
 * - обычно (но не обязятельно) упорядочивает элементы как FIFO
 *      - среди исключений приоритетные очереди, упорядывающие элементы в соответствии с
 *      предоставленным компаратором или натуральным порядком элементов
 *          - при использовании порядка, операциями remove или poll первым будет доставаться head
 *      - каждая очередь должна указывать свои свойства упорядочивания
 *
 * - некоторые имплементации из java.util.concurrent можно ограничивать, но никакие из java.util
 *
 * - обычно не позволяют вставлять null элементы
 *      - исключение LinkedList, но все равно не рекомендуется
 *
 * - Queue implementations generally do not define element-based versions of the equals and hashCode
 * methods but instead inherit the identity-based versions from Object.
 *
 * - java.util.concurrent.BlockingQueue расширяет Queue и добавляет методы ожидания появляения
 * элемента/места
 * */


/* DEQUE (DOUBLE-ENDED QUEUE)
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 * - может использоваться как FIFO и LIFO
 *      - т.е. все элементы можно вставить/получить из любого из концов
 *      - т.е. имплементирует и Queue и Stack
 * - реализации:  ArrayDeque и LinkedList
 * - методы:
 *      - вставка:
 *          - в начало:
 *              - addfirst (выбрасывает исключение)
 *              - offerFirst (возвращает значение)
 *          - в конец:
 *              - addLast (выбрасывает исключение)
 *             - offerLast (возвращает значение)
 *      - удаление:
 *          - removeFirst(), pollFirst()
 *          - removeLast(), pollLast()
 *      - иследование:
 *          - getFirst(), peekFirst()
 *          - getLast(), peekLast()
 *
 * - также есть дополнительные методы:
 *      - removeFirstOccurence, removeLastOccurence - удаляет первую/последнюю встречу элемента,
 *      если он есть
 * */


/* MAP
 * - мапит ключи и значения
 * - не может содержать дубликатов ключей
 *      - каждый ключ замаплен максимум на одно значение
 * - моделирует математическую абстракцию функции
 * - базовые методы:
 * put, get, remove, containsKey, containsValue, size, and empty
 * - балковые методы: putAll, clear
 * - просмотр мапы как коллекции (единственный способ итерации по мапе):
 *      - keySet - набор ключей
 *          - for (KeyType key : m.keySet()) System.out.println(key);
 *     - values - коллекция значений (не набор, т.к. могут быть повторения)
 *     - entrySet - набор пар ключей-значений, содержащихся в мапе. У интерфейса мап есть вложенный
 *     интерфейс Map.Entry, тип элементов в данном наборе
 *          - у Map.Entry также есть метод setValue - можно менять значение
 *              - это единственный способ безопасно менять мапу при итерации
 *     - для ускорения, всегда возвращаются те же объекты, а не создаются новые
 * - имплементации:
 *      - HashMap
 *          - LinkedHashMap
 *      - TreeMap
 * - скорость действия аналогично имплементациям сетов
 * -  как и Set и List ужесточает требования для equals и hashCode, чтобы можно было сравнить 2 мапы
 * вне зависимости от имплементаций
 *      - 2 мапы равны, если представляют тот же мапинг ключей-значений
 * - по договоренности есть конструкторы, принимающие другие мапы
 * - если у одного ключа должно быть несколько значени (multimap), то можно использовать List для
 * хранения этих значений
 * */


/* SORTEDMAP
 * - Map, который сохраняет элементы в возрастающем порядке в соответствии с натуральным порядком
 * ключей или в соответствии с предоставленным компаратором во время создания
 * - используются для природно упорядоченных Map
 *      - например, словари и телефонные справочники
 * - методы, унаследованные от мапы, ведут себя аналогично, за исключением:
 *      - итератор, возвращаемый iterator, перебирает набор по порядку
 *      - массив, возвращаемый toArray, возвращает упорядоченный массив ключей, значений или записей
 * - есть дополнительные операции для удобства пользования порядком
 *      - просмотр диапазона - разные диапазонноые операции
 *          - похожи на аналогичные у листа с 1 большой разницей - диапазон здесь остается валидным
 *          даже при изменении напрямую оригинального сета, т.к. конечные точки являются абсолютными
 *          в просртанстве элементов, а не конкретных элементов в оригинальной коллекции, как у листа
 *              - изменения в оригинале и в куске отражаются друг в друге, поэтому можно долго юзать
 *              диапазон
 *          SortedSet<E> subSet(E fromElement, E toElement);
 *          SortedSet<E> headSet(E toElement); // от начала и до элемента
 *          SortedSet<E> tailSet(E fromElement); // от элемента и до конца
 *      - конечные точки - вернет первый или последний элемент из сортированного набора
 *          E first();
 *          E last();
 *      - доступ к компаратору - вернет компаратор, если таковой использовался в наборе
 *          Comparator<? super E> comparator();
 * */


/* ИМПЛЕМЕНТАЦИИ
 * - общего назначения - наиболее используемые
 * - спец назначения - для особых ситуаций, с нестандартными хар-ками скорости, поведения, ограничений
 * - concurrent (java.util.concurrent) - для поддержки высокоуравневой многопоточности, обычно по цене однопоточного
 * исполнения
 * - оберточного назначения - используются в комбинации с другими типами имплементаций, обычно
 * общего назначения, чтобы добавить или ограничить функционал
 *      - как паттерн декоратор
 * - для удобства - мини-имплементации, обычно доступные через статичные фабричные методы, и
 * предоставляют удобные и эффективные альтернативы общим имплементациям для специальных коллекций
 * (например, singleton sets)
 * - абстрактные - скелетные имплементации, которые способствуют созданию кастомных имплементаций.
 * Мало кому понадобится.
 * */

/* ИМПЛЕМЕНТАЦИИ ОБЩЕГО НАЗНАЧЕНИЯ
 * - Hash table:
 *      - HashSet*
 *      - HashMap*
 * - Resizable array:
 *      - ArrayList*
 *      - ArrayDeque*
 * - Tree:
 *      - TreeSet, SortedSet
 *      - TreeMap, SortedMap
 * - Linked list:
 *      - LinkedList (List)
 *      - LinkedList (Deque)
 * - Hash table + Linked list
 *      - LinkedHashSet
 *      - LinkedHashMap
 *
 * - у Queue 2 общих имплементации:
 *      - LinkedList*: FIFO семантика
 *      - PriorityQueue: порядок в зависимости от значений
 *
 * - все общие имплементации:
 *      - допускают null elements, keys, and values
 *      - не синхронизированы
 *      - имеют fail-fast итераторы
 *          - определяют illegal concurrent изменение во время итерации и быстро и чисто падают,
 *          чтобы избежать непоняток
 *      - все Serializable
 *      - все поддерживают метод clone
 *
 * * - наиболее используемая
 * */


/* ИМПЛЕМЕНТАЦИИ SET
 * - общего назначения:
 *      - HashSet - быстрее (constant-time), нет гарантий порядка
 *          - итерации линейны по сумме числа элементов и вместимости, поэтому при большой начальной
 *          вместимости будут потери времени и места, а при изначально малой - будут часто
 *          пересоздаваться массивы и копироваться. Если не указать - дефолтный 16
 *      - TreeSet - медленней (log-time), есть порядок.
 *      - LinkedHashSet - что-то среднее, почти такое же быстрое как хешсет, предоставляет insertion-
 *      ordered iteration (least recently inserted to most recently). Т.е. нужна и скорость и порядок.
 *      Имеет такие же параметры настройки как HashSet, но время итерации не страдает от вместимости.
 * - спец назначения:
 *      - EnumSet - высокоскоростная имплементация сет для энамов (одного типа), плюс кое-какие плюшки.
 *      - CopyOnWriteArraySet - все операции изменения проводятся после создания копии массива,
 *      поэтому не нужен лок, и даже можно итерировать многопоточно
 *          - но операции add, remove, contains требуют время пропорциональное размеру сета.
 *          - подходит только для сетов, которые редко меняются, но часто итерируются
 * */


/* ИМПЛЕМЕНТАЦИИ LIST
 * - общего:
 *      - ArrayList:
 *          - предпочтительней
 *          - константное время доступа
 *          - может пользоваться System.arraycopy, когда нужно двигать несколько элементов одновременно
 *          - можно указывать начальную вместимость
 *      - LinkedList
 *          - константное время
 *              - если часто добавлять элементы в начало списка
 *              - если часто итерировать по списку, чтобы удалять элементы
 *              -  у аррайлиста линейное
 *          - но линейное время доступа
 *          - имплементит Queue
 *          - прежде чем использовать, всегда сравнить перформанс с аррайлистом
 *
 * - специального:
 *      - CopyOnWriteArrayList - все операции изменения проводятся после создания копии массива,
 *      поэтому не нужен лок, и даже можно итерировать многопоточно
 *          - но операции add, remove, contains требуют время пропорциональное размеру сета.
 *          - подходит только для листов, которые редко меняются, но часто итерируются
 * */


/* ИМПЛЕМЕНТАЦИИ МАР
 * - общего:
 *      - HashMap
 *          - максимальная скорость, но нет порядка итерации
 *      - TreeMap
 *          - когда нужен сортированный
 *      - LinkedHashMap
 *          - нечто среднее
 *              - аналогично с сетом
 *                  - но также:
 *                      - его можно создавать на основе key access а не вставки
 *                          - т.е. просмотр по ключу, сдвигает пару в конец мапы
 *                      - метод removeEldestEntry, чтобы при добавлении новой пары удалять самую
 *                      старую пару
 *                          - удобно для кастомного кеша
 *
 * - специального:
 *      - EnumMap
 *          - высокоскоростной (на массиве) для енумов
 *          - лучше, чем просто аррей, когда нужно мапить значения с енумами
 *      - WeakHashMap
 *          - хранит только слабые ссылки на свои ключи
 *              - т.е. сборщик мусора может удалить пару, если на ключ больше нигде снаружи не
 *              ссылаются
 *              - полезен для "регистровый" стуктрур данных
 *      - IdentityHashMap
 *          - быстрое и имеет специфические особенности, типа:
 *            - topology-preserving object graph transformations, т.е. сериализация или глубокое копирование и т.д
 *
 * - многопоточного:
 *      - интерфейс ConcurrentMap расширяет Map
 *          - атомические методы: putIfAbsent, remove, and replace
 *          - имплементация: ConcurrentHashMap
 *              - высокоскоростная
 * */


/* ИМПЛЕМЕНТАЦИИ QUEUE
 * - общего назначения:
 *      - LinkedList
 *          - FIFO операции для add, poll и т.д.
 *      - PriorityQueue
 *          - основан на heap структуре данных
 *          - упорядывачивает элементы на основе указаного при создании порядка
 *              - природный порядок или компаратор
 *          - poll, remove, peek, и element достают элемент из начала очереди
 *          - имплементит все опциональные методы инт-сов коллекции и итератор
 *          - итератор не гарантирует перебор в каком-то определенном порядке
 *              - для порядочного перебора расмотри Arrays.sort(pq.toArray())
 *
 * - многопоточного:
 *      - есть набор синхронизированный интерфейсов и классов Queue
 *      - BlockingQueue расширяет очередь операциями ожидания пока очередь не станет непустой при
 *      получении элемента или когда появится свободное место при добавлении
 *          - имплементации:
 *              - LinkedBlockingQueue: опционально ограниченная FIFO блокируюшая queue на основе
 *             linked nodes
 *              - ArrayBlockingQueue: ограниченная FIFO blocking queue на основе массива
 *              - PriorityBlockingQueue: неограниченная blocking priority queue на основе heap
 *              - DelayQueue: a time-based scheduling queue backed by a heap
 *              - SynchronousQueue: простой рандеву механизм, кот использует инт-с BlockingQueue
 *      - TransferQueue расширяет BlockingQueue, чтобы код, кот. добавляет элемент имел выбор
 *      ожидать пока другая ветка получит элемент
 *          - имплементация:
 *              - LinkedTransferQueue — не ограниченная TransferQueue на основе linked nodes
 * */


/* ИМПЛЕМЕНТАЦИИ DEQUE
 * - общего назначения:
 *      - ArrayDeque:
 *          - на основе способного менять размер массива
 *          - быстрее для операций добавки и удаления
 *      - LinkedList
 *          - на основе листа
 *          - более гибкий чем аррай
 *              - имплементит все опциональные операции
 *              - можно добавлять нал null
 *          - наиб подходящая операция - удалять элемент при итерации
 *          - потребляет больше памяти
 *
 * - многопоточного:
 *      - LinkedBlockingDeque
 *          - если очередь пуста то методы ждут появления элементов перед работой над ним
 * */


/* WRAPPER ИМПЛЕМЕНТАЦИИ
 * - на основе декоратора
 * - имплементации анонимны - создаются от фабричного стат метода в Collections
 * - синхронизационные:
 *      - методы public static <T> ...<T> synchronized...(...<T> c);
 *      - итерировать по коллекции нужно атомически:
 *          - synchronized(c) {for (Type e : c)foo(e);}
 *      - 1 минус - нельзя использовать неинтерфейсные методы обернутой имплементации
 *
 * - неизменяемые:
 *      - убирают возможность изменять элементы
 *          - перехватывают команды и выбрасывают исключение UnsupportedOperationException
 *      - используются:
 *          - сделать коллекцию неизменяемое при создании
 *              - желательно не сохранять линк на оригинал
 *          - позволить определенным клиентам только чтение
 *      - методы public static <T> ...<T> unmodifiable...(...<? extends T> c);
 *
 * - Checked Interface:
 *      - инт-с Collections.checked
 *      - для использования с обобщениями
 *          - вернут ДИНАМИЧЕСКИ (а не компиляторный, как у генериков) типо-безопасный view
 *          указанной коллекции, которая выкинет
 *          ClassCastException, если клиент пытается добавить элемент не того типа
 * */

/* ИМПЛЕМЕНТАЦИИ УДОБСТВА
 * - List view для массива:
 *      - Arrays.asList - вернет лист-вью массива в аргументе
 *          - изменения в одном приводят к изменнеиям в другом
 *          - размер листа нельзя менять
 *              - выкенет UnsupportedOperationException
 *          - полезен не только как мост между массивом и листом, но еще и когда нужен лист
 *          фиксированного размера, т.к. он быстрее имплементации листа общего назначения
 *
 * - Неизменяемый лист с множеством копий 1 элемента
 *      - Collections.nCopies
 *      - например, если
 *          - нужно инициализировать лист, который изначально состоит только из null
 *              - List<Type> list = new ArrayList<Type>(Collections.nCopies(1000, (Type)null);
 *          - нужно расширить текущий лист (в т.ч. вставить в середину)
 *              - lovablePets.addAll(Collections.nCopies(69, "fruit bat"));
 *
 * - Неизменяемый набор синглтонов
 *      - Collections.singleton
 *      - например, если
 *          - нужно удалить все повторы указанного элемента из коллекции
 *              c.removeAll(Collections.singleton(e));
 *          - нужно удалить все значения для определенного ключа
 *              job.values().removeAll(Collections.singleton(LAWYER));
 *          - нужно предоставить единичное входное значение для метода, который расчитан на прием
 *          коллекции значений
 *
 * - Константы с пустыми Set, List, и Map
 *      - Collections.empty...
 *          - например нужно в метод, который принимает коллекцию
 *          tourist.declarePurchases(Collections.emptySet())
 * */


/* ПОЛИМОРФНЫЕ АЛГОРИТМЫ COLLECTIONS
 * - (большинство для List, но есть и для любых)
 * - сортировка: sort
 *      - для листа
 *      - либо сортирует лист по возрастанию в натуратольном порядке, либо принимает компаратор
 *      - на основе немного оптимизированного merge sort
 *          - быстро: log(n)
 *          - стабильно: не меняет порядок равных элементов. Т.е. если я сортирую письма по дате, а
 *          потом по отправителю, то я ожидаю, что порядок по дате сохраниться. Это обеспечивает
 *          стабильность.
 *
 * - shuffling: shuffle
 *      - для листа
 *      - либо использует дефолтный источник рандомизации либо принимает объект Random
 *
 * - рутинные операции с данными
 *      - reverse - обращает порядок элементов в списке.
 *      - fill - перезаписывает каждый элемент в списке с указанным значением.
 *          - полезно для повторной инициализации списка
 *      - copy - копирует 1 лист на другой, перезаписывая элементы.
 *      - swap - поменять местами элементы в листе.
 *      - addAll - добавляет все элементы в коллекцию
 *
 * - поиск: binarySearch
 *      - для листа
 *      - либо принимает лист и элемент, который ищется (ключ)
 *          - ожидается, что лист сортирован в возрастающем натуральном порядке
 *              - т.е. сначала нужно сделать сортировку sort
 *      - либо принимает также Comparator
 *      - вернет индекс элемента, если есть, или отрицательное число, если нет (там корявая формула)
 *
 * - композиция: frequency, disjoint
 *      - frequency - сколько раз указанный элемент встречается в коллекции
 *      - disjoint - определяет, являются ли две коллекции непересекающимися
 *          - то есть не содержат общих элементов
 *
 * - поиск минимальных и максимальных значений: min, max
 *      - либо вернет по натуральному порядку
 *      - либо по указанному компаратору */




@Ntrstn("Нужно пользоваться где только возможно интерфейсом Collection, а не спец методами имплементаций")
@Ntrstn("Arrays.asList - методы add, remove не работают, т.к. массивы не меняются, т.е. " +
        "получается нестрандартная имплементация листа")
@Ntrstn("Важно помнить, что фор ич не позволяет менять элементы, поэтому используется итератор ")

public class Main2 {

    public static void main(String[] args) {
        String[] s = {"dfs", "dfs", "dfd"};
        List<String> l = Arrays.asList(s);
        ListIterator<String> it = l.listIterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }

    }
}
