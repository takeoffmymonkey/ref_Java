package __collections;

import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;

import types_references_annotations.my_annotations.Ntrstn;

/* СПОСОБЫ ПЕРЕБОРА ЭЛЕМЕНТОВ
 * - 1. агрегатные операции
 *      - желательный способ начиная с J8
 *      - получить стрим и произвести аграгатные операции над ним
 *      - обычно используются в сочетации с ЛВ
 *      - myShapesCollection.stream().filter(e -> e.getColor() == Color.RED)
 *      .forEach(e -> System.out.println(e.getName()));
 *      - разница между новыми агрегатными операциями и существующими балковыми методами (containsAll,
 *      addAll, removeAll), то что старые меняют коллекцию
 * - 2. for-each
 *      - for (Object o : collection) System.out.println(o);
 *      - только чтение
 * - 3. итераторы
 *      - это объект, позволяющий проходить по колекции и выборочно удалять элементы, если нужно
 *      - методы интерфейса итератора
 *          boolean hasNext();
 *          E next();
 *          void remove(); //optional, может вызываться только 1 раз за итерацию
 *      - используется вместо форич, если нужно:
 *          - удалить текущий элемент
 *          - итерировать несколько коллекций параллельно
 *          - например:
 *          static void filter(Collection<?> c) {
    for (Iterator<?> it = c.iterator(); it.hasNext(); )
        if (!cond(it.next()))
            it.remove();
}
 *
 * */


/* COMPARABLE, NATURAL ORDERING, COMPARATOR
 * - натуральный порядок, т.е. как мы привыкли
 * - Collections.sort(l) автоматически сортирует листы в натуральном порядке, если классы
 * имплементируют Comparable
 * - основные классы, которые имплементируют Comparable:Byte, Character, Long, Integer, Short,
 * Double, Float, BigInteger, BigDecimal, Boolean, File, String, Date, Chronological, CollationKey
 *      - никакой из этих классов не позволяет межклассовое сравнение
 * - ClassCastException, если класс не имплементит Comparable, или если сортируется лист, чьи
 * элементы нельзя сравнивать при помощи предоставленного компаратора ()
 * - интерфейс Comparable:
 *      - int compareTo(T o); вернет -1, 0, 1
 * - компаратор используется, если нужно сортировать в ненатуральном порядке или объекты, которые не
 * имплементируют Comparable.
 *      - Comparator это интерфейс с 1 методом int compare(T o1, T o2); // ведет себя как и compareTo
 *      - объект Comparator инкапсулирует порядок
 * */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~ИНТЕРФЕЙСЫ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - Иерархия:
 *      - Collection
 *          - Set - набор элементов без повторений
 *              - SortedSet - сортированный по возрастанию Set
 *          - List - упорядоченный список, обращение к элементам по индексу
 *          - Queue - обычно FIFO
 *          - Deque - FIFO или LIFO
 *      - Map - 1 ключ - значение
 *          - SortedMap - сортированный по возрастанию Map
 *
 * - все базовые являются обобщенными
 *      - позволяет проверять тип содержимого при компиляции
 *
 * - какие-то имплементации могут не реализовывать какие-то модификационные методы
 *      - при вызове UnsupportedOperationException
 *      - все имплементации общего назначения поддерживают все опциональные (модификационные) методы
 *      */


/* COLLECTION
 * - содержит группу объектов, т.е. элементы
 * - содержится во всех коллекциях и используется для передачи коллекций и манипулирования, когда
 * требуется максимальная генерализация
 *      - у всех имплементаций общего назначения есть конструктор, который принимает Collection
 *          - т.н. conversion constructor
 *              - т.е. способ конвертации коллекций
 * - не имплементируется конкретно какой-либо коллекцией
 * - базовые методы:
 *      - int size(),
 *      - boolean isEmpty(),
 *      - boolean contains(Object element),
 *      - boolean add(E element) - гарантирует, что элемент будет и вернет результат добавления
 *      - boolean remove(Object element)
 *      - Iterator<E> iterator()
 * - методы манипулирования целой коллекцией:
 *      - boolean containsAll(Collection<?> c)
 *      - boolean addAll(Collection<? extends E> c)
 *      - boolean removeAll(Collection<?> c)
 *      - boolean retainAll(Collection<?> c) - удалить все, чего нет в предоставленной коллекции
 *     - void clear()
 * - методы для операций с массивами
 *      - Object[] toArray()
 *      - <T> T[] toArray(T[] a) - указание типа возвращаемого массива
 * - стримовые методы (с J8)
 *      - Stream<E> stream()
 *      - Stream<E> parallelStream()
 *
 * */


/* SET
 * - коллекция, которая не может содержать дубликатов
 *      - например, колода кард, процессы, которые исполняются на машине и т.д.
 * - содержит только методы Collection
 * - добавляет более сильный контракт на поведение equals и hashCode, позволяя сравнивать сеты даже
 * с разными имплементациями
 *      - сеты одинаковы если содержат одинаковые элементы
 * - имплементации:
 *      - HashSet
 *          - хранит элементы в хештаблице
 *          - наиболее скоростной
 *          - нет гарантии порядка перебора элементов
 *      - TreeSet
 *          - хранит элементы как red-black tree
 *          - порядок элементов основан на их значениях
 *          - значительно медленнее HashSet
 *      - LinkedHashSet
 *          - хранит элементы в хештаблице с линкд листом идущим по ней
 *          - порядок тот, в котором элементы добавлялись
 *          - избавляет клиентов от хаотичного порядка HashSet, немного большей ценой
 * */


/* SORTEDSET
 * - Set, который сохраняет элементы в возрастающем порядке в соответствии с натуральным порядком
 * элементов или в соответствии с предоставленным компаратором во время создания
 * - используются для природно упорядоченных Set
 *      - например, список слов
 * - методы, унаследованные от набора, ведут себя аналогично, за исключением:
 *      - итератор, возвращаемый iterator, перебирает набор по порядку
 *      - массив, возвращаемый toArray, возвращает упорядоченный массив
 * - есть дополнительные операции для удобства пользования порядком
 *      - просмотр диапазона - разные диапазонноые операции
 *          - похожи на аналогичные у листа с 1 большой разницей - диапазон здесь остается валидным
 *          даже при изменении напрямую оригинального сета, т.к. конечные точки являются абсолютными
 *          в просртанстве элементов, а не конкретных элементов в оригинальной коллекции, как у листа
 *              - изменения в оригинале и в куске отражаются друг в друге, поэтому можно долго юзать
 *              диапазон
 *          SortedSet<E> subSet(E fromElement, E toElement);
 *          SortedSet<E> headSet(E toElement); // от начала и до элемента
 *          SortedSet<E> tailSet(E fromElement); // от элемента и до конца
 *      - конечные точки - вернет первый или последний элемент из сортированного набора
 *          E first();
 *          E last();
 *      - доступ к компаратору - вернет компаратор, если таковой использовался в наборе
 *          Comparator<? super E> comparator();
 * */


/* LIST
 * - упорядоченная коллекция
 *      - иногда называется секвенция
 * - может содержать дубликаты
 * - имеет точный контроль над тем, куда в список вставляется элемент и может обращаться к элементам
 * по их индексам
 * - добавляет более сильный контракт на поведение equals и hashCode, позволяя сравнивать листы с
 * разными имплементациями
 *      - листы равны если те же элементы в том же порядке
 * - имеет дополнительные методы:
 *      - позиционного доступа - манипуляция элементами по их числовой позиции в списке: get, set,
 *      add (добавляет в конец списка), addAll(можно указать место добавления, добавляются в порядке,
 *      как работает их итератор), и remove
 *      (всегда удаляет первый попавшийся совпавший элемент)
 *      - поиска - поиск указанного объекта в списке и возвращение его позиции: indexOf, lastIndexOf
 *      - итерации - расширяет семантику Iterator для получения преимуществ последовательной природы
 *      списка: listIterator
 *      - просмотр диапазона - диапазонные операции над списком: sublist (изменения в оригинале
 *      отражаются в диапазоне -> чем меньше времени существует диапазон, тем меньше шансов, что
 *      произойдут изменения в оригинале, которые неожидаемо повлияют на диапазон)
 * - имплементации:
 *      - ArrayList: обычно более быстрая имплементация
 *      - LinkedList: лучше скорость в некоторых условиях
 * - итераторы:
 *      - iterator: итерация в том же порядке
 *      - listIterator: расширяет итератор, итерация в обе стороны (+ previous, hasPrevious),
 *      изменения листа в текущей позиции (add), получение текущей позиции итератора (index), возможность получить итератор
 *      с нужной позиции
 * - для большинства обычных имплементаций листа, например ArrayList, скорость удаления элементов с
 * конца ощутимо выше удаления элементов с начала
 * - большинство алгоритмов Collections применяются специально к List
 *      - sort: сортирвка листа при помощи алгоритма merge sort - быстрая и стабильная сортировка (
 *      т.е. сортировка, которая не меняет порядок равных элементов)
 *      - shuffle: рандомно переставляет элементы в листе.
 *      - reverse: обращает порядок элементов в списке
 *      - rotate: двигает по кругу элементы на указанную дистанцию
 *      - swap: меняет местами элементы на указанных позициях.
 *      - replaceAll: меняет все встречи одного значения на указанное
 *      - fill: переписывает каждый элемент в списке указанным значением
 *      - copy: копирует лист источник в лист цель.
 *      - binarySearch: ищет элементы в упорядоченном листе при помощи binary search алгоритма.
 *      - indexOfSubList: возвращает индекс первого подлиста одного листа, который равен другому.
 *      - lastIndexOfSubList: возвращает индекс последнего подлиста одного листа, который равен другому
 * */


/* QUEUE
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 *      - у каждого из методов 2 формы: одна выбрасывает исключение при неуспехе операции, вторая
 *      возвращает специальное значение при неуспехе (либо null либо false)
 *      - вставка:
 *          - add(e) - выкидывает исключение (в случае отсутствия места в ограниченной очереди)
 *          - offer(e) - возвращает значение (в случае отсутствия места в ограниченной очереди)
 *      - удаление:
 *          - remove() - выкидывает исключение (если нет элементов)
 *          - poll() - возвращает значение (если нет элементов)
 *      - просмотр:
 *          - element() - выкидывает исключение (если нет элементов)
 *          - peek() - возвращает значение (если нет элементов)
 *
 * - обычно (но не обязятельно) упорядочивает элементы как FIFO
 *      - среди исключений приоритетные очереди, упорядывающие элементы в соответствии с
 *      предоставленным компаратором или натуральным порядком элементов
 *          - при использовании порядка, операциями remove или poll первым будет доставаться head
 *      - каждая очередь должна указывать свои свойства упорядочивания
 *
 * - некоторые имплементации из java.util.concurrent можно ограничивать, но никакие из java.util
 *
 * - обычно не позволяют вставлять null элементы
 *      - исключение LinkedList, но все равно не рекомендуется
 *
 * - Queue implementations generally do not define element-based versions of the equals and hashCode
 * methods but instead inherit the identity-based versions from Object.
 *
 * - java.util.concurrent.BlockingQueue расширяет Queue и добавляет методы ожидания появляения
 * элемента/места
 * */


/* DEQUE (DOUBLE-ENDED QUEUE)
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 * - может использоваться как FIFO и LIFO
 *      - т.е. все элементы можно вставить/получить из любого из концов
 *      - т.е. имплементирует и Queue и Stack
 * - реализации:  ArrayDeque и LinkedList
 * - методы:
 *      - вставка:
 *          - в начало:
 *              - addfirst (выбрасывает исключение)
 *              - offerFirst (возвращает значение)
 *          - в конец:
 *              - addLast (выбрасывает исключение)
 *             - offerLast (возвращает значение)
 *      - удаление:
 *          - removeFirst(), pollFirst()
 *          - removeLast(), pollLast()
 *      - иследование:
 *          - getFirst(), peekFirst()
 *          - getLast(), peekLast()
 *
 * - также есть дополнительные методы:
 *      - removeFirstOccurence, removeLastOccurence - удаляет первую/последнюю встречу элемента,
 *      если он есть
 * */


/* MAP
 * - мапит ключи и значения
 * - не может содержать дубликатов ключей
 *      - каждый ключ замаплен максимум на одно значение
 * - моделирует математическую абстракцию функции
 * - базовые методы:
 * put, get, remove, containsKey, containsValue, size, and empty
 * - балковые методы: putAll, clear
 * - просмотр мапы как коллекции (единственный способ итерации по мапе):
 *      - keySet - набор ключей
 *          - for (KeyType key : m.keySet()) System.out.println(key);
 *     - values - коллекция значений (не набор, т.к. могут быть повторения)
 *     - entrySet - набор пар ключей-значений, содержащихся в мапе. У интерфейса мап есть вложенный
 *     интерфейс Map.Entry, тип элементов в данном наборе
 *          - у Map.Entry также есть метод setValue - можно менять значение
 *              - это единственный способ безопасно менять мапу при итерации
 *     - для ускорения, всегда возвращаются те же объекты, а не создаются новые
 * - имплементации:
 *      - HashMap
 *          - LinkedHashMap
 *      - TreeMap
 * - скорость действия аналогично имплементациям сетов
 * -  как и Set и List ужесточает требования для equals и hashCode, чтобы можно было сравнить 2 мапы
 * вне зависимости от имплементаций
 *      - 2 мапы равны, если представляют тот же мапинг ключей-значений
 * - по договоренности есть конструкторы, принимающие другие мапы
 * - если у одного ключа должно быть несколько значени (multimap), то можно использовать List для
 * хранения этих значений
 * */


/* SORTEDMAP
 * - Map, который сохраняет элементы в возрастающем порядке в соответствии с натуральным порядком
 * ключей или в соответствии с предоставленным компаратором во время создания
 * - используются для природно упорядоченных Map
 *      - например, словари и телефонные справочники
 * - методы, унаследованные от мапы, ведут себя аналогично, за исключением:
 *      - итератор, возвращаемый iterator, перебирает набор по порядку
 *      - массив, возвращаемый toArray, возвращает упорядоченный массив ключей, значений или записей
 * - есть дополнительные операции для удобства пользования порядком
 *      - просмотр диапазона - разные диапазонноые операции
 *          - похожи на аналогичные у листа с 1 большой разницей - диапазон здесь остается валидным
 *          даже при изменении напрямую оригинального сета, т.к. конечные точки являются абсолютными
 *          в просртанстве элементов, а не конкретных элементов в оригинальной коллекции, как у листа
 *              - изменения в оригинале и в куске отражаются друг в друге, поэтому можно долго юзать
 *              диапазон
 *          SortedSet<E> subSet(E fromElement, E toElement);
 *          SortedSet<E> headSet(E toElement); // от начала и до элемента
 *          SortedSet<E> tailSet(E fromElement); // от элемента и до конца
 *      - конечные точки - вернет первый или последний элемент из сортированного набора
 *          E first();
 *          E last();
 *      - доступ к компаратору - вернет компаратор, если таковой использовался в наборе
 *          Comparator<? super E> comparator();
 * */


@Ntrstn("Нужно пользоваться где только возможно интерфейсом Collection, а не спец методами имплементаций")
@Ntrstn("Arrays.asList - методы add, remove не работают, т.к. массивы не меняются, т.е. " +
        "получается нестрандартная имплементация листа")
public class Main2 {

    public static void main(String[] args) {
        String[] s = {"dfs", "dfs", "dfd"};
        List<String> l = Arrays.asList(s);
        ListIterator<String> it = l.listIterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }

    }
}
