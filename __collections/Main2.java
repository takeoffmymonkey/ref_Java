package __collections;

import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;

import types_references_annotations.my_annotations.Ntrstn;

/* ОБЩЕЕ
 * - какие-то имплементации могут не реализовывать какие-то опциональные (модификационные) методы
 *      - при вызове UnsupportedOperationException
 *      - все имплементации общего назначения поддерживают все опциональные методы
 *      */

/* ИМПЛЕМЕНТАЦИИ
 * - общего назначения - наиболее используемые
 * - спец назначения - для особых ситуаций, с нестандартными хар-ками скорости, поведения, ограничений
 * - concurrent (java.util.concurrent) - для поддержки высокоуравневой многопоточности, обычно по цене однопоточного
 * исполнения
 * - оберточного назначения - используются в комбинации с другими типами имплементаций, обычно
 * общего назначения, чтобы добавить или ограничить функционал
 *      - как паттерн декоратор
 * - для удобства - мини-имплементации, обычно доступные через статичные фабричные методы, и
 * предоставляют удобные и эффективные альтернативы общим имплементациям для специальных коллекций
 * (например, singleton sets)
 * - абстрактные - скелетные имплементации, которые способствуют созданию кастомных имплементаций.
 * Мало кому понадобится.
 * */

/*===============================================================*/
/* СПОСОБЫ ПЕРЕБОРА ЭЛЕМЕНТОВ
 * - 1. агрегатные операции
 *      - желательный способ начиная с J8
 *      - получить стрим и произвести аграгатные операции над ним
 *      - обычно используются в сочетации с ЛВ
 *      - myShapesCollection.stream().filter(e -> e.getColor() == Color.RED)
 *      .forEach(e -> System.out.println(e.getName()));
 *      - разница между новыми агрегатными операциями и существующими балковыми методами (containsAll,
 *      addAll, removeAll), то что старые меняют коллекцию
 * - 2. for-each
 *      - for (Object o : collection) System.out.println(o);
 *      - только чтение
 * - 3. итераторы
 *      - это объект, позволяющий проходить по колекции и выборочно удалять элементы, если нужно
 *      - методы интерфейса итератора
 *          boolean hasNext();
 *          E next();
 *          void remove(); //optional, может вызываться только 1 раз за итерацию
 *      - используется вместо форич, если нужно:
 *          - удалить текущий элемент
 *          - итерировать несколько коллекций параллельно
 *          - например:
 *          static void filter(Collection<?> c) {
    for (Iterator<?> it = c.iterator(); it.hasNext(); )
        if (!cond(it.next()))
            it.remove();
}
 *
 * */

/*ITERATOR
 * - объект, обеспечивающий перемещение по последовательности объектов с выбором каждого объекта
 * этой последовательности
 * - создание не должно занимать много ресурсов
 * - является паттерном проектирования
 * - можно выполнять следующие операции:
 *      - iterator() - запросить итератор у Collector. Итератор готов вернуть начальный элемент
 *      последовательности
 *
 * - методы:
 *      - next() - получить следующий элемент последовательности
 *      - hasNext() - проверить, есть ли еще объекты в последовательности
 *      - remove() - удалить из последовательности последний элемент, возвращенный итератором
 *          - не обязателен для имплементации
 *
 * - унифицируют доступ к контейнерам
 *      - т.е. тип не важен
 *
 * - может перемещаться только вперед
 * */


/*ITERABLE и FOREACH
 * - использовать, если просто перемещаться по списку, без изменения элементов
 * - Iterable содержит метод iterator() для получения объекта Iterator
 * - интерфейс используется foreach для перемещения по списку
 *      - т.е. любой класс, который реализует этот интерфейс может использоваться форичем
 * - реализуется любой Collection, но не Map
 * - команда форич работает с массивом или любой другой реализацией итерабл но это не означает, что
 * массив автоматически реализует итерабл и не подразумевает автоматической упаковки
 *      - т.е. нельзя передать массив вместо итерабл
 *          - нужно сначала его вручную преобразовать в лист
 *              - напр. при помощи Arrays.asList()
 *          - но при этом он все равно работает с форичем
 *
 * - при помощи "метода-адаптера" можно добавить другое поведение команды форич
 *      - напр. также листать в обратную сторону
 *      - если просто переопределить iterator(), то поведение просто заменится на другое
 *      - нужен метод, который будет создать интерфейс Iterable с нужным поведением
 *
 * */


/* iterable - простое представление серии элементов, по которым можно пройтись. нет состояния
 * итерации такой как "текущий элемент",а есть единственный метод, который создает итератор
 *
 * iterator - объект с состоянием итерации. позволяет проверять, есть ли элемент и т.д
 * */

/* COMPARABLE, NATURAL ORDERING, COMPARATOR
 * - натуральный порядок, т.е. как мы привыкли
 * - Collections.sort(l) автоматически сортирует листы в натуральном порядке, если классы
 * имплементируют Comparable
 * - основные классы, которые имплементируют Comparable:Byte, Character, Long, Integer, Short,
 * Double, Float, BigInteger, BigDecimal, Boolean, File, String, Date, Chronological, CollationKey
 *      - никакой из этих классов не позволяет межклассовое сравнение
 * - ClassCastException, если класс не имплементит Comparable, или если сортируется лист, чьи
 * элементы нельзя сравнивать при помощи предоставленного компаратора ()
 * - интерфейс Comparable:
 *      - int compareTo(T o); вернет -1, 0, 1
 * - компаратор используется, если нужно сортировать в ненатуральном порядке или объекты, которые не
 * имплементируют Comparable.
 *      - Comparator это интерфейс с 1 методом int compare(T o1, T o2); // ведет себя как и compareTo
 *      - объект Comparator инкапсулирует порядок
 * */


/* =======================================ИЕРАРХИЯ======================================= */
/* ИЕРАРХИЯ КОЛЛЕКЦИЙ (ОБЩЕГО НАЗНАёЧЕНИЯ)
 * - <<Collection>>: группа элементов
 *      - <<List>>: последовательная группа элементов - обращение к элементам по индексу, контроль
 *      места вставки
 *          - LinkedList: [Doubly-Linked List], <<Deque>>
 *          - ArrayList: [Array], можно менять размер
 *
 *      - <<Set>>: группа элементов без дубликатов
 *          - <<SortedSet>>: упорядоченная группа (натуральный порядок или компаратор)
 *              - TreeSet: [Red-Black Tree]
 *          - HashSet: [Hash table], неупорядочена
 *              - LinkedHashSet: [Hash Table], [Doubly-Linked List], порядок как добавлялось
 *          - EnumSet: [Bit Vector]
 *
 *      - <<Queue>>: 1-сторонняя очередь (обычно FIFO), перед обработкой, элемента должен быть добавлен
 *          - PriorityQueue: [Priority (Binary) Heap], (натуральный порядок или компаратор)
 *          - <<Deque>>: двусторонняя очередь (FIFO, LIFO)
 *              - LinkedList
 *
 * - <<Map>>: связь ключ-значение; не может иметь дубликатов ключей; 1 ключ связан только с 1 значением
 *      - <<SortedMap>>: упорядоченная мапа (натуральный порядок ключей или компаратор)
 *              - <<NavigableMap>>: методы навигации к ближайшему совпадению
 *                  - TreeMap: [Red-Black Tree]
 *      - HashMap: [Hash table], неупорядочена
 *          - LinkedHashMap: [Hash Table], [Doubly-Linked List], порядок как добавлялось
 *      - EnumMap: [Array] */


/* ДОПОЛНИТЕЛЬНЫЕ КЛАССЫ\ИНТЕРФЕЙСЫ
 * - <<AbstractCollection>>: дефолтная имплементация коллекции
 *
 * - <<Iterator>>: итератор по коллекции
 *      - <<ListIterator>>: итератор по списку в обе стороны, с возможностью внесения изменений и
 *      получения текущей позиции курсора
 *
 * - <<Comparable>>: имплементирующий объект можно сравнивать с другим такого же типа
 *
 * - <<Comparator>>: описывает порядок объектов в коллекции
 *
 * - Collections:
 *
 * - Arrays:
 *
 * */


/* ====================================ИНТЕРФЕЙСЫ/ИМПЛЕМЕНТАЦИИ==================================== */
/* COLLECTION
 * - public interface Collection<E> extends Iterable<E>
 * - представляет группу объектов (элементов)
 * - коренной интерфейс в иерархии коллекций
 *      - удобно использовать как генерализированную коллекцию при манипуляциях
 *      - принимается всеми имплементациями в конструктор
 *          - т.е. для конвертации коллекций
 * - не имплементируется напрямую какими-либо коллекциями
 *      - только, разве что, AbstractCollection
 * - методы:
 *      - базовые:
 *          - size: размер коллекции
 *          - isEmpty: проверка на пустоту
 *          - contains: поиск элемента
 *          - add: гарантия добавления элемента; вернет результат добавления
 *          - remove: удаление элемента
 *          - iterator: позволяет итерировать по коллекции
 *      - манипулирование целой коллекцией:
 *          - containsAll: поиск данной коллекции элементов
 *          - addAll: добавление данной коллекции
 *          - removeAll: удаление данной коллекции
 *          - retainAll: удаление всего, кроме данной коллекции
 *          - clear: удаление всего
 *      - операции с массивами
 *          - toArray: перевод коллекции в массив типа Object
 *          - toArray(T[] a): перевод коллекции в массив указанного типа
 *      - стримовые (с J8)
 *          - stream: перевод коллекции в стрим
 *          - parallelStream: перевод коллекции в, возможно, параллельный стрим */


/* LIST
 * - последовательная группа элементов
 *      - например, список покупок
 *
 * - дополнительные методы:
 *      - позиционного доступа: манипуляция элементами по их числовой позиции в списке:
 *          - get, set, add, addAll, remove (удаляет первый совпадающий элемент)
 *      - поиска: поиск указанного объекта в списке и возвращение его позиции:
 *          - indexOf, lastIndexOf
 *      - итерации: расширяет семантику Iterator для работы со списком
 *          - listIterator
 *              - расширяет итератор
 *              - итерация в обе стороны: + previous, hasPrevious
 *              - изменения листа в текущей позиции: add
 *              - получение текущей позиции итератора: index
 *              - возможность получить итератор с нужной позиции
 *      - просмотр диапазона: диапазонные операции над списком:
 *          - sublist (изменения в оригинале отражаются в диапазоне)
 *
 * - итераторы являются fail-fast
 *      - при изменении коллекции после получения иторатора не его методами (remove, add)
 *      выбрасывается ConcurrentModificationException
 *          - не является гарантированным (нельзя основывать на этом логику)
 *
 * - большинство алгоритмов Collections применяются специально к List
 *      - sort: сортировка листа при помощи MergeSort - быстрая и стабильная (не меняет порядок
 *      равных элементов)
 *      - shuffle: рандомно переставляет элементы в листе
 *      - reverse: обращает порядок элементов в списке
 *      - rotate: двигает по кругу элементы на указанную дистанцию
 *      - swap: меняет местами элементы на указанных позициях
 *      - replaceAll: меняет все встречи одного значения на указанное
 *      - fill: переписывает каждый элемент в списке указанным значением
 *      - copy: копирует лист источник в лист цель
 *      - binarySearch: ищет элементы в упорядоченном листе при помощи Binary Search
 *      - indexOfSubList: возвращает индекс первого подлиста одного листа, который равен другому
 *      - lastIndexOfSubList: возвращает индекс последнего подлиста одного листа, который равен другому
 *
 * - реализации:
 *      - общего назначения:
 *          - ArrayList:
 *              - предпочтительней
 *              - основан на Array
 *              - можно менять размер массива
 *              - допускаются дубликаты и null элементы
 *              - скорость:
 *                  - add: O(1) (константное амортизированное время, т.е. O(n)+)
 *                      - т.е. среднее время, если операция повторяется многократно
 *                          - напр. из-за периодического увеличения массива
 *                  - remove: O(n)
 *                  - get: O(1)
 *                  - contains: O(n)
 *                  - next: O(1)
 *
 *          - LinkedList:
 *              - перед использованием, сравнить перформанс с ArrayList
 *              - основан на Doubly-Linked List
 *              - также имплементирует <<Deque>>
 *                  - т.е. есть методы очереди
 *              - допускаются дубликаты и null элементы
 *              - доступ к элементу с начала или конца (зависит от того, что ближе)
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - get: O(n)
 *                  - contains: O(n)
 *                  - next: O(1)
 *
 *      - специального:
 *          - CopyOnWriteArrayList:
 *              - основан на Array
 *              - потокобезопасен: все операции изменения проводятся после создания копии массива
 *                  - т.е. не нужен лок, и даже можно итерировать многопоточно
 *              - подходит только для списков, которые редко меняются, но часто итерируются
 *              - скорость:
 *                  - add: O(n)
 *                  - remove: O(n)
 *                  - get: O(1)
 *                  - contains: O(n)
 *                  - next: O(1)
 *
 * - для большинства имплементаций общего назначения скорость удаления элементов с конца выше
 * удаления с начала */


/* SET
 * - набор элементов без дубликатов
 *      - например, колода карт
 *
 * - меняют поведение Collection, а не добавляет новое
 *      - в отличие от, например, List
 *
 * - содержит только методы Collection
 *
 * - реализации:
 *      - общего назначения:
 *          - HashSet
 *              - основан на Hash table
 *              - нет гарантии порядка
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - contains: O(1)
 *                  - next: O(h/n)
 *                  - size: O(1)
 *
 *          - LinkedHashSet
 *              - наследует HashSet
 *              - основан на Hash Table + Linked List
 *              - порядок, в котором добавлялись элементы
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - contains: O(1)
 *                  - next: O(1)
 *                  - size: O(1)
 *
 *      - специального:
 *          - EnumSet
 *              - основан на Bit Vector
 *              - высокоскоростная имплементация для Enum одного типа
 *              - типобезопасен, в отличие от битовых флагов на основе int
 *              - итератор:
 *                  - на основе natural order
 *                      - т.е. порядок создания констант
 *                  - является weakly consistent
 *                      - не выбрасывает ConcurrentModificationException
 *                      - может проявлять эффекты изменения коллекции после создания итератора
 *              - не допускает null элементы
 *              - скорость:
 *                  - add: O(1)
 *                  - remove: O(1)
 *                  - contains: O(1)
 *                  - next: O(1)
 *                  - size: O(1)
 *
 *          - CopyOnWriteArraySet:
 *              - основан на Array
 *              - потокобезопасен: все операции изменения проводятся после создания копии массива
 *                  - т.е. не нужен лок, и даже можно итерировать многопоточно
 *              - подходит только для наборов, которые редко меняются, но часто итерируются
 *              - скорость:
 *                  - add: O(n)
 *                  - remove: O(n)
 *                  - contains: O(n)
 *                  - next: O(1)
 *                  - size: O(1)
 *
 * - интерфейсы-наследники:
 *      - SortedSet: упорядоченный набор (натуральный порядок или компаратор)
 *          - например, список слов
 *      - методы:
 *          - те же, что и Set, но:
 *               - iterator вернет итератор, перебирающий по порядку
 *               - toArray вернет упорядоченный массив
 *          - дополнительные:
 *              - конечные точки: first, last
 *                  - вернет первый или последний элемент из набора
 *              - просмотр диапазона: subSet, headSet (от начала до элемента), tailSet (от элемента
 *              до конца)
 *                  - в отличие от List, диапазон остается валидным даже при изменении оригинала
 *                      - т.к. конечные точки являются абсолютными
 *                  - изменения в оригинале и в куске отражаются друг в друге
 *              - доступ к компаратору: comparator
 *                  - вернет компаратор, если он использовался в наборе
 *
 *      - интерфейсы-наследники:
 *          - NavigableSet: упорядоченный набор с навигационными методами (по первому совпадению)
 *              - возможность итерировать/просматривать набор в возрастающем и спадающем порядке
 *                  - операции с возрастающим могут быть быстрее
 *              - дополнительные методы:
 *                  - возрват элементов при помощи сравнения: lower, floor, ceiling, higher
 *                  - удаление первого/последнего элемента: pollFirst, pollLas
 *
 *              - реализации (общего назначения):
 *                  - TreeSet
 *                      - основан на Red-black Tree
 *                      - fail-fast итератор
 *                      - скорость:
 *                          - add: O(log n)
 *                          - remove: O(log n)
 *                          - contains: O(log n)
 *                          - next: O(log n)
 *                          - size: O(1) */


/* QUEUE
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 *      - у каждого из методов 2 формы: одна выбрасывает исключение при неуспехе операции, вторая
 *      возвращает специальное значение при неуспехе (либо null либо false)
 *      - вставка:
 *          - add(e) - выкидывает исключение (в случае отсутствия места в ограниченной очереди)
 *          - offer(e) - возвращает значение (в случае отсутствия места в ограниченной очереди)
 *      - удаление:
 *          - remove() - выкидывает исключение (если нет элементов)
 *          - poll() - возвращает значение (если нет элементов)
 *      - просмотр:
 *          - element() - выкидывает исключение (если нет элементов)
 *          - peek() - возвращает значение (если нет элементов)
 *
 * - обычно (но не обязятельно) упорядочивает элементы как FIFO
 *      - среди исключений приоритетные очереди, упорядывающие элементы в соответствии с
 *      предоставленным компаратором или натуральным порядком элементов
 *          - при использовании порядка, операциями remove или poll первым будет доставаться head
 *      - каждая очередь должна указывать свои свойства упорядочивания
 *
 * - некоторые имплементации из java.util.concurrent можно ограничивать, но никакие из java.util
 *
 * - обычно не позволяют вставлять null элементы
 *      - исключение LinkedList, но все равно не рекомендуется
 *
 * - Queue implementations generally do not define element-based versions of the equals and hashCode
 * methods but instead inherit the identity-based versions from Object.
 *
 * - java.util.concurrent.BlockingQueue расширяет Queue и добавляет методы ожидания появляения
 * элемента/места
 * */

/* ИМПЛЕМЕНТАЦИИ QUEUE
 * - общего назначения:
 *      - LinkedList
 *          - FIFO операции для add, poll и т.д.
 *      - PriorityQueue
 *          - основан на heap структуре данных
 *          - упорядывачивает элементы на основе указаного при создании порядка
 *              - природный порядок или компаратор
 *          - poll, remove, peek, и element достают элемент из начала очереди
 *          - имплементит все опциональные методы инт-сов коллекции и итератор
 *          - итератор не гарантирует перебор в каком-то определенном порядке
 *              - для порядочного перебора расмотри Arrays.sort(pq.toArray())
 *
 * - многопоточного:
 *      - есть набор синхронизированный интерфейсов и классов Queue
 *      - BlockingQueue расширяет очередь операциями ожидания пока очередь не станет непустой при
 *      получении элемента или когда появится свободное место при добавлении
 *          - имплементации:
 *              - LinkedBlockingQueue: опционально ограниченная FIFO блокируюшая queue на основе
 *             linked nodes
 *              - ArrayBlockingQueue: ограниченная FIFO blocking queue на основе массива
 *              - PriorityBlockingQueue: неограниченная blocking priority queue на основе heap
 *              - DelayQueue: a time-based scheduling queue backed by a heap
 *              - SynchronousQueue: простой рандеву механизм, кот использует инт-с BlockingQueue
 *      - TransferQueue расширяет BlockingQueue, чтобы код, кот. добавляет элемент имел выбор
 *      ожидать пока другая ветка получит элемент
 *          - имплементация:
 *              - LinkedTransferQueue — не ограниченная TransferQueue на основе linked nodes
 * */


/* QUEUE
 * - первым пришел первым ушел
 * - для надежного перемещения объектов из одной области в другую
 * - играют важную роль в пареллельном программировании
 * - LinkedList реализует очередь
 * - offer() - добавить элемент в конец или вернуть false(why?)
 * - peek(), element() - вернуть элемент в начале очереди без удаления. peek - возвращает null для
 * пустой очереди, а element - noSuchElementException
 * - poll(), remove() извлекают элемент в начале и возвращают его, но пол возвращает нал для пустой
 * очереди, а ремув - но сач эл
 * - методы специфические для очереди предоставляют полную и законченную функциональность. Т.е. вы
 * получаете работоспособную очередь без испольлзования методов Collection, от которого наследует очередь
 * */

/* PRIORITYQUEUE
 *  - следующим извлекается элемент обладающий наивысшим приоритетом
 *  - работает с Integer, String, Character
 *  - для своих классов можно использовать свой Comparator
 * */

/* ИМПЛЕМЕНТАЦИИ DEQUE
 * - общего назначения:
 *      - ArrayDeque:
 *          - на основе способного менять размер массива
 *          - быстрее для операций добавки и удаления
 *      - LinkedList
 *          - на основе листа
 *          - более гибкий чем аррай
 *              - имплементит все опциональные операции
 *              - можно добавлять нал null
 *          - наиб подходящая операция - удалять элемент при итерации
 *          - потребляет больше памяти
 *
 * - многопоточного:
 *      - LinkedBlockingDeque
 *          - если очередь пуста то методы ждут появления элементов перед работой над ним
 * */

/* DEQUE (DOUBLE-ENDED QUEUE)
 * - используется для удержания множественных элементов до их обработки
 * - помимо базовых операций Collection, также предлагает дополнительные операции вставки, получения,
 * и изучения
 * - может использоваться как FIFO и LIFO
 *      - т.е. все элементы можно вставить/получить из любого из концов
 *      - т.е. имплементирует и Queue и Stack
 * - реализации:  ArrayDeque и LinkedList
 * - методы:
 *      - вставка:
 *          - в начало:
 *              - addfirst (выбрасывает исключение)
 *              - offerFirst (возвращает значение)
 *          - в конец:
 *              - addLast (выбрасывает исключение)
 *             - offerLast (возвращает значение)
 *      - удаление:
 *          - removeFirst(), pollFirst()
 *          - removeLast(), pollLast()
 *      - иследование:
 *          - getFirst(), peekFirst()
 *          - getLast(), peekLast()
 *
 * - также есть дополнительные методы:
 *      - removeFirstOccurence, removeLastOccurence - удаляет первую/последнюю встречу элемента,
 *      если он есть
 * */


/* MAP
 * - мапит ключи и значения
 * - не может содержать дубликатов ключей
 *      - каждый ключ замаплен максимум на одно значение
 * - моделирует математическую абстракцию функции
 * - базовые методы:
 * put, get, remove, containsKey, containsValue, size, and empty
 * - балковые методы: putAll, clear
 * - просмотр мапы как коллекции (единственный способ итерации по мапе):
 *      - keySet - набор ключей
 *          - for (KeyType key : m.keySet()) System.out.println(key);
 *     - values - коллекция значений (не набор, т.к. могут быть повторения)
 *     - entrySet - набор пар ключей-значений, содержащихся в мапе. У интерфейса мап есть вложенный
 *     интерфейс Map.Entry, тип элементов в данном наборе
 *          - у Map.Entry также есть метод setValue - можно менять значение
 *              - это единственный способ безопасно менять мапу при итерации
 *     - для ускорения, всегда возвращаются те же объекты, а не создаются новые
 * - имплементации:
 *      - HashMap
 *          - LinkedHashMap
 *      - TreeMap
 * - скорость действия аналогично имплементациям сетов
 * -  как и Set и List ужесточает требования для equals и hashCode, чтобы можно было сравнить 2 мапы
 * вне зависимости от имплементаций
 *      - 2 мапы равны, если представляют тот же мапинг ключей-значений
 * - по договоренности есть конструкторы, принимающие другие мапы
 * - если у одного ключа должно быть несколько значени (multimap), то можно использовать List для
 * хранения этих значений
 * */


/* SORTEDMAP
 * - Map, который сохраняет элементы в возрастающем порядке в соответствии с натуральным порядком
 * ключей или в соответствии с предоставленным компаратором во время создания
 * - используются для природно упорядоченных Map
 *      - например, словари и телефонные справочники
 * - методы, унаследованные от мапы, ведут себя аналогично, за исключением:
 *      - итератор, возвращаемый iterator, перебирает набор по порядку
 *      - массив, возвращаемый toArray, возвращает упорядоченный массив ключей, значений или записей
 * - есть дополнительные операции для удобства пользования порядком
 *      - просмотр диапазона - разные диапазонноые операции
 *          - похожи на аналогичные у листа с 1 большой разницей - диапазон здесь остается валидным
 *          даже при изменении напрямую оригинального сета, т.к. конечные точки являются абсолютными
 *          в просртанстве элементов, а не конкретных элементов в оригинальной коллекции, как у листа
 *              - изменения в оригинале и в куске отражаются друг в друге, поэтому можно долго юзать
 *              диапазон
 *          SortedSet<E> subSet(E fromElement, E toElement);
 *          SortedSet<E> headSet(E toElement); // от начала и до элемента
 *          SortedSet<E> tailSet(E fromElement); // от элемента и до конца
 *      - конечные точки - вернет первый или последний элемент из сортированного набора
 *          E first();
 *          E last();
 *      - доступ к компаратору - вернет компаратор, если таковой использовался в наборе
 *          Comparator<? super E> comparator();
 * */




/* ИМПЛЕМЕНТАЦИИ ОБЩЕГО НАЗНАЧЕНИЯ
 * - Hash table:
 *      - HashSet*
 *      - HashMap*
 * - Resizable array:
 *      - ArrayList*
 *      - ArrayDeque*
 * - Tree:
 *      - TreeSet, SortedSet
 *      - TreeMap, SortedMap
 * - Linked list:
 *      - LinkedList (List)
 *      - LinkedList (Deque)
 * - Hash table + Linked list
 *      - LinkedHashSet
 *      - LinkedHashMap
 *
 * - у Queue 2 общих имплементации:
 *      - LinkedList*: FIFO семантика
 *      - PriorityQueue: порядок в зависимости от значений
 *
 * - все общие имплементации:
 *      - допускают null elements, keys, and values
 *      - не синхронизированы
 *      - имеют fail-fast итераторы
 *          - определяют illegal concurrent изменение во время итерации и быстро и чисто падают,
 *          чтобы избежать непоняток
 *      - все Serializable
 *      - все поддерживают метод clone
 *
 * * - наиболее используемая
 * */







/* ИМПЛЕМЕНТАЦИИ МАР
 * - общего:
 *      - HashMap
 *          - максимальная скорость, но нет порядка итерации
 *      - TreeMap
 *          - когда нужен сортированный
 *      - LinkedHashMap
 *          - нечто среднее
 *              - аналогично с сетом
 *                  - но также:
 *                      - его можно создавать на основе key access а не вставки
 *                          - т.е. просмотр по ключу, сдвигает пару в конец мапы
 *                      - метод removeEldestEntry, чтобы при добавлении новой пары удалять самую
 *                      старую пару
 *                          - удобно для кастомного кеша
 *
 * - специального:
 *      - EnumMap
 *          - высокоскоростной (на массиве) для енумов
 *          - лучше, чем просто аррей, когда нужно мапить значения с енумами
 *      - WeakHashMap
 *          - хранит только слабые ссылки на свои ключи
 *              - т.е. сборщик мусора может удалить пару, если на ключ больше нигде снаружи не
 *              ссылаются
 *              - полезен для "регистровый" стуктрур данных
 *      - IdentityHashMap
 *          - быстрое и имеет специфические особенности, типа:
 *            - topology-preserving object graph transformations, т.е. сериализация или глубокое копирование и т.д
 *
 * - многопоточного:
 *      - интерфейс ConcurrentMap расширяет Map
 *          - атомические методы: putIfAbsent, remove, and replace
 *          - имплементация: ConcurrentHashMap
 *              - высокоскоростная
 * */





/* WRAPPER ИМПЛЕМЕНТАЦИИ
 * - на основе декоратора
 * - имплементации анонимны - создаются от фабричного стат метода в Collections
 * - синхронизационные:
 *      - методы public static <T> ...<T> synchronized...(...<T> c);
 *      - итерировать по коллекции нужно атомически:
 *          - synchronized(c) {for (Type e : c)foo(e);}
 *      - 1 минус - нельзя использовать неинтерфейсные методы обернутой имплементации
 *
 * - неизменяемые:
 *      - убирают возможность изменять элементы
 *          - перехватывают команды и выбрасывают исключение UnsupportedOperationException
 *      - используются:
 *          - сделать коллекцию неизменяемое при создании
 *              - желательно не сохранять линк на оригинал
 *          - позволить определенным клиентам только чтение
 *      - методы public static <T> ...<T> unmodifiable...(...<? extends T> c);
 *
 * - Checked Interface:
 *      - инт-с Collections.checked
 *      - для использования с обобщениями
 *          - вернут ДИНАМИЧЕСКИ (а не компиляторный, как у генериков) типо-безопасный view
 *          указанной коллекции, которая выкинет
 *          ClassCastException, если клиент пытается добавить элемент не того типа
 * */

/* ИМПЛЕМЕНТАЦИИ УДОБСТВА
 * - List view для массива:
 *      - Arrays.asList - вернет лист-вью массива в аргументе
 *          - изменения в одном приводят к изменнеиям в другом
 *          - размер листа нельзя менять
 *              - выкенет UnsupportedOperationException
 *          - полезен не только как мост между массивом и листом, но еще и когда нужен лист
 *          фиксированного размера, т.к. он быстрее имплементации листа общего назначения
 *
 * - Неизменяемый лист с множеством копий 1 элемента
 *      - Collections.nCopies
 *      - например, если
 *          - нужно инициализировать лист, который изначально состоит только из null
 *              - List<Type> list = new ArrayList<Type>(Collections.nCopies(1000, (Type)null);
 *          - нужно расширить текущий лист (в т.ч. вставить в середину)
 *              - lovablePets.addAll(Collections.nCopies(69, "fruit bat"));
 *
 * - Неизменяемый набор синглтонов
 *      - Collections.singleton
 *      - например, если
 *          - нужно удалить все повторы указанного элемента из коллекции
 *              c.removeAll(Collections.singleton(e));
 *          - нужно удалить все значения для определенного ключа
 *              job.values().removeAll(Collections.singleton(LAWYER));
 *          - нужно предоставить единичное входное значение для метода, который расчитан на прием
 *          коллекции значений
 *
 * - Константы с пустыми Set, List, и Map
 *      - Collections.empty...
 *          - например нужно в метод, который принимает коллекцию
 *          tourist.declarePurchases(Collections.emptySet())
 * */


/* ПОЛИМОРФНЫЕ АЛГОРИТМЫ COLLECTIONS
 * - (большинство для List, но есть и для любых)
 * - сортировка: sort
 *      - для листа
 *      - либо сортирует лист по возрастанию в натуратольном порядке, либо принимает компаратор
 *      - на основе немного оптимизированного merge sort
 *          - быстро: log(n)
 *          - стабильно: не меняет порядок равных элементов. Т.е. если я сортирую письма по дате, а
 *          потом по отправителю, то я ожидаю, что порядок по дате сохраниться. Это обеспечивает
 *          стабильность.
 *
 * - shuffling: shuffle
 *      - для листа
 *      - либо использует дефолтный источник рандомизации либо принимает объект Random
 *
 * - рутинные операции с данными
 *      - reverse - обращает порядок элементов в списке.
 *      - fill - перезаписывает каждый элемент в списке с указанным значением.
 *          - полезно для повторной инициализации списка
 *      - copy - копирует 1 лист на другой, перезаписывая элементы.
 *      - swap - поменять местами элементы в листе.
 *      - addAll - добавляет все элементы в коллекцию
 *
 * - поиск: binarySearch
 *      - для листа
 *      - либо принимает лист и элемент, который ищется (ключ)
 *          - ожидается, что лист сортирован в возрастающем натуральном порядке
 *              - т.е. сначала нужно сделать сортировку sort
 *      - либо принимает также Comparator
 *      - вернет индекс элемента, если есть, или отрицательное число, если нет (там корявая формула)
 *
 * - композиция: frequency, disjoint
 *      - frequency - сколько раз указанный элемент встречается в коллекции
 *      - disjoint - определяет, являются ли две коллекции непересекающимися
 *          - то есть не содержат общих элементов
 *
 * - поиск минимальных и максимальных значений: min, max
 *      - либо вернет по натуральному порядку
 *      - либо по указанному компаратору */




@Ntrstn("при имплементации своей коллекции удобней просто возвращать итератор, вместо наследования " +
        "от абстрактколлеции")

@Ntrstn("Нужно пользоваться где только возможно интерфейсом Collection, а не спец методами имплементаций")
@Ntrstn("Arrays.asList - методы add, remove не работают, т.к. массивы не меняются, т.е. " +
        "получается нестрандартная имплементация листа")
@Ntrstn("Важно помнить, что фор ич не позволяет менять элементы, поэтому используется итератор ")
@Ntrstn("Фреймворк коллекций - это удобный способ манипулирования определенной кучей объектов")

@Ntrstn("Правильней называть коллекциями, только то, что относится к интерфейсу Collection (т.е. НЕ " +
        "Map), а вот все вместе - контейнерами")
@Ntrstn("Массив обеспечивает самый эффективный способ хранения групп объектов и является первым " +
        "кандидатом при хранении группы примитивов. Однако массив имеет фиксированный размер.")

@Ntrstn("До Java 5 в экземпляры контейнеров можно было добавлять любые типы, но с появлением " +
        "обобщений появились версии классов-контейнеров, использующих ограничение типов")

@Ntrstn("Метод add() в Collection не обязательно добавляет элемент (как в случае дубликата в Set), " +
        "а лишь гарантирует, что такой элемент будет в контейнере")

@Ntrstn("Для добавления групп элементов существуют специальные методы для удобства. Arrays.asList() " +
        "- принимает список элементов через запятую и возвращает контейнер List с ними. Но " +
        "Arrays.asList() создает List, в который нельзя добавлять или удалять элементы в рантайме, " +
        "иначе возникнет UnsupportedOperationException." +
        "Collections.addAll() - добавляет в указанную коллекцию указанные элементы (могут идти как " +
        "через запятую, так и массиве). В отличие от Collections.addAll() метод Collection.addAll() " +
        "может в качестве аргумента получать только другой объект Collection, поэтому он менее удобен")

@Ntrstn("Для печати содержимого контейнера не нужен специальный метод, в отличие от массива")

public class Main2 {

    public static void main(String[] args) {
        String[] s = {"dfs", "dfs", "dfd"};
        List<String> l = Arrays.asList(s);
        ListIterator<String> it = l.listIterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }

    }
}
