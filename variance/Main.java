package variance;

import java.util.ArrayList;

import types_references_annotations.my_annotations.Ntrstn;

/* ВАРИАНТНОСТЬ
 * - определяет, какие другие типы можно передавать в место, где требуется определенный тип
 *      - перед передачей происходит неявное преобразование */


/* ИНВАРИАНТНОСТЬ
 * - в место, где требуется определенный тип, можно передать только этот тип
 *      - полезна для типобезопасности
 *          - т.е. туда, точно нельзя передать несовместимый тип
 *              - в т.ч. тот, который выше по иерархии
 *
 * - аргумент в переопределяемом методе:
 *      void meth(Number n) {}...
 *      @Override
 *      void meth(Number n) {}
 *      - перегрузка:
 *          void meth(Integer n) {}
 *          - т.к. сигнатуры больше не совпадают
 *
 * - экземпляры обобщений:
 *      ArrayList<Integer> a = new ArrayList<Integer>();
 *      - иначе объект ArrayList<Integer> можно назначить ссылке ArrayList<Number>, а затем добавить
 *      элемент Number, что приведет загрязнению кучи, которое JVM не может отслеживать
 *          - т.к. типы стерты во время работы программы */


/* КОВАРИАНТНОСТЬ
 * - в место, где требуется определенный тип, можно также передать всех его наследников
 *
 * - присваивание:
 *      Clazz c = new SubClazz();
 *
 * - передаваемый аргумент в метод (не переопределяемый):
 *      void takeAny (Object o){ }
 *      takeAny(new Integer(1));
 *
 * - возвращаемый тип из метода (в т.ч. переопреляемого):
 *      Object returnNumber (){ return new Integer () ; }
 *      - переопределение:
 *          Number returnNumber (){ return new Double (1.1); } // корректное переопределение
 *
 * - массивы:
 *      - элементы массива:
 *          Clazz[] c = new Clazz[1];
 *          c[0] = new SubClazz();
 *      - сами массивы:
 *          Clazz [] c = new Subclazz[];
 *          - в массив теперь можно добавить любой элемент-наследник родительского класса
 *              - чтобы избежать загрязнения кучи, JVM запоминает реальный тип объекта массива, и
 *              при попытке в него добавить некорректный элемент, выбрасывает исключение
 *              ArrayStoreException
 *      - массивы должны были быть ковариантными (по крайней мере до появления обобщений), т.к. при
 *      использовании библиотечного метода, который принимает Object[], не смог бы принимать String[]
 *          - т.е. требовалось бы сначала скопировать содержание String[] в новый массив Object[]
 *
 * - параметр типа при создании экземпляра обобщенного кода с верхней границей
 *      class Clazz <T extends Number> {}...
 *      Clazz <Integer> c1 = new Clazz <>();
 *
 * - аргумент типа у экземпляра обобщенного кода, где известна только верхняя граница
 *      ArrayList<? extends Number> a1 = new ArrayList<Integer>(); */


/* КОНТРАВАРИАНТНОСТЬ
 * - в место, где требуется определенный тип, можно также передать всех его родителей
 *
 * - аргумент типа у экземпляра обобщенного кода, где известна только нижняя граница
 *      ArrayList<? super Number> a1 = new ArrayList<Object>();*/


@Ntrstn("Вариантность определяет семейство типов, которые можно передать место, где требуется тип. " +
        "Ковариантность значит, что передать можно указанный тип и его подтипы. Контравариантность " +
        "значит передать можно указанный тип и его родителей. Инвариантность значит, что передать " +
        "можно только указанный тип")

@Ntrstn("Инвариантность полезна для обеспечения безопасности типов и избежания ошибок приведения, но " +
        "исключает возможность работы с целым семейством типов. Инвариантными в Java считаются " +
        "аргументы методов при их переопределении (иначе сигнатура не будет совпадать и это будет " +
        "просто перегрузка), а также экземпляры обобщенных типов (иначе обобщенный экземпляр можно " +
        "было бы назначить ссылке родительского типа и добавить в этот экземляр элемент " +
        "родительского типа, что является не типобезопасным (у родительского типа нет всех методов, " +
        "которые требуются наследникам - т.е. downcast) и приводило бы к загрязнению кучи, т.к. к " +
        "моменту работы программы информация о типе стерта и JVM не способна выкинуть исключение, " +
        "когда по ссылке на объект-наследник находится родительский объект")

@Ntrstn("Ковариантность встречается во многих местах: при назначении объекта-наследника родительской " +
        "ссылке, при передаче аргумента в метод (не переопределяемый), при возвращении объекта из " +
        "метода (в т.ч. переопределяемого), при указании параметра типа при создании экземпляра " +
        "обобщенного типа и при указании аргумента типа у экземпляра обобщенного кода, где известна " +
        "только верхняя граница (ограниченный метасимвол). Кроме того, массивы также являются " +
        "ковариантными: по типу добавляемого элемента (можно добавить элемент типа наследника в " +
        "в массив по родительской ссылке) и по типу самого массива (можно назначить массив типа " +
        "наследника родительской ссылке). Это было необходимо до появления обобщений, когда методы " +
        "принимали Object[] - во-первых иначе туда нельзя было бы передать массив типа наследника, а " +
        "во-вторых перед работой с элементами их пришлось бы все копировать в новый массив типа " +
        "Object[]. Но т.к. коварантность у массивов позволяет назначить родительской ссылке массив-" +
        "наследник, а после этого добавить в него родительский элемент, чтобы избежать загрязнения " +
        "кучи JVM удерживает информацию о реальном типе массива по ссылке и при некорректном " +
        "добавлении выбрасывает ArrayStoreException")

@Ntrstn("Контравариантность встречается только в 1 месте - при указании аргумента типа у экземпляра " +
        "обобщенного кода, где известна только нижняя граница (ограниченный метасимвол). Т.е. ссылке " +
        "на обобщенный код, где указана нижняя граница, можно назначить иерархически совместимый " +
        "экземпляр обобщенного кода с любым параметром, если он соответствует указанной границе")


public class Main {
    /* ~~~~~~~~~~~~~~~~~~~ИНВАРИАНТНОСТЬ~~~~~~~~~~~~~~~~~~~*/
    class Invariance {
        /* АРГУМЕНТ В ПЕРЕОПРЕДЕЛЯЕМОМ МЕТОДЕ */
        void meth(Number n) {
        }

        class InvarianceSon extends Invariance {
            @Override
            void meth(Number n) {
            }

            // @Override
            void meth(Integer n) { // простая перегрузка
            }
        }


        /* ЭКЗЕМПЛЯРЫ ОБОБЩЕНИЙ */
        void gen() {
            ArrayList<Number> a = new ArrayList<Number>();
//            ArrayList<Number> a1 = new ArrayList<Integer>();
//            ArrayList<Number> a2 = new ArrayList<Object>();
        }
    }


    /* ~~~~~~~~~~~~~~~~~~~КОВАРИАНТНОСТЬ~~~~~~~~~~~~~~~~~~~*/
    class Covariance {
        /* ПРИСВАИВАНИЕ */
        Number number = new Integer(1);


        /* АРГУМЕНТ МЕТОДА */
        void takeAny(Object o) {
            takeAny(new Integer(1));
        }


        /* ВОЗВРАЩАЕМЫЙ ТИП ИЗ МЕТОДА (В Т.Ч. ПЕРЕОПРЕДЕЛЯЕМОГО) */
        Object returnInteger() { // оригинальный метод
            return new Integer(1);
        }

        class CovarianceSon extends Covariance {
            @Override
            Number returnInteger() { // корректное переопределение
                return new Double(1.1);
            }
        }

        /* МАССИВЫ */
        void arrays(Object[] a) {
            /*ЭЛЕМЕНТЫ МАССИВОВ КОВАРИАНТНЫ */
            Number[] n = new Number[1];
            n[0] = new Integer(1);


            /* САМИ МАССИВЫ КОВАРИАНТНЫ */
            Object[] n2 = new Integer[1];
            n2[0] = new Object(); // JVM кинет ArrayStoreException, чтобы избежать загрязения кучи

            /* КОВАРИАНТНОСТЬ НЕОБХОДИМА, ЧТОБЫ ИЗБЕЖАТЬ КОПИРОВАНИЯ */
            arrays(new String[100]); // при инвариантности нужно скопировать все содержание в Object[]
        }


        /* ПАРАМЕТР ТИПА ПРИ СОЗДАНИИ ЭКЗЕМПЛЯРА ОБОБЩЕННОГО КОДА С ВЕРХНЕЙ ГРАНИЦЕЙ */
        class CovarienceGenericUpperLim<T extends Number> {
            void meth() {
                CovarienceGenericUpperLim<Number> c = new CovarienceGenericUpperLim<>();
                CovarienceGenericUpperLim<Integer> c1 = new CovarienceGenericUpperLim<>();
                CovarienceGenericUpperLim<Double> c2 = new CovarienceGenericUpperLim<>();
//                CovarienceGenericUpperLim<Object> c3 = new CovarienceGenericUpperLim<>();
            }
        }


        /* АРГУМЕНТЫ ТИПА У ЭКЗЕМПЛЯРА ОБОБЩЕННОГО КОДА, ГДЕ ИЗВЕСТНА ТОЛЬКО ВЕРХНЯЯ ГРАНИЦА*/
        void wild() {
            ArrayList<? extends Number> a = new ArrayList<Number>();
            ArrayList<? extends Number> a1 = new ArrayList<Integer>();
            ArrayList<? extends Number> a2 = new ArrayList<Double>();
//            ArrayList<? extends Number> a3 = new ArrayList<Object>();
        }
    }


    /* ~~~~~~~~~~~~~~~~~~~КОНТРАВАРИАНТНОСТЬ~~~~~~~~~~~~~~~~~~~*/
    class ContraVariance {
        /* АРГУМЕНТЫ ТИПА У ЭКЗЕМПЛЯРА ОБОБЩЕННОГО КОДА, ГДЕ ИЗВЕСТНА ТОЛЬКО НИЖНЯЯ ГРАНИЦА*/
        void wild() {
            ArrayList<? super Integer> a = new ArrayList<Integer>();
            ArrayList<? super Integer> a1 = new ArrayList<Number>();
            ArrayList<? super Integer> a2 = new ArrayList<Object>();
//            ArrayList<? super Integer> a3 = new ArrayList<Double>();
        }
    }
}