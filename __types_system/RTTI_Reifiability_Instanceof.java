package __types_system;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import types_references_annotations.my_annotations.Ntrstn;

/* RTTI (runtime type identification) - (АВТОМАТИЧЕСКИЙ) МЕХАНИЗМ ДИНАМИЧЕСКОГО ОПРЕДЕЛЕНИЯ ТИПОВ
 * - использует во время работы программы информацию о типе, доступную при компиляции
 *      - для получения информации используется соответствующий объект Class
 *
 *
 * - обеспечивает:
 *      - безопасность (нисходящих) преобразований типов:
 *          - чтобы в рантайме при попытке привести родителя к ребенку удостоверится, что приводимый
 *          объект действительно является ребенком
 *              - иначе будет вызвано ClassCastException
 *                  - т.к. дальше было бы некорректное поведение программы и загрязнение кучи
 *
 *      - полиморфизм:
 *          - чтобы в рантайме при вызове метода по родительской ссылке вызвать метод реального типа
 *          объекта по ссылке
 *
 *      - безопасность работы с массивами
 *          - чтобы в массив нельзя было добавить несовместимые типы
 *              - JVM обязана контролировать совместимость типов в массиве
 *              - иначе будет вызвано ArrayStoreException
 *                  - т.к. дальше было бы некорректное поведение программы и загрязнение кучи
 *
 *
 * - самостоятельно получить информацию о типе от RTTI можно при помощи оператора instanceof
 *      - чтобы избежать ClassCastException и ArrayStoreException
 *      - RTTI является традиционным способом получения информации о типе */


/* RTTI VS РЕФЛЕКСИЯ
 * - сходства:
 *      - позволяют во время работы программы узнавать информацию о типе объекта
 *          - для получения информации используется объект Class
 *
 * - различия:
 *      - RTTI: механизм обеспечения типовой безопасности, основанный на информации о типах,
 *      известной при компиляции
 *          - т.е. информация о типе, которую можно получить во время работы, была известна при
 *          компиляции
 *              - для получения информации используется:
 *                 - компилятором соответствующий файл .class
 *                 - JVM соответствующий объект Class
 *          - механизм используется автоматически для обеспечения типовой безопасности при:
 *              - приведениях (корректность приведения родителя к ребенку)
 *              - работе с массивами (корректность добавления объектов)
 *              - полиморфизме (вызов корректного метода)
 *          - можно самостоятель узнать только информацию о типе объекта, но не о его структуре
 *
 *      - рефлексия: механизм доступа к информации о типе и структуре класса (в т.ч. внешнего)
 *          - информация о типе могла быть недоступной при компиляции, например:
 *              - при программировании компонентов программы
 *              - при распределенных вычислениях
 *          - для получения информации используется:
 *                 - JVM соответствующий объект Class
 *          - можно также узнать информацию о всей структуре класса
 *              - т.е. все унаследованные и синтетические/неявные члены */


/* instanceof vs isInstance vs сравнение объектов Class при помощи ==
 * -  instanceof и isInstance дают одинаковые результаты
 * - == не затрагивает наследование
 *
 * */


@Ntrstn("Механизм рефлексии и механизм динамического определения типов (RTTI) позволяют во время " +
        "работы программы получить информацию о типе нужного объекта. Однако, в отличие от рефлексии, " +
        "для работы RTTI информация о типе должна быть изначально доступна при компиляции программы, " +
        "т.е. он работает только для объектов, описанных в самой программе. Рефлексия же помогает " +
        "обойти это ограничение, и позволяет узнавать информацию о типе объекта, полученного извне " +
        "(при помощи ClassLoader) - напр. в мой метод я получаю Object, и чтобы узнать его реальный " +
        "тип (и, следовательно, методы - использую рефлексию). Т.е. по сути разница в том, кто (и когда) исследует .class файл " +
        "объекта - при RTTI это делает компилятор, а при рефлексии - JVM.")

@Ntrstn("Разница между традиционным RTTI и рефлексией в том, что при использовании RTTI файл .class " +
        "открывается и изучается компилятором, т.е. мметоды объекта можно вызвать обычным способом. " +
        "А при работе с рефлексией файл .class во время компиляции недоступен - он открывается и " +
        "обрабатывается системой выполнения")

@Ntrstn("Также в отличие от RTTI, рефлексия открывает доступ к полям, методам и конструкторам " +
        "нужного класса, плюс доступны унаследованные поля и методы, скрытые и синтетические " +
        "элементы.")


@Ntrstn("информация о любом классе (типе), используемом во время работы программы хранится в\n" +
        " * соответствующем объекте типа Class. Эти")





/* ДОСТУПНОСТЬ ИНФОРМАЦИИ О ТИПЕ ВО ВРЕМЯ РАБОТЫ С НИМ В RUNTIME
 * - позволяет узнавать тип при помощи оператора instanceof
 *      - только для ссылочных типов
 *
 * - использовать тип в качестве элемента массива
 *      - т.к. JVM обязана контролировать реальный тип массива и выбрасывать ArrayStoreException при
 *      некорректном добавлении элементов в него, чтобы избежать загрязнения кучи
 *          - такое возможно при назначении массива родительской ссылке и добавления в него
 *          родительских элементов */


/* МАТЕРИАЛИЗИРУЕМЫЕ ТИПЫ - ИНФОРМАЦИЯ О ТИПЕ ПОЛНОСТЬЮ ДОСТУПНА В RUNTIME
 * - необобщенный тип
 *      Object o;
 *      Serializable s;
 *
 * - обобщенный тип, у которого все аргументы типа являются неограниченными метасимволами
 *      List<?> l;
 *          - т.е. параметр типа нас не интересует
 *              - т.к. это может быть вообще любой параметр
 *
 * - базовые тип
 *      List l;
 *
 * - примитивный тип
 *      int i;
 *      boolean b;
 *
 * - массив, у которого элементы материализируемого типа
 *      Object [] o;
 *
 * - todo вложенный тип, где для каждого типа Т, разделенного точкой, Т является материализируемым типом
 *      - если у обобщенного класса X<T> есть обобщенный член класса Y<U>, то тип X<?>.Y<?>
 *      материализируемый, потому что X<?> */


/* НЕМАТЕРИАЛИЗИРУЕМЫ ТИПЫ - ИНФОРМАЦИЯ О ТИПЕ ПОЛНОСТЬЮ ИЛИ ЧАСТИЧНО ОТСУТСТВУЕТ В RUNTIME
 * - обобщенный тип, у которого в аргументах типа нет неограниченного метасимвола
 *      - напр. List<String> и List<Number> не отличимы для JVM
 *      - напр. для List<? extends Number> пришлось бы убедиться, что у объекта параметр типа
 *      соответствует указанной границе  */


@Ntrstn("Доступность информации о типе во время работы позволяет узнавать этот тип в runtime при " +
        "помощи оператора instanceof (работает только для ссылочных), а также контролировать типы " +
        "элементов, которые добавляются в массив (так JVM сможет выбросить ArrayStoreException при " +
        "добавлении родительского элемента в массив типа наследника, а это возможно, если сначала " +
        "такой массив назначить ссылке родительского типа)")

@Ntrstn("Материализируемые типы - информация о типе полностью доступна во время работы программы, " +
        "нематериализируемый - информация не полностью доступна или не доступна. Единственный тип, " +
        "который относится к нематериализируемым - это обобщенный тип, если у него в качестве " +
        "параметра указан НЕ неограниченный метасимвол. JVM не знает реальный тип параметра, т.к. к " +
        "моменту работы программы он стерт. Если тип параметра указан как ограниченный метасимвол, " +
        "JVM все равно пришлось бы сверять реальный параметр типа с этой границей, что также " +
        "невозможно сделать в runtime")


public class RTTI_Reifiability_Instanceof {

    /*~~~~~~~~~~~~~~~~~~МАТЕРИАЛИЗИРУЕМЫЕ ТИПЫ~~~~~~~~~~~~~~~~~~*/
    Number object = new Integer(1);
    Serializable interf = new Serializable() {
        @Override
        public int hashCode() {
            return super.hashCode();
        }
    };
    List<?> listUnkn = new ArrayList<String>();
    List listRaw = new ArrayList();
    int integ = 1;
    boolean bool = false;
    Object[] objArr = new Object[1];

    /*~~~~~~~~~~~~~~~~~~НЕМАТЕРИАЛИЗИРУЕМЫЕ ТИПЫ~~~~~~~~~~~~~~~~~~*/
    List<String> listString;
    List<? extends Number> listUnknBound;


    public static void main(String[] args) {
        RTTI_Reifiability_Instanceof m = new RTTI_Reifiability_Instanceof();

        System.out.println(m.object instanceof Number);
        System.out.println(m.interf instanceof Serializable);
        System.out.println(m.listUnkn instanceof List<?>);
        System.out.println(m.listRaw instanceof List);
//        System.out.println(m.integ instanceof int); // instanceof работает только для объектов
        System.out.println(m.objArr instanceof Object[]);

//        System.out.println(m.listString instanceof List<String>); // нематериализируемый
//        System.out.println(m.listUnknBound instanceof List<? extends Number>); // нематериализируемый
    }
}
