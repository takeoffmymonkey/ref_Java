package __types_system;

import types_references_annotations.my_annotations.Ntrstn;

/* RTTI (runtime type identification) - МЕХАНИЗМ ДИНАМИЧЕСКОГО ОПРЕДЕЛЕНИЯ ТИПОВ
 * - позволяет во время работы
 * */

/* RTTI - runtime type identification
 * - позволяет получать и использовать информацию о типах во время выполнения
 *
 * - использует нужны объект Class для получения информации о типе
 *
 * */

/* Формы rtti
 * 1. классическое преобразование, кот. использует rtti для проверки правильности преобразования.
 * выбрасывает ClassCastException при неправильном преобразовании
 * 2. объект Class, представляющий тип моего объекта. У объекта Class можно запросить полезную инфц
 * во время исполнения
 * 3. instanceof,сообщает принадлежит ли объект к некоторому типу
 * */


/* RTTI - 1 из способов узнать тип класса во время выполнения
 * - скорее как механизм обеспечения правильности работы с типом в рантайме
 *      - чтобы знать какой реально метод нужно вызвать
 *      - чтобы не добавить в массив некорректный тип
 *      - при извлечении из массива
 * */

/* * - RTTI
 *      - традиционное динамическое определение типов
 *          - во время компиляции и выполнения у меня есть все необходимые типы
 *      - обычно используется при:
 *          - downcast к классу-наследнику - использует RTTI для проверки правильности преобразования
 *              - т.е. механизм обеспечивает правильность НИСХОДЯЩЕГО преобразования
 *          - проверка типа объекта с помощью instanceof
 *          - динамическое связывание? т.е. узнавание реального типа объекта
 *          - когда элемент достается из массива
 *      - подразумевает, что типы были известны еще во время компиляции
 *          - но в некоторых случаях эта информация недоступна
 *              - при программировании компонентов программы
 *              - при распределенных вычислениях
 *
 *              */


/* instanceof vs isInstance vs сравнение объектов Class при помощи ==
 * -  instanceof и isInstance дают одинаковые результаты
 * - == не затрагивает наследование
 *
 * */


@Ntrstn("Механизм рефлексии и механизм динамического определения типов (RTTI) позволяют во время " +
        "работы программы получить информацию о типе нужного объекта. Однако, в отличие от рефлексии, " +
        "для работы RTTI информация о типе должна быть изначально доступна при компиляции программы, " +
        "т.е. он работает только для объектов, описанных в самой программе. Рефлексия же помогает " +
        "обойти это ограничение, и позволяет узнавать информацию о типе объекта, полученного извне " +
        "(при помощи ClassLoader) - напр. в мой метод я получаю Object, и чтобы узнать его реальный " +
        "тип (и, следовательно, методы - использую рефлексию). Т.е. по сути разница в том, кто (и когда) исследует .class файл " +
        "объекта - при RTTI это делает компилятор, а при рефлексии - JVM.")

@Ntrstn("Также в отличие от RTTI, рефлексия открывает доступ к полям, методам и конструкторам " +
        "нужного класса.")

public class RTTI {
    static class A {
    }

    static class AB extends A {
    }

    static class AC extends A {
    }

    public static void main(String[] args) {
        /* ~~~~~~~~~~~~~~~~РАБОТА RTTI~~~~~~~~~~~~~~~~*/
        /* ТИПЫ ИЗВЕСТНЫ ПРИ КОМПИЛЯЦИИ */
        A a = new A();
        AB ab = new AB();
        AC ac = new AC();

        if (a instanceof AB) { // instanceof ()
            a = (A) ab; // downcast
        }


    }

}