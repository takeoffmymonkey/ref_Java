package __types_system;

import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import types_references_annotations.my_annotations.Ntrstn;
import types_references_classes.classes_inside.nested_static.Main;


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ПАКЕТ JAVA.LANG.REFLECTION~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - предоставляет программный доступ к информации о полях, методах и конструкторах загруженных
 * классов
 *      - позволяет работать (читать/записывать и вызывать/создавать) с данными членами
 *
 *
 * - интерфейсы:
 *      - AnnotatedArrayType: потенциально аннотированное использование массивного типа, тип
 *      элементов которого и сам может представлять аннотированное использование типа
 *
 *      - AnnotatedElement: аннотированный элемент программы, которая сейчас выполняется VM
 *
 *      - AnnotatedParameterizedType: потенциально аннотированное использование параметризированного
 *      типа, типы аргумента которого могут и сами представлять аннотированное использование типов
 *
 *      - AnnotatedType: потенциально аннотированное использование типа в программе
 *
 *      - AnnotatedTypeVariable: потенциально аннотированное использование переменной типа, чье
 *      объявление может иметь границы, которые и сами могут представлять аннотированные
 *      использования типов
 *
 *      - AnnotatedWildcardType: потенциально аннотированное использование агрумента типа wildcard,
 *      чьи верхняя или нижняя границы могут и сами представлять потенциально аннотированные
 *      использования типов
 *
 *      - GenericArrayType: представляет тип массива, тип элементов которого либо параметризированный
 *      тип либо переменная типа
 *
 *      - GenericDeclaration: общий интерфейс для всех сущностей, объявляющих переменные типа
 *
 *      - InvocationHandler: интерфейс, реализуемые помощником по инициализации прокси экземпляра
 *
 *      - Member: интерфейс, представляющий идентифицирующую информацию об одном члене (поле, методе
 *      или конструкторе)
 *
 *      - ParameterizedType: представляет параметризированный тип, например Collection<String>
 *
 *      - Type: общий интерфейс-родитель для всех типов в Java
 *
 *      - TypeVariable<D extends GenericDeclaration>: общий интерфейс-родитель для переменных типа
 *
 *      - WildcardType: представляет выражение типа с wildcard, например ?, ? extends Number, или
 *      ? super Integer
 *
 *
 * - классы:
 *      - AccessibleObject: родитель для объектов Field, Method и Constructor
 *
 *      - Array: предоставляет статические методы для динамического создания и доступа к массивам
 *
 *      - Constructor<T>: предоставляет информацию и доступ к одному конструктору класса
 *
 *      - Executable: общий родитель для общей функциональности классов Method и Constructor
 *
 *      - Field: предоставляет информацию и динамический доступ к одному полю класса/интерфейса
 *
 *      - Method: предоставляет информацию и доступ к одному методу класса/интерфейса
 *
 *      - Modifier: предоставляет статические методы и константы для раскодирования модификаторов
 *      доступа класса и членов
 *
 *      - Parameter: информация о параметрах метода
 *
 *      - Proxy: предоставляет статические методы для создания динамических прокси-классов и объектов,
 *      а также является родителем все динамических прокси классов, созданных этими методами
 *
 *      - ReflectPermission: представляет разрешения для операций рефлексии
 *
 *
 * - исключения:
 *      - InvocationTargetException: проверяемое исключения, которое оборачивает исключение,
 *      выбрасываемое вызванным методом или конструктором
 *
 *      - MalformedParameterizedTypeException: выбрасывается когда семантически некорректный
 *      параметризированный тип встречается рефлексивным методом, которому нужно инициировать его
 *
 *      - MalformedParametersException: выбрасывается, когда пакет java.lang.reflect пытается
 *      прочитать параметры метода из файла класса и определяет, что один из них или более некорректны
 *
 *      - UndeclaredThrowableException: выбрасывается при вызове метода на экземпляре прокси, если
 *      его метод-помощник по инициализации выбрасывает проверяемое исключение, которое не
 *      относится ни к одному из объявленных типов исключений в блоке throws метода, который был
 *      вызван на экземпляре прокси и передан помощнику по инициализации (ага, бля)
 *
 *
 * - ошибки:
 *      - GenericSignatureFormatError: выбрасывается, когда синтатически некорректный атрибут
 *      подписи встречается рефлексивным методом, которому нужно интерпретировать общую (generic)
 *      информацию подписи для типа, метода или конструктора (епто)*/


/* РЕФЛЕКСИЯ - МЕХАНИЗМ ИССЛЕДОВАНИЯ ДАННЫХ О ПРОГРАММЕ В RUNTIME; ПОЗВОЛЯЕТ:
 * - получить информацию о классе и его структуре в runtime
 *      - при помощи объекта Class соответствующего класса
 *          - находится в пакете java.lang
 *          - напр. узнать список методов и какие из них являются переопределениями для
 *          имплементируемого интерфейса
 *          - напр. синтетические конструкции, которые были добавлены при компиляции
 *
 * - изменить поведение объектов
 *      - при помощи вспомогательных классов из пакета java.lang.reflect работать со всеми членами
 *
 * - полноценно работать с классами, которые были не доступны в runtime
 *      - при помощи вспомогательных классов из пакета java.lang.reflect работать со всеми членами
 *          - а не как с объектом типа Object */


/* ЧТО МОЖНО УЗНАТЬ С ПОМОЩЬЮ РЕФЛЕКСИИ
 * - пакет класса
 * - класс-родитель
 * - всю информацию о типе класса, членов, их параметров, элементов массива
 * - все переменные типа (но не их реальные значения - они стерты)
 * - все интерфейсы, которые имплементирует класс
 * - все аннотации (у которых стоит RetentionPolicy RUNTIME)
 * - все модификаторы
 * - все члены - приватные, унаследованные публичные, обобщенные и поля-константы
 * - все названия параметров метода/конструктора
 * - все выбрасываемые исключения у метода/конструктора
 * - все дополнительные элементы, которых не было при компиляции (например, синтетические методы)
 * - кому принадлежит член (напр. данный внутренний класс)
 * - является ли член массивом, перечислением, аннотацией, полем-константой, интерфейсом, локальным
 * или анонимным классом, методом имплементируемого интерфейса
 * - является ли член синтезированным, неявным, мостовым
 * - является ли член доступным для модификации из другого указанного класса
 * - является ли член экземпляром указанного класса (аналог instanceof) */


/* ЧТО НЕЛЬЗЯ С ПОМОЩЬЮ РЕФЛЕКСИИ
 * - узнать класс, в котором объявлен данный анонимный класс
 * - узнать значение, установленное в параметре типа
 * - узнать имя аргумента метода/конструктора (если при компиляции не указана опция -parameters)
 * - узнать аннотацию, если у нее не стоит RetentionPolicy.RUNTIME
 * - изменить финализированное значение поля
 * - изменить модификатор
 * - создать экземпляр класса-перечисления*/


/* ПОЛЬЗА РЕФЛЕКСИИ И МЕСТА ПРИМЕНЕНИЯ
 * - полноценная работа с классами, которых не существовало в момент компиляции
 *
 * - визуальные средства программирования
 *      - показывать структуру класса
 *      - скрывать синтетические и другие нерелевантные члены
 *
 * - средства тестирования
 *      - увидеть полную структуру класса
 *      - получить доступ к приватным членам
 *
 * - а также дебаггеры, интерпретаторы, инспекторы объектов, браузеры классов, сериализация объектов
 * и JavaBeans
 *
 * - в обычной работе применяется не часто */


/* МИНУСЫ РЕФЛЕКСИИ
 * - ухудшение производительности
 *      - из-за типов, которые разрешаются динамически
 *          - JVM не может произвести некоторые, связанные с ними, оптимизации
 *
 * - ограничение безопасности
 *      - todo требует runtime права, которого может не быть при работе в security manager (Applet)
 *
 * - доступность скрытого (нарушение инкапсуляции!)
 *      - нарушается сокрытие приватных членов
 *         - может привести к проблемам с кодом */


/*~~~~~~~~~~~~~~~~~~~~~~КЛАСС JAVA.LANG.CLASS - ВХОДНАЯ ТОЧКА В REFLECTION API~~~~~~~~~~~~~~~~~~~~~~
 * - Class Class<T> extends Object implements Serializable, AnnotatedElement, GenericDeclaration, Type
 *
 * - не является частью пакета java.lang.reflect
 *
 * - каждый тип объекта в программе имеет 1 соответствующий этому типу экземпляр класса Class
 *      - этот экземпляр создается JVM единожды при первом обращении к статическому члену данного
 *      класса
 *          - в т.ч. конструктору
 *      - экземпляр является неизменяемым
 *
 * - экземпляр класса Class используется как входная точка в Reflection API
 *      - он предоставляет множество методов для получения членов класса и информации о типе
 *          - например:
 *              - getFields()
 *              - getMethods()
 *              - getConstructors()
 *          - для членов существуют отдельные классы java.lang.reflect, но они не имеют конструкторов,
 *          поэтому для получения их экземпляров используется соответствующий экземпляр Class
 *
 * - параметризированная версия существует для удобства:
 *      - можно ограничить тип, которому может принадлежать ссылка типа Class
 *          - Class<?> можно использовать, чтобы указать, что тип неизвестен
 *      - можно также использовать и непараметризированную версию */


/* ~~~~~~~~~~~~~~ПОЛУЧЕНИЕ НУЖНЫХ ЭКЗЕМПЛЯРОВ CLASS~~~~~~~~~~~~~~
 * - получения объекта Class:
 *      - Тип.class: для примитивов и void или когда есть тип, но нет объекта
 *          - наиболее эффективный (не нужно вызывать метод)
 *              - т.е. это уже готовая ссылка на нужный объект Class
 *              - проверка осуществляется при компиляции
 *          - не приводит к созданию экземпляра Class, если он еще не создан
 *
 *      - объект.getClass(): когда есть нужный объект
 *          - только для ссылочных типов
 *
 *      - Class.forName(): когда есть полное имя класса
 *          - только для ссылочных типов
 *          - может выбросить исключение ClassNotFoundException
 *          - приводит к созданию экземпляра Class, если он еще не создан
 *
 *      - Оболочка.TYPE: альтернатива Тип.class для получения примитивов и void от их оболочек
 *          - у каждого класса-оболочки есть поле TYPE с ссылкой на объект Class соответствующего
 *          примитива
 *
 *
 * - получение объекта Class от другого Class:
 *      - класс.getSuperclass(): получить родителя данного класса
 *
 *      - класс.getEnclosingClass(): получить обрамляющий класс
 *
 *      - класс.getClasses(): массив из всех публичных(!) классов, интерфейсов и перечислений,
 *      которые являются членами данного класса (в т.ч. унаследованные)
 *
 *      - класс.getDeclaredClasses(): массив из всех классов, интерфейсов и перечислений, которые
 *      явно объявлены в данном классе
 *
 *      - класс.getDeclaringClass(): возвращает класс, в котором объявлен данный член
 *          - не работает для анонимных классов
 *              - но можно получить обрамляющий класс
 *          - соответствующие аналоги для полей, методов и конструкторов:
 *              - java.lang.reflect.Field.getDeclaringClass()
 *              - java.lang.reflect.Method.getDeclaringClass()
 *              - java.lang.reflect.Constructor.getDeclaringClass() */


/* ~~~~~~~~~~~~~~ ПОЛУЧЕНИЕ ЧЛЕНОВ КЛАССА / СХОДСТВА В МЕТОДАХ GET...~~~~~~~~~~~~~~
 * - получить член можно соответствующим методом либо по имени либо массивом
 *      - возваращаемый тип - соответвующая реализация интерфейса java.lang.reflect.Member
 *          - классы Field, Method, Constructor
 *
 * - методы получения членов:
 *      - get...() VS getDeclared...():
 *          - get...(): вернет указанный публичный члены или массив публичных членов, в т.ч.
 *          унаследованный
 *          - getDeclared...(): вернет указанный член или массив членов, явно объявленный в классе,
 *          в т.ч. приватный
 *
 *      - get...()/getDeclared...() VS get...s()/getDeclared...s():
 *          - get...()/getDeclared...(): вернет указанный член
 *          - get...s()/getDeclared...s(): вернет указанные члены в виде массива типа члена (напр.
 *          Fields[])
 *
 *      - todo get...() VS getGeneric...():
 *          - get...(): возвращает Class-версию объекта
 *          - getGeneric...(): возвращает Type-версию объекта, предствляющие типы параметров */


/* ~~~~~~~~~~~~~~ МЕТОДЫ GET.../SET... КЛАССОВ FIELD И ARRAY И ИХ СХОДСТВА ~~~~~~~~~~~~~~
 * - get...(...)/set...(...): получение/установка значения с указанным примитивным типом
 *
 * - get(Object)/set(Object): получение/установка значения с типом Object
 *      - если достается примитив, то он будет обвернут в Object
 *      - при установке поля/элемента, перед установкой оно будет автоматически распаковано из
 *      Object
 *          - в т.ч. если это примитив
 *
 * - при получении/установке значения поля/элемента автоупаковка и автораспаковка из/в типы-обвертки
 * не происходит!
 *      - т.е. в реальное поле типа Integer нельзя передать просто int
 *
 * - если устанавливается значение финализированного поля, будет выброшено IllegalAccessException*/


/* ~~~~~~~~~~~~~~ ПОЛУЧЕНИЕ МОДИФИКАТОРОВ / КЛАСС MODIFIER ~~~~~~~~~~~~~~
 * - получить модификаторы: класс\член.getModifiers()
 *      - возвращается число - закодированные модификаторы
 *      - раскодировать в строковое значение можно при помощи статического метода Modifier.toString()
 *
 * - класс Modifier:
 *      - числовые константы, представляющие соответствующие модификаторы
 *      - статические методы для работы с модификаторами:
 *          - узнать модификаторы для указанного поля, конструктора, метода и параметра
 *          - узнать является ли данный модификатор указанным
 *          - перевести числовой код модификатора в строковое представление
 *
 * - для дефолтного модификатора нет константы и метода проверки!
 *      - поэтому нужно проверять, что член не является ни публичным, ни приватным, ни защищенным */


/* ~~~~~~~~~~~~ ПОЛУЧЕНИЕ ПЕРЕМЕННОЙ ТИПА / ИНТЕРФЕЙС TYPEVARIABLE ~~~~~~~~~~~~
 * - класс/член.getTypeParameters(): возвращает массив из объектов TypeVariable
 *
 * - методы TypeVariable:
 *      - getBounds(): вернет массив из Type, представляющий верхную границу(ы) переменной
 *      - getGenericDeclaration(): вернтет класс, в котором объявлено данное обобщение
 *      - getName(): вернет имя переменной, какое указано в коде */


/* ~~~~~~~~~~~~ПОЛУЧЕНИЕ АННОТАЦИЙ / ИНТРЕФЕЙС ANNOTATEDELEMENT~~~~~~~~~~~~
 * - представляет аннотированный элемент программы и позволяет читать аннотации
 *      - все возвращаемые аннотации являются неизменяемыми и сериализируемыми
 *          - если аннотации возвращаются в массиве, то сам массив можно менять, но это не приведет
 *          к изменению возвращаемых массивов другими методами
 *
 *
 * - получить можно только аннотации, у которых стоит RetentionPolicy.RUNTIME
 *
 *
 * - имплементируют классы Class, Field, Method, Constructor
 *
 *
 * - понятия:
 *      - "присутствует явно":
 *          - аннотация A присутствует явно на элементе E, если у E есть атрибут
 *          RuntimeVisibleAnnotations или RuntimeVisibleParameterAnnotations или
 *          RuntimeVisibleTypeAnnotations, и в атрибует содержится A
 *
 *      - "присутствует неяно":
 *          - аннотация A присутствует неявно на элементе E, если у E есть атрибут
 *          RuntimeVisibleAnnotations или RuntimeVisibleParameterAnnotations или
 *          RuntimeVisibleTypeAnnotations, и тип A - повторяемый, и атрибут содержит ровно одну
 *          аннотацию, чей элемент значения содержит A и чей тип - содержит тип аннотации типа А
 *
 *      - "присутствует":
 *          - аннотация A присутствует для элемента E если:
 *              - либо A присутсвует явно для Е
 *              - либо для Е аннотация типа A не присутствует явно, Е является классом, а тип A
 *              можно унаследовать, и А присутствует у родителя класса E.
 *
 *      - "ассоциирован":
 *          - аннотация A ассоциирована с элементом E если:
 *              - либо А присутствует явно или неявно на элементе E
 *              - либо А не присутствует явно или неявно на элементе E, Е является классом, а тип А
 *              можно унаследовать, и A ассоциирована с родителем класса E.
 *
 *
 * - методы:
 *      - getAnnotation(Class<T> annotationClass): вернет аннотацию элемента для указанного типа,
 *      если она присутствует, иначе null.
 *
 *      - getAnnotations(): вернет аннотации, присутствуещие для элемента
 *
 *      - getAnnotationsByType(Class<T> annotationClass): вернет аннотации, которые ассоциированы с
 *      данным элементом
 *
 *      - getDeclaredAnnotation(Class<T> annotationClass): вернет аннатацию элемента для указанного
 *      типа, если она присутствует явно, иначе null
 *
 *      - getDeclaredAnnotations(): вернет аннотации, которые присутствуют явно
 *
 *      - getDeclaredAnnotationsByType(Class<T> annotationClass): вернет аннотации элемента для
 *      указанного типа, если такие аннотации либо присутствуют явно либо неявно
 *
 *      - isAnnotationPresent(Class<? extends Annotation> annotationClass): вернет true, если
 *      аннотация для указанного типа присутствует для данного элемента, иначе false*/


/* todo ДРУГИЕ МЕТОДЫ КЛАССА CLASS
 * - <U> Class<? extends U> asSubclass(Class<U> clazz):
  *     - позволяет преобразовать объект класса к более конкретному
 *
 * - T cast(Object obj): Casts an object to the class or interface represented by this Class object.
 *      - полезен, когда нельзя исплользовать обычное приведение типа. Напр. при написании
 *      обобщеннго кода и сохранении ссылки на Class, которая будет использоваться для приведения
 *      типа позднее. но такие ситуации возникают редко
 *
 * - isInstance() помогает избавится от громоздких конструкций instanceof
 *      instanceof и isInstance дают одинаковые результаты
 *      == не затрагивает наследование
 *
 * - isAssignableFrom(Class<?> cls)
 *      Integer.class.isAssignableFrom(int.class) == false
 *      Strictly speaking, any attempt to set a field of type X to a value of type Y can only succeed if the following statement holds:
        X.class.isAssignableFrom(Y.class) == true
 *
 * - getCanonicalName()
 * */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ЧЛЕНЫ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~ ИНТЕРФЕЙС MEMBER ~~~~~~~~~~~~~~~~~~~~~~~~
 * - для идентификации членов класса: полей, методов и конструкторов
 * - имплементируется классами Field, Method и Constructor
 * - методы:
 *      - getDeclaringClass(): вернет класс, которому принадлежит член
 *      - getModifiers(): вернет закодированное число, представляющее модификаторы члена
 *      - getName(): вернет имя члена из кода
 *      - isSynthetic(): проверка, является ли член добавленным при компиляции */


/* ~~~~~~~~~~~~~~~~~~~~~~~~ КЛАСС ACCESSIBLEOBJECT ~~~~~~~~~~~~~~~~~~~~~~~~
 * - public class AccessibleObject extends Object implements AnnotatedElement
 *
 * - является прямым родителем для Field и прародителем (через класс Executable) для Method и
 * Constructor
 *
 * - предоставляет возможность помечать член для игнорирования стандартных проверок доступа, которые
 * выполняет Java
 *      - при чтении и записи полей, вызовах методов и создании экземпляров классов
 *
 * - по дефолту для всех членов стоит флаг "не доступен"
 *      - но все равно можно обращаться к реально доступным членам
 *          - например, можно установить значение публичному члену или вызвать метод, даже если у
 *          него стоит флаг "не доступен"
 *              - но работать с фактически не доступными членами (например, private), без установки
 *              флага "доступен" работать не получится
 *
 * - основные методы:
 *      - isAccessible(): возвращает значение флага accessible для объекта
 *      - setAccessible(boolean flag): включение/выключение проверки прав доступа
 *      - setAccessible(AccessibleObject[] array, boolean flag): удобный и производительный метод
 *      для установки проверки доступа для массива объектов */


/* ~~~~~~~~~~~~~~~~~~~~~~~~ ПОЛЯ / КЛАСС FIELD~~~~~~~~~~~~~~~~~~~~~
 * - public final class Field extends AccessibleObject implements Member
 *
 * - предоставляет доступ к полю класса или интерфейса
 *
 * - поля могут быть:
 *      - принадлежащими экземпляру
 *      - статическими
 *      - синтезированы компилятором
 *          - проверить: isSynthetic()
 *          - обычно являются не публичными
 *      - константами перечисления (если исследуется класс-перечисление)
 *          - проверить: isEnumConstant()
 *
 * - получение и запись значения:
 *      - должно использоваться как можно реже, т.к. нарушает инкапсуляцию (т.е. сам смысл класса)
 *      - замедляет работу, т.к. требуется проверка доступа
 *      - операция замены является атомарной, как и простой замене в коде
 *      - такой код не будет оптимизирован JVM, если оптимизация должна была бы произойти без рефлексии
 *      - если поле статическое, то объект просто игнорируется
 *      - автоупаковка и автораспаковка не происходит, т.к. это runtime
 *          - т.е. в поле типа Integer нельзя установить значение простым int, и наоборот */


/* ~~~~~~~~~~~~~~~~~~~~~~~~ КЛАСС EXECUTABLE ~~~~~~~~~~~~~~~~~~~~~~~~
 * - public class Executable extends Object implements AnnotatedElement, GenericDeclaration, Member
 *
 * - является прямым родителем для для Method и Constructor
 *
1 * - в качестве параметра для запуска метода/конструктора можно передать родительский тип, но не тип
 * наследника (сужение)
 *      - иначе будет выброшено IllegalArgumentException
 *
 * - если это параметр с переменным числом аргументов, то передается массив
 *
 * - основные методы:
 *      - getExceptionTypes(): вернет массив объектов типа Class, который представляет типы
 *      исключений, которые объявлены для данного Executable
 *      - getParameters(): вернет массив объектов типа Parameter, который представляет параметры
 *      данного Executable
 *      - getParameterCount(): вернет число параметров у данного Executable
 *      - getParameterTypes(): вернет массив объектов типа Class, который представляет параметры
 *      типа (в последовательности объявления) у данного Executable
 *      - getTypeParameters(): вернет массив объектов типа TypeVariable, который представляет
 *      переменные типа (в последовательности объявления) у данного Executable
 *      - isVarArgs(): узнать, есть ли у данного Executable переменное число параметров*/


/* ~~~~~~~~~~~~~~~~~~~~~~~~ ПАРАМЕТРЫ / КЛАСС PARAMETER ~~~~~~~~~~~~~~~~~~~~~~~~
 * - public final class Parameter extends Object implements AnnotatedElement
 *
 * - предоставляет:
 *     - информацию о параметрах метода/конструктора
 *          - в т.ч. имя и модификаторы
 *              - имя модификатора доступно только, если при компиляции указать опцию -parameters
 *                  - иначе имя будет типа arg0
 *              - по дефолту не хранятся, чтобы:
 *                  - сэкономить место
 *                  - нельзя было по имени найти секретный параметр, например Password
 *      - альтернативные средства получения атрибутов параметра
 *
 * - параметры могут также быть:
 *      - неявными: проверка - isImplicit()
 *      - синтетическими: проверка - isSynthetic()
 *      - с переменным числом аргументов: проверка - isVarArgs()
 *      - не иметь имени (т.к. он является синтезированным или синтетическим): проверка - isNamePresent()
 *
 * - другие основные методы:
 *      - equals(Object obj): сравнивает на основании Еxecutable и индекса
 *      - hashCode(): вернет hash code на основании hash code Еxecutable и индекса */


/* ~~~~~~~~~~~~~~~~~~~~~ МЕТОДЫ / КЛАСС METHOD ~~~~~~~~~~~~~~~~~~~~~
 * public final class Method extends Executable
 *
 * - предоставляет:
 *      - доступ к информации о типах параметров, выбрасываемых исключений и возвращаемого значения
 *      - возможность запускать нужный метод для указанного объекта
 *
 * - запуск метода:
 *      - может понадобится только если невозможно привести экземпляр класса к нужному типу в коде
 *      без помощи рефлексии
 *      - public Object invoke(Object obj, Object... args) throws IllegalAccessException,
 *      IllegalArgumentException, InvocationTargetException
 *          - если метод статический, то объект игнорируется (может быть null)
 *          - в случае возникновения исключения, оно будет обвернуто в InvocationTargetException
 *              - получить оригинал: InvocationTargetException.getCause() */


/* ~~~~~~~~~~~~~~~~~~~~~КОНСТРУКТОРЫ / КЛАСС CONSTRUCTOR ~~~~~~~~~~~~~~~~~~~~~
 * - public final class Constructor<T> extends Executable
 *
 * - аналогично методам, кроме:
 *      - не имеет возвращаемого значения
 *      - вызов конструктора приводит к созданию экземпляра
 *
 * - создавать экземпляр можно 2 методами:
 *      - от объекта Constructor: public T newInstance(Object... initargs) throws
 *      InstantiationException, IllegalAccessException, IllegalArgumentException,
 *      InvocationTargetException
 *          - предпочтительный
 *              - можно исследовать и обрабатывать любые вызываемые конструктором исключения
 *                  - оборачивает исключения в InvocationTargetException
 *          - вызывает конструктор с любым числом аргументов
 *
 *      - от объекта Class: public T newInstance() throws InstantiationException,
 *      IllegalAccessException
 *          - вызывает только конструктор с 0 аргументов
 *          - выбрасывает любое исключение конструктора
 *              - проверяемое и не проверяемое
 *
 * - в отличие от оператора new, не происходит:
 *     - проверка типа аргументов
 *     - автоупаковка
 *     - todo разрешение методов */



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~МАССИВЫ И ПЕРЕЧИСЛЕНИЯ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - являются обычными классами и все, что относится к работе с классами, относится и к ним
 * - также имеют свои дополнительные API:
 *      - методы класса Class для перечислений и массивов
 *      - java.lang.reflect.Array для массивов */


/* ~~~~~~~~~~~~~~~~~~~~~ СПЕЦИФИЧЕСКИЙ СИНТАКСИС ДЛЯ МАССИВОВ ~~~~~~~~~~~~~~~~~~~~~
 * - при получении объекта Class по имени нужного класса, для массивов используется особый синтаксис:
 *      - относится и к ссылочным массивам и к примитивным
 *          - [ значит одно измерение массива
 *          - boolean: Z
 *          - byte:	B
 *          - char: C
 *          - класс/интерфейс Lимякласса;
 *          - double: D
 *          - float: F
 *          - int: I
 *          - long: J
 *          - short: S
 *
 * - напр. [[D - значит 2-мерный массив из элементов типа double */


/*~~~~~~~~~~~~~~~~~~~~~МАССИВЫ / КЛАСС JAVA.LANG.REFLECT.ARRAY~~~~~~~~~~~~~~~~~~~~~
 * - узнать, является ли класс массивом: класс.isArray()
 *
 * - public final class Array extends Object
 *
 * - узнать тип компонентов: класс.getComponentType()
 *
 * - создание нового массива:
 *      - Array.newInstance(Class type, int length)
 *      - Array.newInstance(Class<?> componentType, int... dimensions): для многомерного
 *
 * - узнать длину массива:
 *      - Array.getLength(Object o) */


/* ~~~~~~~~~~~~~~~~~~~~~ПЕРЕЧИСЛЕНИЯ~~~~~~~~~~~~~~~~~~~~~
 * - узнать, является ли класс перечислением: Class.isEnum()
 *
 * - получить константы-перечисления (только для классов-перечислений): Class.getEnumConstants()
 *
 * - узнать, является ли поле константой-перечислением (только для классов-перечислений): поле.isEnumConstant()
 *
 * - инициализировать экземпляры нельзя
 *      - даст IllegalArgumentException
 *      - т.к. определенные константы не смогут быть уникальными
 *      - поэтому перед инициализацией нужно убедится, что класс не является перечислением
 *
 * - методы Class.getFields() и Class.getDeclaredFields() не гарантируют точный порядок констант,
 * как он был при объявлении
 *      - todo иногда это важно (For various reasons, including support for evolution of the enum type)
 *      - получить поля с соблюдением порядка объявления: Class.getEnumConstants()*/


@Ntrstn("Механизм рефлексии является нетрадиционным способом получения информации о типах класса, и, " +
        "в отличие от традиционного RTTI, позволяет узнавать тип класса, который мог быть не " +
        "известен во время компиляции (т.е. например динамически добавлен во время работы) и " +
        "работать с ним полноценно, а не как с обычным Object. Кроме того, этот механизм позволяет " +
        "получить практически всю информацию о программе (в т.ч. ту, которой не было до компиляции - " +
        "например, увидеть добавленные компилятором синтетические конструкции), изменить ее поведение " +
        "при помощи ручного создания объектов почти любого класса, вызова любого метода и изменения " +
        "практически любого значения.")

@Ntrstn("При помощи рефлексии не получится: " +
        "- узнать, какому классу принадлежит данный анонимный класс" +
        "- узнать значение типа, установленное в переменной типа (стерто при компиляции)" +
        "- узнать имя аргумент метода/конструктора, если при компиляции не указана опция -parameters " +
        "(по дефолту заменяется на arg0, чтобы сохранить место и скрыть важные названия типа password)" +
        "- получить доступ к аннотации, если у нее не стоит RetentionPolicy.RUNTIME" +
        "- изменить финализированное значение (иначе исключение)" +
        "- изменить модификатор" +
        "- создать экземпляр класс перечисления (запрещено - должен быть уникальным)")

@Ntrstn("Рефлексия не используется часто в обычных программах, но она незаменима в случаях, когда " +
        "нужно полностью видеть структруру программы или иметь доступ к приватным членам - например, " +
        "IDE, дебаггеры, интерпретаторы, средства тестирования, визуальные средства программирования " +
        "и т.д.")

@Ntrstn("К минусам рефлексии относятся:" +
        "- ухудшение производительности (из-за того, что невозможно произвести некоторые оптимизации)" +
        "- нарушение инкапсуляции (т.к. доступно все, то нарушается смысл класса как такового)")

@Ntrstn("Все вспомогательные классы, представляющие конструкции языка (например, ключевые классы " +
        "Field, Method, Constructor, Parameter, Modifier, Type, TypeVariable, Array), находятся в " +
        "пакете java.lang.reflect, но не имеют публичных конструкторов, и либо предоставляют " +
        "статические утилитные методы (например, Array или Modifier - у последнего, например, есть " +
        "метод, который перекодирует число в модификатор или константу, представляющую модификатор) " +
        "либо создаются от экземпляра класса Class (находится в пакете java.lang) - например, " +
        "соответствующими методами getFields(), getMethods(), getConstructors(). Класс Class можно " +
        "смело считать входной точкой в API рефлексии, хоть он сам и не принадлежит пакету рефлесии.")

@Ntrstn("У каждого загруженного класса в программе, есть соответствующий экземпляр класса Class " +
        "(создается при первом обращении к статическому члену данного класса), ссылку на который " +
        "можно получить несколькими методами:" +
        "1 - Тип.class: для примитивов и void или когда есть тип, но нет объекта. Наиболее эффективен, " +
        "т.к. это уже готовая ссылка. Не приводит к созданию объекта Class, если данный класс еще не " +
        "создан." +
        "2 - объект.getClass(): когда есть нужный объект. Работает только для ссылочных типов. Если " +
        "соответствующий объект класса еще не создан, то он создастся" +
        "3 - Class.forName(str): когда есть полное имя класса. Работает только для ссылочных типов." +
        "4 - Оболочка.TYPE: альтернатива Тип.class для получения примитивов и void от их оболочек " +
        "(у каждого типа-оболочки есть поле со ссылкой на соответствующий объект Class для их " +
        "примитива)")

@Ntrstn("Также ссылку на экземпляр Class можно получить и от другого Class: на класс-родитель, на " +
        "обрамляющий класс, на все члены-классы данного класса, и на класс, в котором объявлен данный")

@Ntrstn("Параметризованная версия Class <T> существует только для удобства: обозначить, что данной " +
        "переменной типа можно назначить только объект класса Class, указанного типа, например: " +
        "Class<String> c = String.class. Версия с wildcard может использоваться, чтобы явно указать, " +
        "что скрываемый тип неизвестен.")

@Ntrstn("Получать объекты-члены класса можно при помощи соответствующего метода класса Class либо по " +
        "имени члена (например, getField(String name)) либо массивом (например, getFields()) - будет " +
        "возвращен объект или массив объектов соответствующего класса (реализация интерфейса Member), " +
        "например Field.")

@Ntrstn("Версия методов get...(s) возвращает указанный член/массив членов, только если он публичный, " +
        "но при этом также возвращается унаследованный член/массив членов. Версия getDeclared...(s) " +
        "вернет указанный член/массив членов, только если он был объявлен в данном классе, но при " +
        "этом вернет также и приватный член/массив членов.")

@Ntrstn("Несмотря на то, что технически конструктор не является членом класса (т.к. не наследуется), " +
        "в пакете рефлексии он все равно подразумевается именно как член")

@Ntrstn("Получать модификаторы можно методами класс/член.getModifiers(), однако они возвращаются " +
        "закодированными. Чтобы раскодировать число, нужно воспользоваться статическим методом " +
        "Modifier.toString(). Другие методы данного класса, позволяют узнавать модификаторы у " +
        "данного члена и проверять имеет ли член указанный модификатор. Кроме того, для " +
        "модификаторов представлены соответствующие константы. Однако важно знать, что для " +
        "дефолтного модификатора нет соответствующих методов или констант! Поэтому, единственный " +
        "способ узнать, имеет ли член дефолтный модификатор - убедится, что он не имеет остальных " +
        "модификаторов доступа")

@Ntrstn("Все члены (Field, Method, Constructor) имплементируют интерфейс Member, у которого есть " +
        "методы, чтобы узнать, какому классу принадлежит член, получить модификаторы члена, получить " +
        "имя самого члена и узнать, является ли он синтетическим (т.е. добавлен при компиляции")

@Ntrstn("При работе с членами (чтение и запись полей, вызов методов, создании экземпляров классов), " +
        "соблюдается их доступность по стандартным правилам доступа в Java. Т.е. нельзя прочитать " +
        "приватное поле или вызвать приватный метод, но можно, если он публичный. Класс " +
        "AccessibleObject является прямым (для Field) или непрямым (для Method и Constructor) " +
        "родителем, и устанавливает для всех членов по дефолту флаг не доступен, что означает, что " +
        "соблюдается стандартные правила доступа. Если нужно их игнорировать и свободно работать с " +
        "приватными членами, нужно для данного члена вызвать метод setAccessible(true). Кроме того, " +
        "методы данного класса позволяют узнать, какой сейчас флаг установлен и сменить флаг сразу " +
        "для массива членов")

@Ntrstn("Класс Field предоставляет доступ к полям класса или интерфейса. Поля могут принадлежать " +
        "экземпляру, быть статическими, быть синтезированными компилятором (isSynthetic()) или " +
        "константами класса-перечисления (isEnumConstant(); имеется ввиду, что данный класс и есть " +
        "перечисление и это его поле-константа-перечисление, а не просто поле с константой-" +
        "перечислением внутри любого класса)")

@Ntrstn("У методов get/set классов Field и Array есть сходства: можно считывать/записывать " +
        "поля/элементы специальной версией метода с указанным примитивом, а можно использовать " +
        "общую версию с Object. Во втором случае, если достается примитив, то он будет обернут в " +
        "Object, а если нужно записать примитив, то его нужно передать как Object, а затем он " +
        "автоматически распаковывается. При этом важно помнить, что в рефлексии не происходит " +
        "автоупаковка и автораспаковка примитивов из их собственных оберток (она происходит при " +
        "компиляции), т.е. если я получаю примитивное значение int из поля, я не могу его сразу " +
        "записывать в объект Integer, и наоборот. Кроме того, если пытаться записать " +
        "финализированное поле, то будет выброшено исключение. И еще один нюанс - методы первым " +
        "аргументом принимают объект, над которым производится действие, а если это статический " +
        "класс, то объект будет просто проигнорирован, можно передавать спокойно null")

@Ntrstn("Класс Executable является прямым родителем Method и Constructor. В качестве параметра для " +
        "запуска метода/конструктора можно передавать родительский тип, но не тип наследника (это " +
        "сужение и будет вызвано исключение). Сам класс предоставляет методы для получения типов " +
        "выбрасываемых исключений, параметров (в виде класса Parameter), числа и типа параметров, а " +
        "также параметров типа. Кроме того, можно узнать, есть ли у метода/конструктора переменное " +
        "число агрументов")

@Ntrstn("Класс Parameter представляет 1 параметр метода или конструктора и предоставляет о себе " +
        "всю информацию. Тем не менее, реальное имя аргумента может быть заменено на arg0 для " +
        "сохранения места и сокрытия названия важных полей (проверка - isNamePresent()) - если " +
        "компилировать программу без параметра -parameters. Сами параметры могут быть неявными " +
        "(isImplicit()), синтетическими (isSynthetic()), с переменным числом параметров (isVarArgs()).")

@Ntrstn("Класс Method представляет 1 метод класса и предоставляет всю информацию о нем (параметры, " +
        "выбрасываемые исключения, возвращаемый тип, параметры типа) и возможность запускать его. " +
        "Для запуска метода нужно вызвать invoke(Object obj, Object... args); выброшенное методом " +
        "исключение будет завернуто в InvocationTargetException (получить оригинал - getCause())")

@Ntrstn("Класс Constructor аналогичен классу Method, но не имеет возвращаемого типа, а вместо вызова " +
        "можно создавать объекты. Создавать можно 2 способами:" +
        "1 - от объекта Constructor: public T newInstance(Object... initargs). Является " +
        "предпочтительным, т.к. можно вызвать конструктор с любым числом аргументов, а выбрасываемые " +
        "исключения заворачиваются в InvocationTargetException и потом с ними можно работать." +
        "2 - от объекта Class: public T newInstance(). Вызывает только конструктор без аргументов, а " +
        "выбрасываемые исключения не заворачиваются")

@Ntrstn("В отличие от оператора new, создание объекта при помощи класса Constructor не производит " +
        "автоматической упаковки или проверки передаваемого типа")

@Ntrstn("Методы класса Class работают для всех ссылочных типов, включая массивы и перечисления. " +
        "Однако для последних существует дополнительное API: методы класса Class для перечислений и " +
        "массивов и методы класса Array для массивов")

@Ntrstn("У массивов в рефлексии (а также и в RTTI) существует специальный синтаксис для примитивов и " +
        "ссылочных типов, где [ значит одно измерение, а L(имя типа) - ссылочный тип, а другие " +
        "определенные заглавные - примитивы. Например, [[D - значит 2-мерный массив из элементов " +
        "типа double")

@Ntrstn("Для массива можно узнать, является ли класс массивом, длину массива, тип его элементов, а " +
        "также создавать массив, добавлять и менять значения его элементов.")

@Ntrstn("Для перечислений можно узнать, является ли класс перечислением, получить его константы-" +
        "перечисления, узнать, является ли его поле - полем-константой-перечислением. " +
        "Инициализировать константы нельзя, поэтому перед созданием любого экземпляра нужно " +
        "убедится, что его класс не является перечислением")

@Ntrstn("Механизмы рефлексии и динамического определения типа (RTTI) можно равноценно использовать " +
        "в runtime, чтобы узнать тип интересующего объекта. Для этого в RTTI можно использовать " +
        "оператор instanceof, а в рефлексии - информацию из объекта Class нужного объекта (instanceof " +
        "также использует этот объект для определения типа, а затем проверяет еще и иерархическую " +
        "совместимость (мое предположение!)). Однако, в отличие от рефлексии, RTTI имеет только " +
        "информацию о типах классов, которые были доступны еще при компиляции, а также используется " +
        "(автоматически) для обеспечения типовой безопасности при нисходящем преобразовании, при " +
        "работе с элементами массива и при вызовах полиморфных методов. В отличие от RTTI, рефлексия " +
        "не используется автоматически, и предоставляет разработчику доступ ко всем членам объекта " +
        "(в т.ч. синтетическим, которые появились после компиляции) - в runtime можно менять значения " +
        "полей, запускать нужные методы и создавать объекты при помощи конструкторов. Кроме того, " +
        "можно полноценно (а не только как с типом Object) работать с объектами классов, которые не " +
        "были доступны при компиляции, но были добавлены уже впоследствии")

public class Reflection<T extends Number> {
    static Modifier mod;
    static Class c;
    static Class[] ca;
    static Field f;
    static Field[] fa;
    static Method m;
    static Method[] ma;
    static Constructor k;
    static Constructor[] ka;
    static Parameter p;
    static Parameter[] pa;

    static Integer i = 33;
    static double[][] da = new double[1][];
    static String[][] sa = new String[1][];
    static List<?> l = new ArrayList<>();
    static List<Integer> l2 = new ArrayList<>();
    private Field field;
    static TestEnum testEnum = TestEnum.ONE;

    enum TestEnum {ONE, TWO}


    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException,
            NoSuchMethodException, IllegalAccessException, InvocationTargetException,
            InstantiationException {
        /* ~~~~~~~~~~~~~~~~~~~~~~~ CLASS VS CLASS<T> ~~~~~~~~~~~~~~~~~~~~~~~ */
        Class<String> cStr = String.class; // указывает, что типом может быть только String
//        cStr = Integer.class; // ошибка компилятора

        Class<?> cJ = String.class; // просто указывает, что тип неизвестен
        cJ = Integer.class; // ok

        c = String.class; // вообще ничего не указывает
        c = Integer.class; // ok


        /* ~~~~~~~~~~~~~~~~~~~~~~~ПОЛУЧЕНИЕ ЭКЗЕМПЛЯРА CLASS ДЛЯ ТИПА/ОБЪЕКТА~~~~~~~~~~~~~~~~~~~~~~~ */
        /* ~~~~~~~~~ПОЛУЧЕНИЕ ЭКЗЕМПЛЯРА CLASS~~~~~~~~~*/
        /* ДЛЯ ССЫЛОЧНЫХ ТИПОВ ПО ОБЪЕКТАМ */
        c = i.getClass(); // java.lang.Integer
        c = da.getClass(); // [[D
        c = sa.getClass(); // [[Ljava.lang.String

        /* ДЛЯ ПРИМИТИВОВ ИЛИ КОГДА НЕТ ОБЪЕКТОВ */
        c = Integer.class; // java.lang.Integer
        c = boolean.class; // boolean
        c = void.class; // void
        c = double[][].class; // [[D

        /* ПО ПОЛЮ TYPE У ОБОЛОЧЕК */
        c = Integer.TYPE; // int
        c = Void.TYPE; // void

        /* ПО ПОЛНОМУ ИМЕНИ КЛАССА */
        c = Class.forName("java.lang.Integer");
        c = Class.forName("[[D");
        c = Class.forName("[[Ljava.lang.String;");


        /* ~~~~~~~~~ПОЛУЧЕНИЕ ЭКЗЕМПЛЯРА CLASS ОТ ДРУГОГО CLASS ~~~~~~~~~*/
        /* ПОЛУЧЕНИЕ РОДИТЕЛЯ */
        c = Child.class.getSuperclass(); // __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge

        /* ПОЛУЧЕНИЕ ОБРАМЛЯЮЩЕГО КЛАССА */
        c = MainInner.class.getEnclosingClass(); // __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge

        /* ПОЛУЧЕНИЕ ВСЕХ КЛАССОВ, ИНТЕРФЕЙСОВ И ПЕРЕЧИСЛЕНИЙ, КОТОРЫЕ ЯВЛЯЮТСЯ ЧЛЕНАМИ (В Т.Ч. УНАСЛЕДОВАННЫЕ) */
        ca = Reflection.class.getClasses(); // [class __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge$MainInner, class __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge$Child]

        /* ПОЛУЧЕНИЕ ВСЕХ ЧЛЕНОВ, КОТОРЫЕ ЯВНО ОБЪЯВЛЕНЫ В КЛАССЕ */
        ca = Reflection.Child.class.getDeclaredClasses(); // [class __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge$Child$ChildOwnInner]

        /* ПОЛУЧЕНИЕ КЛАССА/ЧЛЕНОВ, В КОТОРОМ ОН ОБЪЯВЛЕН */
        c = Reflection.Child.class.getDeclaringClass(); // __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge


        /* ~~~~~~~~~~~~~~~~~~~~~~~ПОЛУЧЕНИЕ МОДИФИКАТОРА КЛАССА И ТИПА ~~~~~~~~~~~~~~~~~~~~~~~ */
        int modifiers = Reflection.Child.class.getModifiers(); // 25
        Modifier.toString(modifiers); // public static final

        TypeVariable[] typeVariable = Reflection.class.getTypeParameters();
        typeVariable[0].getName(); // T
        Type t = typeVariable[0].getBounds()[0]; // class java.lang.Number
        typeVariable[0].getGenericDeclaration(); // class __types_system.Reflection


        /* ~~~~~~~~~~~~~~~~~~~~~~~ПОЛУЧЕНИЕ АННОТАЦИЙ~~~~~~~~~~~~~~~~~~~~~~~ */
        c = Reflection.class;
        Annotation[] a = c.getDeclaredAnnotations();


        /* ~~~~~~~~~~~~~~~~~~~~~~~ОТКЛЮЧЕНИЕ ПРОВЕРКИ ДОСТУПА ДЛЯ ЧЛЕНА ~~~~~~~~~~~~~~~~~~~~~~~*/
        c = Reflection.Child.class;
        f = c.getDeclaredField("f"); // член публичный
        f.isAccessible(); // false (для любого члена по дефолту стоит флаг "не доступен")
        f.set(new Child(), 3); // но фактически доступным все-равно членом можно пользоваться
        f.setAccessible(true);

        Child ch = new Reflection.Child();
        m = c.getDeclaredMethod("meth"); // публичный метод
        m.isAccessible(); // false (для любого члена по дефолту стоит флаг "не доступен")
        m.invoke(ch); // можно вызвать

        m = c.getDeclaredMethod("privateMeth"); // приватный метод
        m.isAccessible(); // false (для любого члена по дефолту стоит флаг "не доступен")
//        m.invoke(ch); // нельзя вызвать
        m.setAccessible(true);
        m.invoke(ch); // нельзя вызвать

        System.out.println("метод доступен: " + m.isAccessible());


        /* ~~~~~~~~~~~~~~~ПОЛУЧЕНИЕ ЧЛЕНОВ (КОНСТРУКТОРОВ, МЕТОДОВ, ПОЛЕЙ) КЛАССА ~~~~~~~~~~~~~~~*/
        c = Reflection.class;

        fa = c.getDeclaredFields(); // static java.lang.reflect.Modifier __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge.mod, etc

        f = c.getDeclaredField("mod"); // static java.lang.reflect.Modifier __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge.mod

        ma = c.getMethods(); // public static void __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge.reflection(java.lang.String[]), etc.
        ka = c.getConstructors(); // public __Implicit_Synthetic_Bridge.__Implicit_Synthetic_Bridge()


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~РАБОТА С ЧЛЕНАМИ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /*~~~~~~~~~~~~~~~~~~~~~~ПОЛЯ~~~~~~~~~~~~~~~~~~~~~~*/
        f = c.getDeclaredField("mod");

        /* УЗНАТЬ, СИНТЕЗИРОВАНО ЛИ ПОЛЕ ПРИ КОМПИЛЯЦИИ */
        f.isSynthetic(); // false

        /* УЗНАТЬ, ЯВЛЯЕТСЯ ЛИ ПОЛЕ ЭКЗЕМПЛЯРОМ ПЕРЕЧИСЛИМОГО ТИПА */
        f.isEnumConstant(); // false

        /* ПОЛУЧЕНИЕ ИНФОРМАЦИИ О ТИПЕ ПОЛЯ*/
        f = c.getDeclaredField("mod");
        f.getType(); // class java.lang.reflect.Modifier

        f = c.getDeclaredField("l");
        f.getType(); // interface java.util.List
        f.getGenericType(); // java.util.List<?>

        f = c.getDeclaredField("l2");
        f.getType(); // interface java.util.List
        f.getGenericType(); // java.util.List<java.lang.Integer>


        /* ПОЛУЧЕНИЕ И ОБРАБОТКА ИНФОРМАЦИИ О МОДИФИКАТОРАХ ПОЛЯ */
        Modifier.toString(f.getModifiers()); // static

        /* ПОЛУЧЕНИЕ И УСТАНОВКА ЗНАЧЕНИЯ В ПОЛЕ */
        f = c.getDeclaredField("i");
        Reflection reflection = new Reflection();

        /*ПОЛУЧЕНИЕ*/
        i = (Integer) f.get(reflection);

        /*УСТАНОВКА*/
        f.set(reflection, 44);

        /*~~~~~~~~~~~~~~~~~~~~~~МЕТОДЫ~~~~~~~~~~~~~~~~~~~~~~*/
        ma = c.getDeclaredMethods();
        m = c.getDeclaredMethod("meth", Integer.class, int[].class);

        /*ПОЛУЧЕНИЕ МОДИФИКАТОРОВ*/
        m.getModifiers(); // final

        /* ПОЛУЧЕНИЕ ПАРАМЕТРОВ */
        m.getParameters();

        /* ЗАПУСК МЕТОДА */
        m.invoke(reflection, 12345, new int[2]); // password is 12345, numbers are [0,0]


        /*~~~~~~~~~~~~~~~~~~~~~~КОНСТРУКТОРЫ~~~~~~~~~~~~~~~~~~~~~~*/
        class Inside {
            public Inside() {
                System.out.println("Default constructor");
            }

            public Inside(int i) {
                System.out.println("Constructor with params");
            }
        }
        c = Inside.class;

        /* ДЕФОЛТНЫЙ КОНСТРУКТОР */
        c.newInstance(); // Default constructor

        /* НЕДЕФОЛТНЫЙ КОНСТРУКТОР */
        k = c.getDeclaredConstructor(int.class);

        k.newInstance(5);


        /*~~~~~~~~~~~~~~~~~~~~~~МАССИВЫ~~~~~~~~~~~~~~~~~~~~~~*/
        c = Reflection.class;
        f = c.getDeclaredField("da");
        c = f.getType(); // [[D
        c.isArray(); // true

        /*УЗНАТЬ ТИП МАССИВА И ТИП КОМПОНЕНТОВ*/
        c.getName(); // [[D
        c.getComponentType(); // class [D

        /*УЗНАТЬ ДЛИНУ МАССИВА*/
        Array.getLength(da);

        /*~~~~~~~~~~~СОЗДАНИЕ НОВОГО МАССИВА, УСТАНОВКА И ЧТЕНИЕ ЗНАЧЕНИЙ ~~~~~~~~~~~*/
        /*СОЗДАНИЕ*/
        Object o = Array.newInstance(double.class, 2);

        /*УСТАНОВКА ЗНАЧЕНИЙ*/
        Array.set(o, 0, 2.3);
        Array.set(o, 1, 4.3);

        /*ЧТЕНИЕ ЗНАЧЕНИЙ*/
        Array.get(o, 1);
        System.out.println(Array.get(o, 1));


        /*~~~~~~~~~~~~~~~~~~~~~~ПЕРЕЧИСЛЕНИЯ~~~~~~~~~~~~~~~~~~~~~~*/
        c = Reflection.TestEnum.class;
        f = c.getDeclaredField("ONE");
        System.out.println(f.isEnumConstant());

        f = c.getDeclaredField("testEnum");

        c = f.getType(); // class __types_system.Reifiability$TestEnum
        c.isEnum(); // true

        /*ПОЛУЧИТЬ СПИСОК ВОЗМОЖНЫХ КОНСТАНТ */
        Arrays.asList(c.getEnumConstants()); // [ONE, TWO]
        System.out.println(Arrays.asList(c.getEnumConstants()));
    }


    public static final class Child<T, V> extends Reflection {
        public int f;
        private int pf;

        public void meth() {
            System.out.println("public method");
        }

        private void privateMeth() {
            System.out.println("private method");
        }

        class ChildOwnInner {
        }
    }

    public static class MainInner {
    }

    final void meth(Integer password, int[] numbers) {
        System.out.println("password is: " + password);
        System.out.println("numbers are: " + Arrays.toString(numbers));
    }
}