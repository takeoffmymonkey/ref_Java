package __types_system;

/* КЛАСС CLASS
 * - информация о любом классе (типе), используемом во время работы программы хранится в
 * соответствующем объекте типа Class
 *      - создается JVM из .class файла (скомпилированный байт-код), который создался при компиляции
 *          - для создания объектов используется подсистема "загрузчик классов"
 *              - это может быть цепочка загрузчиков, но всегда есть "первичный загрузчик классов"
 *                  - он загружает доверенные классы, включая J API, обычно c локального диска
 *          - все классы загружаются динамически при их первом использовании
 *              - при первом обращении к статическому члену класса
 *                  - напр. при помощи new к конструктору
 *                      - (хоть конструкторы и не имеет слова static)
 *                  - загрузчик проверяет, загружен ли объект Class для данного класса
 *                      - если нет - ищет файл .class
 *                          - внешний загрузчик же, напр. может считать байт-код из бд
 *                          - исполнительная система проверяет байт-код класс на целостность и
 *                          корректность
 *                          - если все ок, то объект Class появляется в памяти
 *                              - используется в дальнейшем для создания соответствующих объектов
 *
 * - объект класса Class используется во время работы для создания соотвтетствующий объектов
 *
 * - используется RTTI при преобразованиях
 *
 * - создание ссылки на объект Class синтаксисом .class не приводит к автоматической инициализации
 * объекта Class
 *      - а forName() приводит
 *
 * - static final может читаться без инициализации класса, если это константа времени выполнения (
 * напр. 47 или 2 + 2)
 *
 * - обращение к static без final можно только после компоновки
 *
 * - Class<T>: можно ограничить тип, на который указывает Class
 *      - т.е. я не смогу переназначить ссылку на другой тип
 *      - а Class<?> является эквивалентом просто Class
 *          - но ясно показывает, что ссылка на конкретный класс не используется случайно или по
 *          незнанию, а девелопер сознательно выбирает неконкретную версию
 * */


/* Подготовка класса к использованию состоит из 3 шагов
 * 1. Загрузка, выполняемая загрузчиком класса. Он находит байт-код (обычно, но не обязательно,
 * находится в каталогах CLASSPATH) и создает на его основе объект Class
 *
 * 2. Компоновка. Проверяется байт-код класса, выделяется память для статических полей, при
 * необходимости разрешаются все ссылки на другие классы, используемые текущим классом
 *
 * 3. Инициализация (откладывает до первого обращения к статическому методу (в т.ч. конструктору)).
 * Если у класса имеется родитель, выполняется его инициализация. Также выполняются статические
 * инициализаторы и блоки статической инициализации
 * */


/* ПОЛУЧЕНИЕ ОБЪЕКТОВ КЛАСС*/

public class Main {
    public Main() {
        System.out.println("В конструкторе Main");
    }

    static {
        System.out.println("В статическом блоке Main");
    }


    public static void main(String[] args) {
        System.out.println("В статическом методе класса Main");

        System.out.println("Создание объекта Main");
        Main m = new Main();


//        System.out.println("Поиск класса A");
//        Class c1 = null;
//        try {
//            c1 = Class.forName("A"); // класса еще нет!
//        } catch (ClassNotFoundException e) {
//            e.printStackTrace();
//        }

        System.out.println("Получение ссылки на объект Class класса A");
        Class c = A.class;
        if (c == null) System.out.println("Ссылка == null");

        System.out.println("Создание объекта А");
        A a = new A();
    }

}

class A {
    public A() {
        System.out.println("В конструкторе класса A");
    }

    static {
        System.out.println("В статическом блоке класса A");
    }
}