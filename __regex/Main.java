package __regex;


import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import types_references_annotations.my_annotations.Ntrstn;


/* РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
 * - способ описать текст, основываясь на его общих характеристиках
 *
 * - используются для поиска, изменения или валидации текста
 *
 * - выражаются при помощи специального синтаксиса
 *      - схож с синтаксисом в Perl
 *
 * - API для работы с ними находится в пакете java.util.regex:
 *      - Pattern: скомпилированное представление РВ
 *      - Matcher: производит операции сверки для последовательности символов, интерпретируя паттерн
 *      - {MatchResult}: результат операции сверки
 *      - PatternSyntaxException: непроверяемое исключение для указания синтаксической ошибки в
 *      паттерне
 *      - часть методов валидации и замены текста из классов Pattern и Matcher дублируются классом
 *      String
 *          - чтобы избежать создания объектов Pattern и Matcher
 *
 * - С J7 поддерживается Unicode 6.0
 *      - кодовые точки
 *      - свойства символов*/


/*~~~~~~~~~~~~~~~~~~~~PATTERN - СКОМПИЛИРОВАННОЕ ПРЕДСТАВЛЕНИЕ РВ~~~~~~~~~~~~~~~~~~~~
 * - нет публичного конструктора
 *      - для получения объекта, нужно вызвать Pattern.compile(String regex), передав РВ
 *
 * - в перегруженную версию Pattern.compile(String regex, int flag) можно также передавать флаги
 *      - определяют поведение при сверке
 *      - флагов может быть несколько:
 *          - перечисляются через | */


/* ОСНОВНЫЕ ФЛАГИ МЕТОДА PATTERN.COMPILE()
 * - CASE_INSENSITIVE: включает игнорирование регистра
 *      - по дефолту включает игнорирование только для US-ASCII
 *          - для Unicode нужен дополнительный флаг UNICODE_CASE
 *      - альтернатива - использовать встроенный флаг (?i) прямо в выражении
 *          - напр. (?i)foo
 *
 * - COMMENTS: позволяет присутствовать в паттерне пробелам и комментариям, игнорируя их
 *      - альтернатива - (?x)
 *
 * - todo MULTILINE: включает многострочный режим
 *      - т.е. ^ и $ работают для каждой строки, а не для всего ввода
 *      - альтернатива - (?u) */


/* ОСНОВНЫЕ МЕТОДЫ PATTERN
 * - compile(String regex): компилирует предоставленное РВ в паттерн
 *      - compile(String regex, int flags): то же, но с учетом флагов
 *
 * - matches(String regex, String str): производит сравнение без создания объекта Matcher
 *      - напр. Pattern.matches("\\d", "1");
 *
 * - split(CharSequence input): делит вводимую строку по регулярному выражению на массив строк
 *      - напр.
 *          Pattern p = Pattern.compile("\\d");
            String[] items = p.split("one9two4three7four1five"); // массив отдельных слов
 *
 * - toString(): вернет строкой РВ, из которого сделан паттерн
 *
 * - todo quote(String s): вернет в виде строки шаблон, который подходит для введенного текста
 *      - напр. для 123xxxAAA вернет \Q123xxxAAA\E */


/* АНАЛОГИЧНЫЕ МЕТОДЫ ИЗ STRING
 * - matches(): аналогично
 * - split(): аналогично */



/* ~~~~~~~~~MATCHER - ДВИЖОК ДЛЯ СВЕРКИ ШАБЛОНА С ПОЛУЧЕННОЙ СТРОКОЙ И ПОСЛЕДУЮЩИХ ДЕЙСТВИЙ~~~~~~~~~
 * - нет публичного конструктора
 *      - для получения объекта, нужно вызвать matcher() на объекте Pattern */


/* ОСНОВНЫЕ ГРУППЫ МЕТОДОВ MATCHER
 * - методы изучения:
 *      - matches(): пытается сверить весь(!) текст с выражением
 *          - т.е. если со всем выражением совпадает только часть текста, это не считается совпадением
 *
 *      - find(): пытается найти следующий подходящий под паттерн отрезок текста в введенном тексте
 *          - т.е. если не был перезагружен (reset()), начинает поиск с места, где закончил в
 *          прошлый раз
 *              - является пошаговым и используется в цикле while в качестве условия
 *          - find(int index): перезагрузить поиск и начать с указанного индекса символа
 *
 *      - lookingAt(): сверяет введенный текст с паттерном, начиная с начала текста
 *          - т.е. совпадать всему тексту не обязательно!
 *              - в отличие от matches()
 *
 * - индексные методы:
 *      - start(): вернет стартовый индекс последнего совпадения
 *          - start(int group): вернет начальный индекс отрезка, захваченного указанной группой при
 *          предыдущей операции сверки
 *
 *      - end(): вернет индекс, следующий за последним совпадением
 *          - end (int group): вернет индекс последнего символа (+1) отрезка, захваченного указанной
 *          группой при предыдущей операции сверки
 *
 *
 *  - методы для работы с группами:
 *      - groupCount(): вернет количество групп в РВ
 *          - при этом нулевая группа, т.е. все выражение, не учитывается
 *
 *      - group (int group): возвращает отрезок, захваченный указанной группой при предыдущей
 *      операции сверки
 *
 *
 * - методы замены:
 *      - replaceAll(String replacement): заменяет предоставленной строкой каждый отрезок в тексте,
 *      который совпадает с шаблоном
 *
 *      - replaceFirst(String replacement): заменяет предоставленной строкой первый отрезок в тексте,
 *      который совпадает с шаблоном */


/* АНАЛОГИЧНЫЕ МЕТОДЫ ИЗ STRING
 * - replaceFirst(String regex, String replacement): аналогично
 * - replaceAll(String regex, String replacement): аналогично */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~PATTERNSYNTAXEXCEPTION~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - предназначен для иключения, указывающего на синтаксические проблемы в РВ
 *      - но IDE предупреждает о проблемах еще на стадии компиляции
 *
 * - является непроверяемым
 *      - т.е. не нужно обрамлять try-catch блоком */


/* МЕТОДЫ PATTERNSYNTAXEXCEPTION
 * - getDescription(): получить описание ошибки
 * - getIndex(): получить индекс ошибки
 * - getPattern(): получить паттерн, в котором находится ошибка
 * - getMessage(): получить многострочную строку с описанием синтаксической ошибки и ее индекса, а
 * также проблемный паттерн и визуальное указание на ошибку в паттерне*/



/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~СИНТАКСИС~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* ~~~~~~~~~~~~~~~~~~~~~~~~СИМВОЛЫ~~~~~~~~~~~~~~~~~~~~~~~~
 * B: символ В
 * \xhh: символ с 16-ричным кодом 0xhh
 * \\uhhhh: символ Unicode с 16-ричным представлением 0xhhhh
 * \t: символ табуляции
 * \n: символ перехода на новую строку
 * \r: символ возврата курсора
 * \f: символ подачи страницы
 * \e: escape-символ */


/* КЛАССЫ (ТИПЫ) СИМВОЛОВ - НАБОР СИМВОЛОВ В КВАДРАТНЫХ СКОБКАХ ДЛЯ СВЕРКИ С 1 СИМВОЛОМ В СТРОКОВОМ
 * ВВОДЕ
 * - [abc]: простой класс
 *      - совпадает с: a, b, c
 *      - синоним: [a|b|c]
 *
 * - [^abc]: отрицание
 *      - совпадает с: любым символом, кроме a, b, c
 *
 * - [a-zA-Z]: диапазон
 *      - совпадает с: любым символом от а до z или от A до Z (влючительно)
 *
 * - [a-d[m-p]]: объединение
 *      - совпадает с: любым символом от а до d или от m до p
 *      - синоним: [a-dm-p]
 *
 * - [a-z&&[def]]: пересечение
 *      - совпадает с: d, e, f
 *
 * - [a-z&&[^bc]]: вычитание
 *      - совпадает с: любым символом от а до z, кроме b и с
 *      - синоним: [ad-z]
 *
 * - [a-z&&[^m-p]]: вычитание
 *      - совпадает с: любым символом от а до z, кроме диапазона от m до p
 *      - синоним: [a-lq-z]*/


/* ПРЕДУСТАНОВЛЕННЫЕ КЛАССЫ СИМВОЛОВ (В PATTERN API) - УДОБНЫЕ СОКРАЩЕНИЯ ДЛЯ КЛАССОВ СИМВОЛОВ
 * - все, что начинается с обратной черты, нужно дополнительно экранировать обратной чертой в коде:
 *      - напр. вместо \d использовать \\d
 *
 * - .: любой символ
 * - \d: любая цифра (аналогично [0-9])
 * - \D: любая нецифра (аналогично [^0-9])
 * - \s: любой символ с пустотой (аналогично [\t\n\x0B\f\r])
 * - \S: любой непустой символ (аналогично [^\s])
 * - \w: любой символ в слове (аналогично [a-zA-Z_0-9])
 * - \W: любой символ в неслове (аналогично [^\w])*/


/* POSIX (ТОЛЬКО ДЛЯ US-ASCII)
 * - \p{Lower}: любой буквенный символ в нижнем регистре (аналогично [a-z])
 * - \p{Upper}:	любой буквенный символ в верхнем регистре (аналогично [A-Z])
 * - \p{ASCII}:	все символы ASCII (аналогично[\x00-\x7F])
 * - \p{Alpha}:	любой буквенный символ в любом регистре (аналогично [\p{Lower}\p{Upper}])
 * - \p{Digit}:	любой цифровой символ: (аналогично[0-9])
 * - \p{Alnum}:	любой буквенно-цифровой символ (аналогично[\p{Alpha}\p{Digit}])
 * - \p{Punct}:	любой символ пунктуации (аналогично[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~]
 * - \p{Graph}:	любой отображаемый символ (аналогично[\p{Alnum}\p{Punct}])
 * - \p{Print}:	любой печатный символ (аналогично[\p{Graph}\x20])
 * - \p{Blank}:	символы пробела или табуляции (аналогично[ \t])
 * - \p{Cntrl}:	любой управляющий символ (аналогично[\x00-\x1F\x7F])
 * - \p{XDigit}: любой 16-ричный символ (аналогично[0-9a-fA-F])
 * - \p{Space}:	любой символ с пустотой (аналогично[ \t\n\x0B\f\r])*/


/*~~~~~~~~~~~~~~~~~~~~~~~~ЗАХВАТ ГРУППЫ И ОБРАТНАЯ ССЫЛКА~~~~~~~~~~~~~~~~~~~~~~~~
 * - способ объединить несколько символов в 1 группу в рамках одних скобок, чтобы в последствии с
 * ней работать (как с переменной)
 *      - во время сверки каждый совпадающий с группой отрезок сохраняется
 *          - например, чтобы:
 *              - указать, что для совпадения текст из одной группы должен соответствовать тексту из
 *              другой
 *              - поменять местами текст 2 разных групп
 *
 * - с группой можно работать по
 *      - номеру:
 *          - дается автоматически
 *              - нумерация идет по открывающимся скобкам
 *                  - т.е. для ((A)(B(C))):
 *                      0. все выражение
 *                          - т.е. то же, что и 1
 *                          - не учитывается методом groupCount()
 *                      1. ((A)(B(C)))
 *                      2. (A)
 *                      3. (B(C))
 *                      4. (C)
 *
 *      - имени:
 *          - указывается вручную: (?<groupname>regex)
 *              - напр. (?<my>aba)
 *          - первый символ в должен быть буквенным
 *
 *
 * - к группе можно обращаться в:
 *      - результате сверки
 *          - как по имени, так и по номеру
 *              - напр. replaceAll(${my}) или replaceAll($1)
 *
 *      - самом регулярном выражении (т.н backreferencing)
 *          - как по имени, так и по номеру:
  *              - напр. \\k<my> или \1
 *
 * - напр. (\d\d) определяет одну захваченную группу, которая соответствует 2 цифрам подряд
 *      - чтобы было совпадение для 2 цифр, после которых идут эти же цифры, нужно такое РВ:
 *          (\d\d)\1
 *              - тогда для "1212" будет совпадение
 *              - а для "1234" нет
 *              - \1 здесь ссылка на группу под номером 1
 *
 * - некоторые методы Matcher принимают на вход номер группы
 *      - start(), end(), group()
 *
 * - todo группы, которые начинаются с (?:, явлюются чистыми незахватывающими группами
 *      - т.е. когда нужно, чтоб они игнорировались паттерном - не захватывался совпадающий текст и
 *      не добавлялись в общее число групп */


/* ~~~~~~~~~~~~~~~~~~~~~~~~КВАНТИФИКАТОРЫ~~~~~~~~~~~~~~~~~~~~~~~~
 * - указывают количество необходимых вхождений для сверки
 *
 * - можно указывать для отдельных символов, классов символов и групп
 *      - "abc+" - только для символа с
 *      - [abc]+ - для каждого символа в классе
 *      - (abc)+ - для всей группы */


/* ВИДЫ КВАНТИФИКАТОРОВ (НА ПРИМЕРЕ КВАНТИФИКАТОРОВ ДЛЯ СИМВОЛА)
 * - X?: 0 или 1 раз
 *      - ищет совпадение для указанного символа и для нулевой длины в конце (см. совпадения нулевой
 *      длины)
 *          - т.е. при "а?" будет искать пристутствие или отсутствие в проверяемом символе символа
 *          "а":
 *              - для "aaaaa" будет 6 совпадений ("a"[1]"a"[2]"a"[3]"a"[4]"a"[5]""[6])
 *              - для "abaaaab" при будет 8 совпадений ("a"[1]""[2]"b""a"[3]"a"[4]"a"[5]"a"[6]""[7]"b"""[8])
 *
 * - X*: 0 или более
 *      - ищет совпадение для всех встреч указанного символа и для нулевой длины в конце
 *          - т.е. при "а*" будет искать присутствие группы символов "а" или их отстутствие
 *              - для "aaaaa" будет 2 совпадения ("aaaaa"[1]""[2])
 *              - для "abaaaab" будет 5 совпадений ("a"[1]""[2]"b""aaaa"[3]""[4]"b"""[5])
 *
 * - X+: 1 или более
 *      - ищет совпадение для всех встреч указанного символа (пока не встретится другой) и без
 *      нулевой длины в конце
 *          - т.е. при "а+" будет искать присутствие группы ненулевой длины из символов "а"
 *              - для "aaaaa" будет 1 совпадение ("ааааа"[1])
 *              - для "abaaaab" будет 2 совпадения ("a"[1]b"aaaa"[2]b)
 *
 * - X{n}: ровно n раз
 *      - ищет совпадение для всех встреч указанного символа (пока не встретится другой) указанное
 *      количество раз
 *          - т.е. при "а{3}" будет искать присутствие группы символов "а" длиной в 3 символа
 *              - для "aaaaaaaa" будет 2 совпадения ("aaa"[1]"aaa"[2]aa)
 *
 * - X{n,}: не менее n раз
 *      - ищет совпадение для всех встреч указанного символа (пока не встретится другой) не меньше
 *      указанного количества раз
 *          - т.е. при "а{3,}" будет искать присутствие группы символов "а" длиной от 3 символов
 *              - для "aaaaaaaa" будет 1 совпадения ("aaaaaaaa"[1])
 *
 * - X{n,m}: не менее n, но не более m раз
 *      - ищет совпадение для всех встреч указанного символа (пока не встретится другой) в
 *      соответствии с указанным диапазоном раз
 *          - т.е. при "а{3,4}" будет искать присутствие группы символов "а" длиной от 3 до 4 символов
 *              - для "aaaaaaaaaaa" будет 3 совпадения ("aaaa[1]aaaa"[2]aaa[3])*/


/* СОВПАДЕНИЯ НУЛЕВОЙ ДЛИНЫ
 * - происходят для квантификаторов, подразумевающих присутствие символа 0 раз
 *      - напр. для ? или *
 *
 * - встречаются:
 *      - в пустой строке
 *      - в конце совпадения
 *      - в конце строки
 *
 * - напр. при "а*" для строки "abaaaab" будет всего 5 совпадений:
 *      "a"[1]""[2]"b""aaaa"[3]""[4]"b"""[5] */


/* АЛГОРИТМЫ КВАНТИФИКАТОРОВ
 * - для квантификаторов с неограниченным количеством повторов способ установить алгоритм сверки
 *      - для X*, X+, X{n,}
 *
 * - возьмем за пример условие ".*foo" для строки "xfooxxxxxxfoo"
 *      - т.е. ищется любой символ, присутствующий любое количество раз, после чего должны идти
 *      символы f, o и o
 *
 * - жадный:
 *      - сначала съедает все, что подходит под квантификатор
 *          - т.е. при начале совпадения съедается вся оставшаяся строка, а проверка f, o и  o не
 *          успевает осуществиться
 *              - на данном этапе совпадения нет, потому что совпало только .*, а вся строка уже
 *              использована
 *      - затем идет посимвольно с конца строки
 *          - и доходит до начала строки, где находится оставшаяся часть совпадения
 *              - т.е. foo
 *      - итого: 1 совпадение "xfoo" c началом в индексе 0
 *
 * - ленивый (противоположен жадному; имеет дополнительный ? в конце):
 *      - начинает идти посимвольно с начала строки
 *          - находится первое совпадение "xfoo" в диапазоне [0-4]
 *          - находится второе совпадение "xxxxxxfoo" в диапазоне [4-13]
 *      - последней идет сверка всей строки
 *          - совпадений не находится
 *      - итого: 2 совпадения
 *
 * - ревнивый (аналогичен жадному, но без повторного прохождения; имеет дополнительный + в конце):
 *      - съедает все, что подходит под квантификатор
 *          - совпадений не находится
 *      - используется для оптимизации скорости */


/* ~~~~~~~~~~~~~~~~~~УКАЗАНИЕ УСЛОВИЯ МЕСТА ДЛЯ СОВПАДЕНИЯ (ДЛЯ FIND(), A НЕ MATCH())~~~~~~~~~~~~~~~~~~
 * - ^: чтобы считаться совпадением, совпавший с РВ отрезок текста должен находится в начале строки
 *      - "^dog" для "dog that plays" - есть совпадение
 *      - "^dog" для "the dog plays" - нет совпадения
 *
 * - $: в конце строки
 *      - "dog$" для "the playing dog" - есть совпадение
 *      - "dog$" для "the dog plays" - нет совпадения
 *
 * - \b: в рамках слова
 *      - "\bdog\b" для "The dog plays" - есть совпадение
 *      - "\bdog\b" для "The doggie plays" - нет совпадения
 *
 * - \B: в рамках неслова
 *      - "\bdog\B" для "The doggie plays" - есть совпадение
 *      - "\bdog\B" для "The dog plays" - нет совпадения
 *
 * - \A: в начале ввода
 *
 * - \G: в конце предыдущего совпадения
 *      - "dog" для dog dog - 2 совпадения
 *      - "\Gdog" для dog dog - 1 совпадение
 *
 * - \Z: в конце ввода, но для конечного прерывателя (final terminator), если таковой имеется
 *
 * - \z: в конце ввода */


@Ntrstn("Регулярное выражение позволяет на специальном языке задать шаблон, который описывает " +
        "некоторое условие, по которому будет производится поиск в тексте. Сам шаблон позволяет " +
        "описывать текст, основываясь на его каких-то общих характеристиках. Затем этот шаблон " +
        "направляется на желаемый текст, и в нем производится поиск мест, которые соответствуют " +
        "заданному в шаблоне условию. При помощи дополнительных средств (методов специального класса " +
        "в Java) с этими местами можно произвести желаемые действия - например, заменить их на " +
        "другой текст или разбить текст на массив в местах, где происходит совпадение шаблону. Кроме " +
        "того, сам факт совпадения можно использовать для определения, имеет ли весь текст " +
        "необходимую форму (например, является ли этот текст имейлом или IP-адресом) - т.е. для " +
        "валидации его формата")

@Ntrstn("Понятия регулярное выражение, паттерн и шаблон по своей сути являются синонимами (из " +
        "регулярного выражения получается шаблон (паттерн) для осуществления поиска)")

@Ntrstn("В Java язык регулярных выражений является надстройкой, работающей поверх Java при помощи " +
        "API в пакете java.util.regex (а также некоторых дублирующих методов из класса String), а " +
        "IDE умеет его по-особому подсвечивать")

@Ntrstn("Синтаксис регулярного выражения состоит из следующий конструкций:" +
        "1 - символ/специальный символ: указывает искомый в тексте символ. Напр. x соответствует x, " +
        "а \\t - табуляция (чтобы корректно обрабатывать символы, требующие обратную черту, их нужно " +
        "дополнительно экранировать обратной чертой)" +
        "2 - классы (не как в Java) символов: набор символов в квадратных скобках для сверки с 1 " +
        "символом в тексте - например [abc] означает, что ищется 1 символ, который может быть либо a, " +
        "либо b, либо с. У этих классов есть специальные знаки, обозначающие дополнительные условия - " +
        "например,  [^0-3] означает, что ищется любой цифровой символ, который не находится в " +
        "диапазоне от 0 до 3." +
        "3 - предустановленные классы символов: то же, что и предыдущее, но имеет сокращенный " +
        "синтаксис для распространенных условий - например \\d означает, что ищется любой цифровой " +
        "символ (аналог [0-9]), а в виде POSIX то же самое записывается как \\p{Digit}. Иногда POSIX " +
        "имеет более короткую форму (но работает только для US-ASCII). Всегда стоит предпочитать " +
        "предустановленные классы простым!" +
        "4 - захват группы: способ объединить несколько символов в 1 группу в рамках одних скобок, " +
        "чтобы потом с ней работать (совпавший текст сохраняется), обращаясь по номеру группы или " +
        "по данному ей имени. Например, (abc(de)) означает, что есть 2 группы (номер считается по " +
        "открывающейся скобке (также есть нулевая группа - все выражение)) и совпадением, например, " +
        "для второй группы (de) будет считаться символы de в тексте. В самом регулярном выражении " +
        "можно ссылаться на группу как будто по переменной (т.н. backreferencing) - напр. (\\d\\d)\\1 " +
        "(где 1 - номер группы) будет означать, что при сверке первые 2 цифры запомнятся и следующие " +
        "2 цифры должны с ними точно совпадать, чтобы совпадение было засчитано. Также можно к " +
        "найденному тексту обращаться, например, в методе замены - чтобы, например, поменять тексты " +
        "2 групп: replaceAll(${mygroupA}${mygroupB})" +
        "5 - квантификаторы: указывают количество раз, которому должно удовлетворять искомое условие. " +
        "Можно указывать для символов, классов символов и для групп. Например x* означает, что " +
        "символ x может быть любое количество раз (даже 0) для совпадения с условием." +
        "6 - условие, в каком месте должно искаться совпадение: т.е. часть текста полностью " +
        "совпадает с регулярным выражением, но находится не в указанном месте, то это совпадение не " +
        "засчитывается. Напр. для выражения what$ для текста what what совпадением будет считаться " +
        "только последнее what")

@Ntrstn("Из-за того, что некоторые квантификаторы (напр. ? или *) позволяют символу присутствовать 0 " +
        "раз, чтобы считаться совпадением, в некоторых местах, где отстутсвуют видимые символы, " +
        "будут происходить совпадения, при этом длина такого совпадения будет равняться 0. Такое " +
        "происходит в пустой строке, в конце совпадения в непустой строке и в конце строки. Т.е. для " +
        "условия a* со строкой ababaaaab, будут следующие совпадения: (a)[1]()[2](b)(aaaa)[3]()[4](b)()[5]")

@Ntrstn("Также для квантификаторов, у которых количество в условии точно не указано (напр. условие " +
        ".*foo), могут использовать разные алгоритмы сверки, в результате чего можно получить разные " +
        "итоговые результаты совпадений. Жадный (дефолтный) алгоритм, после того как началось " +
        "совпадение, пытается сверить всю оставшуюся часть строки (т.к. * - значит любое количество " +
        "раз), а затем идет с конца строки посимвольно до места совпадения, пытаясь сверить " +
        "оставшуюся часть условия, которая шла после квантификатора. Ленивый алгоритм (с " +
        "дополнительным символом ? в конце) является противоположностью жадного - с момента начала " +
        "совпадения он посимвольно идет до конца, обнаруживая по пути все подходящие совпадения, а " +
        "затем сверяет весь отрезок - от начала совпадения до конца строки. Ревнивый алгоритм (с " +
        "дополнительным + в конце) аналогичен жадному, но не делает посимвольной проверки, после " +
        "того как проверит весь отрезок - от начала совпадения и до конца строки. Данный алгоритм " +
        "существует только в Java и используется с целью оптимизации времени поиска")

@Ntrstn("Классический способ работы с регулярными выражениями в Java заключается в использовании 2 " +
        "специальных классов - Pattern и Matcher. Класс Pattern предназначен для работы с самим " +
        "регулярным выражением, а класс Matcher применяет описанный шаблон к указанному тексту и " +
        "прендазначен для работы с найденными совпадениями. Кроме этих классов в пакете " +
        "java.util.regex также есть класс PatternSyntaxException для работы с исключениями, которые " +
        "вызываются при неправильно заданном регулярном выражении (т.е. при некорректном синтаксисе" +
        " - хотя IDE отлично справляется с этой работой, предупреждая о проблемах на стадии " +
        "компиляции). Но кроме этих классов, класс String также обладает некоторыми методами, " +
        "дублирующими методы классов Pattern и Matcher")

@Ntrstn("У обоих классов - Pattern и Matcher - нет конструкторов. Сначала создается объект Pattern " +
        "от статического метода Pattern.compile(String regex), куда на вход передается регулярное " +
        "выражение в виде простой строки (т.е. компилируется шаблон). Затем от этого объекта при " +
        "помощи метода matcher(String text), примимающего на вход текст, где будет производится " +
        "поиск, создается объект Matcher. Все манипуляции с местами в тексте, которые совпадают с " +
        "заданным шаблоном будут производится при помощи этого класса")

@Ntrstn("Метод Pattern.compile(String regex) имеет перегруженную версию " +
        "Pattern.compile(String regex, int flags), которая дополнительно принимает флаги, способные " +
        "модифицировать условия для поиска - например, при поиске игнорировать регистр. Флаги можно " +
        "перечислять при помощи | (битового ИЛИ). Кроме того, большинство флагов имеют синонимы в " +
        "виде специальных символов, которые можно и просто указать в самих регулярных выражениях")

@Ntrstn("Когда достаточно просто провалидировать формат (всего!) текста, то это можно сделать 3 " +
        "способами: " +
        "1 (классический) - при помощи метода matches() от объекта Matcher. Для этого сначала должен " +
        "быть создан объект класса Pattern" +
        "2 (быстрый) - при помощи статического метода метода Pattern.matches(String regex, String text) " +
        "без необходимости создавать объект класса Matcher" +
        "3 (быстрый) - при помощи метода string.matches(String regex), примененного к строковому " +
        "объекту.")

@Ntrstn("Методы класса Matcher, можно условно разделить на несколько групп: " +
        "1 - методы изучения: ищут совпадения по паттерну в тексте. Искать совпадения можно для " +
        "всего текста или для его куска. Также можно переходить по совпадениям" +
        "2 - индексные методы: возвращают начальный и конечный (+1) индексы последнего совпадения. " +
        "Но перед этим должен быть совершен поиск, иначе будет выброшено исключение " +
        "IllegalStateException: No match available. Также есть возможность получить индексы " +
        "последнего вхождения для определенной группы" +
        "3 - методы групп: возвращают количество групп, указанных в регулярном выражении, либо " +
        "нужную группу в виде строки" +
        "4 - методы замены: заменяют совпадения в тексте другой предоставленной строкой")

@Ntrstn("Методы matches() (класс Matcher) и lookingAt() ищут совпадения в тексте по шаблону, но " +
        "метод matches() вернет true, только если с шаблоном совпадает весь текст, тогда как метод " +
        "lookingAt() вернет true и для отрезка текста, поскольку он просто начинает искать " +
        "совпадения с начала текстового диапазона.")

@Ntrstn("В отличие от методов matches() и lookingAt(), которые всегда начинают работать с начала " +
        "текста, метод find() начинает поиск с того места, где завершилось последнее вхождение (или " +
        "с начала, если до этого не запускался или не была совершена перезагрузка методом reset()). " +
        "Т.е. по сути, это удобный метод, чтобы переходить с одного вхождения на следующее в цикле. " +
        "Можно также указать индекс с символа, с которого нужно начинать поиск совпадения")

@Ntrstn("Методы класса String дублируют методы Pattern: поиск совпадений и разбивание строки на " +
        "массив в местах совпадений. Также они дублируют методы замены совпадений из класса Matcher")

@Ntrstn("Методы класса PatternSyntaxException позволяют отдельно получить описание, индекс ошибки и " +
        "сам проблемный паттерн. А метод getMessage() сочетает всю эту информацию")

public class Main {

    static String regex;
    static String text;
    static Pattern p;
    static Matcher m;

    static void updateMatcher() {
        p = Pattern.compile(regex);
        m = p.matcher(text);
    }

    static void updateMatcherAndFind() {
        updateMatcher();
        m.find();
    }

    public static void main(String[] args) {
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ СИНТАКСИС ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        System.out.println("СИНТАКСИС");

        /*~~~~~~~~~~~~~~СИМВОЛЫ~~~~~~~~~~~~~~~~*/
        System.out.println("СИМВОЛЫ");

        /*ПРОСТЫЕ И СПЕЦИАЛЬНЫЕ СИМВОЛЫ*/
        System.out.println("ПРОСТЫЕ И СПЕЦИАЛЬНЫЕ СИМВОЛЫ");
        System.out.println("Простой символ: " + "t".matches("t")); // true
        System.out.println("Символ табуляции: " + "\t".matches("\\t")); // true

        /*КЛАССЫ СИМВОЛОВ*/
        System.out.println("КЛАССЫ СИМВОЛОВ");
        System.out.println("Простой класс (любой из указанных символов): "
                + "t".matches("[ost]")); // true
        System.out.println("Диапазон+объединение+отрицание+пересечение (любой символ от a до z, при " +
                "этом он не должен входить в диапазон от m до p): "
                + "t".matches("[a-z&&[^m-p]]")); // true

        /*ПРЕДУСТАНОВЛЕННЫЕ КЛАССЫ СИМВОЛОВ*/
        System.out.println("ПРЕДУСТАНОВЛЕННЫЕ КЛАССЫ СИМВОЛОВ");
        System.out.println("Любая цифра: " + "4".matches("\\d")); // true
        System.out.println("Любая цифра (в POSIX): " + "4".matches("\\p{Digit}")); // true


        /*~~~~~~~~~~~~~~ЗАХВАТ ГРУППЫ~~~~~~~~~~~~~~~~*/
        System.out.println("ЗАХВАТ ГРУППЫ");
        regex = "(a(ba)){2}";
        text = "abaaba";
        updateMatcher();
        System.out.println("паттерн соответствует: " + m.matches()); // true
        System.out.println("вторая группа: " + m.group(2)); // ba

        /*ОБРАТНАЯ ССЫЛКА*/
        System.out.println("ОБРАТНАЯ ССЫЛКА");
        regex = "(\\d\\d){2}"; // без обратной ссылки значения цифр не учитываются
        text = "1112";
        updateMatcher();
        System.out.println("без обратной ссылки значение цифр не учитывается: "
                + m.matches()); // true

        regex = "(?<my> \\d\\d)\\k<my>"; // с обратной ссылки значения цифр учитываются
        text = "1112";
        updateMatcher();
        System.out.println(m.matches()); // false
        text = "1111";
        updateMatcher();
        System.out.println(m.matches()); // true

        /* РУЧНОЕ НАЗНАЧЕНИЕ ИМЕНИ */
        System.out.println("РУЧНОЕ НАЗНАЧЕНИЕ ИМЕНИ");
        regex = "(?<my>aba)";
        text = "abaaba";

        /* ОБРАЩЕНИЕ С РЕЗУЛЬТАТОМ */
        System.out.println("ОБРАЩЕНИЕ С РЕЗУЛЬТАТОМ");
        updateMatcher();
        text = m.replaceAll("(${my})"); // даст (aba)(aba)
        System.out.println(text);

        /*~~~~~~~~~~~~~~КВАНТИФИКАТОРЫ~~~~~~~~~~~~~~~~*/
        /*~~~~~КВАНТИФИКАТОР ДЛЯ СИМВОЛА~~~~~*/
        System.out.println("КВАНТИФИКАТОР ДЛЯ СИМВОЛА");
        System.out.println("b".matches("a?")); // false (другой вообще символ)
        System.out.println("".matches("a*")); // true (0 или более)
        System.out.println("".matches("a+")); // false (1 или более)
        System.out.println("aaa".matches("a{3}")); // true (ровно 3)
        System.out.println("aaaaa".matches("a{3,}")); // true (3 и больше)
        System.out.println("aaaaa".matches("a{1,6}")); // true (от 1 до 6)

        /*~~~~~КВАНТИФИКАТОР ДЛЯ КЛАССА СИМВОЛОВ~~~~~*/
        System.out.println("КВАНТИФИКАТОР ДЛЯ КЛАССА СИМВОЛОВ");
        System.out.println("aba".matches("[ab]{3}")); // true (ровно 3 раза 1 из указанных)

        /*~~~~~КВАНТИФИКАТОР ДЛЯ ЗАХВАЧЕННОЙ ГРУППЫ~~~~~*/
        System.out.println("КВАНТИФИКАТОР ДЛЯ ЗАХВАЧЕННОЙ ГРУППЫ");
        System.out.println("abaaba".matches("(aba){2}")); // true (ровно 2 раза указанная группа)

        /*~~~~~АЛГОРИТМЫ КВАНТИФИКАТОРОВ~~~~~*/
        System.out.println("АЛГОРИТМЫ КВАНТИФИКАТОРОВ");
        /* ЖАДНЫЙ (ДЕФОЛТНЫЙ) - проверяет сразу все, что идет после квантификатора, затем идет
         * посимвольно с конца*/
        System.out.println("ЖАДНЫЙ (ДЕФОЛТНЫЙ) АЛГОРИТМ КВАНТИФИКАТОРОВ");
        text = "xfooxxxxxxfoo";
        regex = ".*foo";
        updateMatcher();
        int count = 0;
        while (m.find()) {
            count++;
        }
        System.out.println("Количество совпадений (жадный): " + count); // 1 совпадение

        /* ЛЕНИВЫЙ - идет посимвольно сначала, затем проверяет целой всю строку*/
        System.out.println("ЛЕНИВЫЙ АЛГОРИТМ КВАНТИФИКАТОРОВ");
        regex = ".*?foo";
        updateMatcher();
        int count2 = 0;
        while (m.find()) {
            count2++;
        }
        System.out.println("Количество совпадений (ленивый): " + count2); // 2 совпадения


        /* РЕВНИВЫЙ - проверяет сразу все, что идет после квантификатора, без последующего
         * посимвольного прохода*/
        System.out.println("РЕВНИВЫЙ АЛГОРИТМ КВАНТИФИКАТОРОВ");
        regex = ".*+foo";
        updateMatcher();
        int count3 = 0;
        while (m.find()) {
            count3++;
        }
        System.out.println("Количество совпадений (ревнивый): " + count3); // 0 совпадений


        /*~~~~~ СОВПАДЕНИЯ НУЛЕВОЙ ДЛИНЫ ~~~~~*/
        System.out.println("СОВПАДЕНИЯ НУЛЕВОЙ ДЛИНЫ");
        regex = "a*";
        /*В ПУСТОЙ СТРОКЕ*/
        text = "";
        updateMatcher();
        int c = 0;
        while (m.find()) {
            c++;
            System.out.println("найдено совпадение: начало: " + m.start() + ", конец: " + m.end());
        }
        System.out.println("Всего найденных совпадений: " + c); // 1 (начало: 0, конец: 0)

        /* В КОНЦЕ СОВПАДЕНИЯ И В КОНЦЕ СТРОКИ*/
        text = "abaaab";
        updateMatcher();
        int c1 = 0;
        while (m.find()) {
            c1++;
            System.out.println("найдено совпадение: начало: " + m.start() + ", конец: " + m.end());
        }
        System.out.println("Всего найденных совпадений: " + c1); //5
        /* начало: 0, конец: 1
         * найдено совпадение: начало: 1, конец: 1
         * найдено совпадение: начало: 2, конец: 5
         * найдено совпадение: начало: 5, конец: 5
         * найдено совпадение: начало: 6, конец: 6*/


        /*~~~~~~~~~~~~~~УКАЗАНИЕ МЕСТА СОВПАДЕНИЯ~~~~~~~~~~~~~~~~*/
        System.out.println("УКАЗАНИЕ МЕСТА СОВПАДЕНИЯ");
        /*В НАЧАЛЕ СТРОКИ*/
        regex = "^what"; //
        text = "what wat what";
        updateMatcherAndFind();
        System.out.println("совпадение в начале строки найдено, с индекса: " + m.start()); // 0

        /*В КОНЦЕ СТРОКИ*/
        regex = "what$"; //
        text = "what wat what";
        updateMatcherAndFind();
        System.out.println("совпадение в конце строки найдено с индекса: " + m.start()); // 9

        /*В РАМКАХ СЛОВА */
        regex = "\\bwhat\\b";
        text = "whatty whatty whatty";
        updateMatcher();
        System.out.println("совпадение в рамках слова найдено: " + m.find()); // false
        text = "whatty what whatty";
        updateMatcher();
        System.out.println("совпадение в рамках слова найдено: " + m.find()); // true


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~СПОСОБЫ ВАЛИДАЦИИ ТЕКСТА ПО ШАБЛОНУ~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        System.out.println("ПРОВЕРКА ВСЕГО ТЕКСТА НА СООТВЕТСТВИЕ ШАБЛОНУ");

        /* КЛАССИЧЕСКИЙ: PATTERN + MATCHER */
        p = Pattern.compile("[Ss]ome string"); // задается необходимый для поиска шаблон
        m = p.matcher("Some string"); // задается текст, где производится поиск
        System.out.println("Классическая проверка: " + m.matches()); // производится проверка

        /* БЫСТРЫЙ: БЕЗ СОЗДАНИЯ ОБЪЕКТА MATCHER */
        System.out.println("Быстрая проверка без объекта Matcher: "
                + Pattern.matches("[Ss]ome string", ("Some string")));

        /* БЫСТРЫЙ: БЕЗ СОЗДАНИЯ СОЗДАНИЯ ОБЪЕКТОВ PATTERN И MATCHER */
        System.out.println("Быстрая проверка без объектов Pattern и Matcher: "
                + "Some string".matches("[Ss]ome string"));


        /*~~~~~~~~~~~~~~~~~~~~ФЛАГИ PATTERN.COMPILE()~~~~~~~~~~~~~~~~~~~~ */
        System.out.println("ФЛАГИ PATTERN.COMPILE() И ИХ СИНОНИМЫ");

        /* CASE_INSENSITIVE - ИГНОРИРОВАНИЕ РЕГИСТРА (+ ДЛЯ СИМВОЛОВ UNICODE)*/
        p = Pattern.compile("строка", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
        m = p.matcher("СТРОКА");
        System.out.println("Игнорирование регистра: " + m.matches());
        System.out.println("Синоним:" + "some string".matches("(?i)SOME STRING"));

        /* COMMENTS - ИГНОРИРОВАНИЕ ПРОБЕЛОВ И КОММЕНТАРИЕВ В ПАТТЕРНЕ */
        p = Pattern.compile("some string", Pattern.COMMENTS);
        m = p.matcher("somestring");
        System.out.println("Игнорирование пробелов и комментариев: " + m.matches());
        System.out.println("Синоним:" + "somestring".matches("(?x)some string"));


        /* ~~~~~~~~~~~~~~~~~~~~ДРУГИЕ ВАЖНЫЕ МЕТОДЫ PATTERN~~~~~~~~~~~~~~~~~~~~
         * - compile() и matches() см. выше*/
        System.out.println("ДРУГИЕ ВАЖНЫЕ МЕТОДЫ PATTERN");

        /* SPLIT() - РАЗДЕЛИТЬ СТРОКУ НА МАССИВ ПО МЕСТАМ СОВПАДЕНИЙ */
        p = Pattern.compile(" ");
        String[] sa = p.split("one two three");
        System.out.println("split() делит строку на массив: " + Arrays.toString(sa));

        /*TOSTRING() - ВЕРНУТЬ РВ ОБРАТНО СТРОКОЙ */
        p = Pattern.compile("Blah");
        System.out.println("toString(): вернет шаблон обратно строкой: " + p);

        /*QUOTE() - ВЕРНУТЬ СТРОКОЙ ШАБЛОН, ПОДХОДЯЩИЙ ДЛЯ ВВЕДЕННОЙ СТРОКИ */
        System.out.println("Подобрать шаблон: " + Pattern.quote("123xxxAAA")); // \Q123xxxAAA\E


        /* ~~~~~~~~~~~~~~~~~~~~АНАЛОГИЧНЫЕ МЕТОДЫ И КЛАССА STRING ~~~~~~~~~~~~~~~~~~~~
         * - matches() см. выше */
        System.out.println("АНАЛОГИЧНЫЕ МЕТОДЫ ИЗ КЛАССА STRING");

        /* SPLIT() */
        text = "Split this string";
        System.out.println("split(): " + Arrays.toString(text.split(" ")));


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ГРУППЫ МЕТОДОВ MATCHER~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        System.out.println("ГРУППЫ МЕТОДОВ MATCHER");
        regex = "(i(f))";
        text = "ififif";
        updateMatcher();

        /*~~~~~~~~~~~~ МЕТОДЫ ИЗУЧЕНИЯ ~~~~~~~~~~~~
         * - кроме matches()*/
        /* LOOKINGAT() - поиск совпадения начиная с начала диапазона, а не для ВСЕГО диапазона*/
        System.out.println("Соответствие шаблону найдено: " + m.lookingAt()); // true

        /* FIND() - поиск следующего куска текста, подходящего под паттерн
         * - find(int index) - перезагрузить поиск и начать с указанного символа */
        System.out.println("Соответствие шаблону найдено: " + m.find(3)); // true


        /*~~~~~~~~~~~~ МЕТОДЫ ЗАМЕНЫ ~~~~~~~~~~~~*/
        /* START() - стартовый индекс последнего совпадения
         *   - start(int group)*/
        System.out.println("Стартовый индекс последнего вхождения: " + m.start()); // 4
        System.out.println("Стартовый индекс последнего вхождения группы 2: " + m.start(2)); // 5

        /* END () - индекс, следующий за последним совпадением
         * - end(int group)*/
        System.out.println("Последний индекс последнего вхождения (+1): " + m.end()); // 6
        System.out.println("Последний индекс последнего вхождения (+1) группы 2: " + m.end(2)); // 6


        /*~~~~~~~~~~~~ МЕТОДЫ ГРУПП ~~~~~~~~~~~~*/
        /*GROUP(int number) - вернуть строкой группу по указанному номеру*/
        System.out.println("Количество групп в выражении: " + m.group(2)); // f

        /*GROUPCOUNT() - количество групп в выражении (без учета нулевой)*/
        System.out.println("Количество групп в выражении: " + m.groupCount()); // 2


        /*~~~~~~~~~~~~ МЕТОДЫ ЗАМЕНЫ ~~~~~~~~~~~~*/
        /* REPLACEFIRST() - замена первого вхождения*/
        System.out.println("Замена первого вхождения: " + m.replaceFirst("1")); //1ifif

        /* REPLACEALL() - замена всех вхождений*/
        System.out.println("Замена всех вхождений: " + m.replaceAll("2")); //222


        /* ~~~~~~~~~~~~~~~~~~~~АНАЛОГИЧНЫЕ МЕТОДЫ И КЛАССА STRING ~~~~~~~~~~~~~~~~~~~~ */
        System.out.println("АНАЛОГИЧНЫЕ МЕТОДЫ ИЗ КЛАССА STRING");
        regex = "(i(f))";
        text = "ififif";

        /* REPLACEFIRST() - замена первого вхождения*/
        System.out.println("Замена первого вхождения: " + text.replaceFirst(regex, "1")); //1ifif

        /* REPLACEALL() - замена всех вхождений*/
        System.out.println("Замена всех вхождений: " + text.replaceAll(regex, "2")); //222

        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ МЕТОДЫ PATTERNSYNTAXEXCEPTION~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        System.out.println("МЕТОДЫ КЛАССА PATTERNSYNTAXEXCEPTION");
//        regex = "(i&"; // нужно сначала раскомитить
        text = "ififif";
        try {
            p = Pattern.compile(regex);
        } catch (PatternSyntaxException e) {
            System.out.println(e.getMessage()); // Unclosed group near index 3 (i&
            //                                                                   ^
        }
    }
}