package __concurrency;

import types_references_annotations.my_annotations.Ntrstn;

import static __concurrency.ThreadsColor.ANSI_BLUE;
import static __concurrency.ThreadsColor.ANSI_CYAN;
import static __concurrency.ThreadsColor.ANSI_GREEN;

/* PROCESS, THREAD, CONCURRENCY (MULTI-THREADING)
 * - даже если 1 ядро у процессора, его время делится между процессами и ветками через фичу ОС
 * "time slicing"
 *
 * - процесс:
 *      - имеет свою среду исполнения и набор run-time ресурсов
 *      - обычно 1 апп - 1 процесс
 *          - но может быть и набор коммуницирующих процессов (Inter Process Communication (IPC))
 *      - у каждого процесса есть минимум 1 ветка
 *      - большинство имплементаций JVM работают как 1 процесс
 *          - апп может создавать дополнительные процессы при помощи объекта ProcessBuilder
 *
 * - ветки (потоки): "легковесные" процессы
 *      - также предоставляют среду исполнения, но их создание требует меньше ресурсов, чем для
 *      процесса
 *      - существуют внутри процесса и делят его ресурсы между собой (находятся в Heap)
 *          - из-за этого могут возникать конфликты
 *      - имеет свой Stack для локальных переменных и только она имеет к нему доступ
 *      - изначально есть только ветка main
 *          - другие создаются из нее
 *              - каждая ветка ассоциирована с экземпляром Thread
 *          - (также есть системные ветки (напр. для управления памятью))
 *
 * - многопоточность: способность программы работать с несколькими потоками одновременно */


/* ПРОБЛЕМЫ МНОГОПОТОЧНОСТИ, СИНХРОНИЗАЦИЯ И ОТНОШЕНИЕ HAPPENS-BEFORE */


/* 2 СТРАТЕГИИ ИСПОЛЬЗОВАНИЯ ОБЪЕКТА THREAD
 * - 1: создание объекта Thread каждый раз при необходимости выполнения несинхронной задачи и ручное
 * управление созданным объектом
 *
 * - 2: создание и передача объектов Thread в Executor, чтобы абстрагировать управление ветками
 * (от остальной части приложения)
 *      - относится к высокоуравнему API */


/* 2 СПОСОБА СОЗДАНИЯ И ЗАПУСКА ПОТОКА + МЕХАНИЗМ ЗАПУСКА:
 * - 1: наследовать Thread и переопределить его метод run (изначально ничего не делает)
 *      - легче исопльзовать в простых приложениях
 *      - метод run присутствует из-за имплементации классом Thread интерфейса Runnable
 *
 * - 2: для своего класса имплементировать Runnable и его метод run, и передать экземпляр в
 * конструктор Thread (Runnable)
 *      - предпочтительней, т.к:
 *          - класс сможет наследоваться не обязательно от Thread
 *          - в высокоурованевом API используются объекты Runnable
 *
 * - после этого запустить на экземпляре Thread метод start:
 *      - JVM вызывает метод run на Runnable:
 *          - теперь есть 2 ветки, работающие одновременно:
 *              - текущая ветка (вернулась с вызова метода start)
 *              - новосозданная ветка, которая исполняет свой метод run
 *      - запрещено запускать ветку более 1 раза */


/* НИЗКОУРОВНЕВЫЙ API */

/* ФУНКЦИОНАЛЬНЫЙ ИНТЕРФЕЙС RUNNABLE: run()
 * - общий протокол для объектов, которые хотят исполнять свой код (из метода run) в отдельной ветке
 *      - класс имплементирует Runnable, создается экземпляр Thread и ему передается в качестве цели
 *      данный экземпляр Runnable
 *          - начало ветки приводит к вызову метода run на принадлежащем экземпляру Thread объекту
 *          Runnable
 *      - напр. Thread имплементирует Runnable
 *
 * - позволяет работать в ветке без обязательного наследования от Thread
 *      - (если достаточно переопределить только run(), а не другие методы Thread) */


/* КЛАСС THREAD - ВЕТКА ИСПОЛНЕНИЯ В ПРОГРАММЕ
 * - public class Thread extends Object implements Runnable
 *
 * - свойства:
 *      - имеет имя(setName):
 *          - более 1 ветки могут иметь 1 имя
 *          - если имя не указано, генерируется новое
 *
 *      - имеет приоритет(setPriority): JVM старается исполнять их в порядке, соответствующем приоритету
 *          - наследуется ветками-наследниками, но можно потом изменить
 *
 *      - может быть демоном или пользовательской(setDaemon): JVM может завершить работу только, если
 *      оставшиеся работающие ветки являются демонами
 *          - статус наследуется ветками-наследниками, но можно потом изменить
 *
 *      - имеет уникальный идентификационный номер (getId)
 *          - сохраняется на время жизни и может быть переиспользован после смерти
 *
 * - типичные манипуляции:
 *      - sleep (временное прекращение выполнения ветки) - если нужно:
 *          - предоставить процессорное время другим веткам
 *          - изменить темп выполнения
 *              - например, подождать другую "тяжелую" ветку
 *
 *      - join (присоединение, т.е. текущая ветка для продолжения работы ждет завершения указанной)
 *         - один из механизмов синхронизации (установка отношения Н-В)
 *         - можно также указать время ожидания, вместо завершения ветки (но все равно вызывается на
 *         объекте другой ветки)
 *              - например, чтобы периодически проверять статус выполняющейся ветки и периодически
 *              выводить сообщения о ней с главной ветки
 *
 *      - interrupt ("пожелание", чтобы ветка остановилась и запустила механизм своего прерывания):
 *          - ветка должна иметь такой механизм
 *              - например, выбросить InterruptedException
 *                  - так делают многие методы, прерывая свое исполнение
 *              - если ветка работает долго без выбрасывания InterruptedException, она должна
 *              периодически проверять флаг прерванности (Thread.interrupted (проверяет + обнуляет
 *              статус); устанавливается извне методом interrupt) и продолжать с учетом данного условия
 *                  - если флаг установлен, то можно, например, выбросить InterruptedException
 *                      - позволяет коду, обрабатывающему прерывания, быть сосредоточенным в catch
 *              - по договоренности: при выбрасывании InterruptedException обнуляется статус
 *              прерванности
 *              - todo если ветка заблокирована методами wait (класс Object), join, sleep, то статус
 *              прерванности обнуляется и будет получено InterruptedException
 *
 * - JVM исполняет ветки, пока:
 *      - все ветки, не являющиеся демонами, не умрут или вернутся из вызова run
 *      - todo не будет выброшено исключение, которое выходит за метод run
 *      - todo не был вызван метод exit класса Runtime и security manager разрешил произвести операцию exit
 *
 * - (другие) основные методы:
 *      - activeCount(): приблизительное число активных веток у группы текущей ветки и их подгрупп
 *      - checkAccess(): проверка возможности менять текущую ветку работающей веткой
 *      - currentThread(): ссылка на текущий выполняющийся объект ветки
 *      - dumpStack(): вывод stack trace текущей ветки в standard error stream.
 *      - enumerate(Thread[] tarray): вернуть в массиве копии (ссылки?) всех веток и подветок у данной
 *      - getAllStackTraces(): map of stack traces всех живых веток
 *      - getThreadGroup(): группа ветки, которой принадлежит данная ветка
 *      - holdsLock(Object obj): проверка на удержание монитора веткой для указанного объекта
 *      - isAlive(): проверка живости данной ветки
 *      - toString(): имя ветки, приоритет и группа */



/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ВЫСОКОУРАВНЕВЫЙ API~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ПАКЕТ JAVA.UTIL.CONCURRENT: УТИЛИТНЫЕ КЛАССЫ МНОГОПОТОЧНОСТИ
 * - Executors:
 *      - интерфейсы:
 *          - Executor: простой интерфейс, определяющий кастомные thread-like подсистемы, включая
 *          пулы потоков, асинхронный I/O и легковесные тасковые фреймворки. В зависимости от
 *          используемого конкретного класса, кот. имплементирует Executor, таски могут исполняться
 *          в новых ветках, в существующих или в ветке вызывающей execute, и могут выполняться как
 *          одновременно, так и последовательно
 *          - ExecutorService: более сложный фреймворк: управляет очередями и планированием тасков
 *          и позволяет контролированное завершение
 *              - ScheduledExecutorService: подинтерфейс для отложенного или периодического выполения.
 *              - предоставляет методы для организации асинхронного выполнения объектов Callable
 *                  - аналог Runnable, но возвращает результат
 *          - Future: возвращает результат Callable, позволяет определять, завершилось ли исполнение,
 *          предоставляет возможность отменять выполнение
 *          - RunnableFuture: Future с методом run, который при выполении устанавливает свои результаты.
 *
 *      - имплементации:
 *          - ThreadPoolExecutor и ScheduledThreadPoolExecutor: предоставляют настраиваемые и гибкие
 *          пулы потоков
 *          - Executors: фабричные методы для наиболее часто используемых конфигураций Executor и
 *          некоторые методы для их использования
 *          - FutureTask: простая расширяемая имплементация Future
 *          - ExecutorCompletionService: помогает при координации обработки групповых тасков
 *          - ForkJoinPool: предоставляет Executor для обработки экземпляров ForkJoinTask
 *
 * - Queues:
 *      - ConcurrentLinkedQueue: эффективная масштабируемая thread-safe неблокирующая FIFO очередь.
 *      - ConcurrentLinkedDeque: похоже, но дополнительно поддерживает интерфейс Deque.
 *      - интерфейс BlockingQueue: определяет блокирующие версии put и take
 *          - имплементации: LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue,
 *          PriorityBlockingQueue, и DelayQueue
 *              - для разных контекстов: producer-consumer, messaging, parallel tasking и т.д.
 *          - подинтерфейс BlockingDeque: поддержка FIFO и LIFO (stack-based)
 *              - имплементация: LinkedBlockingDeque
 *      -  TransferQueue (и имплементация LinkedTransferQueue): синхронный медод transfer, который
 *      позволяет продюсеру блокировать ожидающего его консумера
 *
 * - Timing:
 *       - TimeUnit: предоставляет разные гранулярности (включая наносекунды) для операций таймаута
 *       или указания времени
 *
 * - Synchronizers:
 *      - Semaphore: классическая тулза многопоточности
 *      - CountDownLatch: очень простая утилита для блокирования пока происходит указанное число
 *      сигналов, событий или условий.
 *      - CyclicBarrier: resettable multiway точка синхронизации.
 *      - Phaser: более гибкая форма барьера, которая может использоваться для контролирования phased
 *      вичислений между несколькими ветками.
 *      - Exchanger: позволяет 2 веткам обмениваться объектами в rendezvous точке.
 *
 * - многопоточные коллекции (помимо Queue):
 *      - ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList,
 *      CopyOnWriteArraySet
 *          - предпочтительней, чем синхронизованные версии коллекций
 *              - thread-safe, но не управляются 1 монитором
 *      - их итераторы и сплитераторы предоставляют weakly consistent, а не fast-fail перебор */


/* ПАКЕТ JAVA.UTIL.CONCURRENT.LOCKS: РАСШИРЕНИЕ СТАНДАРТНОГО ФУНКЦИОНАЛА МОНИТОРОВ И ОЖИДАНИЯ
 * - интерфейс Lock: поддержка блокировки при помощи другой семантики, и которая может использоваться
 * в неблокирующем контексте, включая алгоритмы hand-over-hand и lock reordering
 *      - ReentrantLock: основная имплементация
 * - интерфейс ReadWriteLock: можно использовать общий замок между читателями, но эксклюзивный для
 * записи
 *      - ReentrantReadWriteLock: единственная имплементация
 * - интерфейс Condition: условные переменные, ассоциированные с Lock
 *      - как у Object.wait, но шире функционал
 *          - например, несколько разных условий
 * - класс AbstractQueuedSynchronizer: суперкласс-удобство для определения мониторов и других
 * синхронизаторов, которые полагаются на очередь блокированных потоков
 *      - унаследован от AbstractOwnableSynchronizer: помогает записывать поток, который удерживает
 *      замок.
 * - класс LockSupport: более низкоуравневый, для своих имплементаций */


/* ПАКЕТ JAVA.UTIL.CONCURRENT.ATOMIC: АТОМИЧЕСКИЕ ОПЕРАЦИИ НАД ПЕРЕМЕННЫМИ
 * - по сути классы в пакете расширяет понятие volatile значений, полей и элементов массивов до таких,
 * что также предоставляют атомическую условную операцию обновления в форме boolean
 * compareAndSet(expectedValue, updateValue);
 *      - метод не является общим заменителем блокировки, а применяется только когда критические
 *      апдейты для объекта заключаются в единственную переменную
 * - в первую очередь предназначены как строительные элементы для имплементаций неблокирующий
 * структур данных
 * - не являются общими заменителями для оберток, так как не определяют методов тех классов
 * - классы AtomicBoolean, AtomicInteger, AtomicLong, и AtomicReference: доступ и обновление
 * переменной соответствующего типа, а также другие удобства, например инкрементация
 * - классы Updater: можно использовать для получения compareAndSet операций для любобо выбранного
 * volatile поля любого класса
 * - классы AtomicIntegerArray, AtomicLongArray, and AtomicReferenceArray поддерживают volatile
 * доступ к элементам массива, что обычным способом не поддерживается
 * */


@Ntrstn("Вообще у приложения изначально не одна ветка - есть еще системные ветки для управления " +
        "памятью и т.д. Но с точки зрения программиста она 1 - main")

@Ntrstn("Так как main также является веткой, то c ней можно делать то же, что и с другими ветками, " +
        "например, уложить спать")

@Ntrstn("Метод interrupt по сути просьба (установка флага прерванности) у текущей ветки прервать то, " +
        "что она сейчас делает. Сама ветка должна работать с постоянной проверкой флага, и если он " +
        "указывает на необходимость прервать выполнение, то так и нужно поступить, например, выбросив " +
        "InterruptedException. А код, который запросил прерывание, укажет, что делать дальше при " +
        "обработке данного исключения")

@Ntrstn("Если вручную вызывать метод run вместо start, то он будет выполнен в текущей ветке, а не в " +
        "отдельной, в то же время start выполняется в новой ветке и единожды для соотв. объекта Thread")

@Ntrstn("Метод run в Thread есть потому, что он и сам имплементирует Runnable")
@Ntrstn("бессмысленность синхрониции конструкторов и локальных переменных")


public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = sleepyThread(2000);
        t.start();

        Thread t1 = interruptingThread();
        t1.start();
        Thread.sleep(30);
        t1.interrupt();

        System.out.println(ANSI_BLUE + Thread.currentThread() + "Before join");
        Thread t2 = sleepyThread(4000);
        t2.start();
        t2.join(); // текущая ветка продолжится после t или после указанного времени
        System.out.println(ANSI_BLUE + Thread.currentThread() + "After join");

    }


    static Thread sleepyThread(int millis) {
        return new Thread(() -> {
            System.out.println(ANSI_GREEN + Thread.currentThread().getName());
            try {
                System.out.println(ANSI_GREEN + "Going to bed for " + millis + " millisecs...");
                Thread.sleep(millis);
            } catch (InterruptedException e) {
                System.out.println(ANSI_GREEN + "I was interrupted while sleeping");
                return;
            }
            System.out.println(ANSI_GREEN + "I am awake now");
        });
    }


    static Thread interruptingThread() {
        return new Thread(() -> {
            System.out.println(ANSI_CYAN + Thread.currentThread().getName());
            for (int i = 0; i < 100000; i++) {
                System.out.println(ANSI_CYAN + i);
                if (Thread.interrupted()) {
                    System.out.println(ANSI_CYAN + "I've been interrupted");
                    return;
                }
            }
        });
    }

}