package __numbers_BigDecimal;
//TODO: не закончено

/*
* BigDecimal является стандартным классом, без специальной поддержки в компиляторе, для представления
* двоичных чисел произвольной разрядности и выполнения арифметических действий над ними. По сути дела
* BigDecimal представлен как недифференцированное значение произвольной разрядности и коэффициент
* масштабирования, который указывает насколько сдвинуть влево десятичную точку для получения значения,
* разбитого на дробную и целую части. Итак, число, представленное BigDecimal является
* unscaledValue*10-scale.

Арифметические действия над значениями BigDecimal реализуются с помощью методов для сложения,
вычитания, умножения и деления. Поскольку объекты BigDecimal являются неизменяемыми, то каждый из
этих методов производит новый объект BigDecimal. В итоге BigDecimal не слишком хорошо подходит для
интенсивных вычислений из-за затрат на создание объекта, но он спроектирован для представления точных
десятичных чисел. Если Вам необходимо представить такие точные величины как денежные суммы, то
BigDecimal прекрасно подойдет для этой задачи.*/


/*Все методы сравнения не созданы равными
Как и у всех типов с плавающей точкой, у BigDecimal тоже есть несколько особенностей. А именно, будьте
осторожны с использованием метода equals() для проверки тождественности чисел. Два значения BigDecimal,
представляющих одно и то же число, но имеющих различные коэффициенты масштабирования (например, 100.00
и 100.000) не будут равными при использовании метода equals(). Тем не менее, метод compareTo() будет
считать их равными, а, следовательно, Вы должны использовать compareTo() вместо equals() при
количественном сравнении двух значений BigDecimal.

Существуют некоторые случаи, когда для получения точных результатов недостаточно двоичной арифметики
с произвольной разрядностью. Например, деление 1 на 9 выдает бесконечную периодическую двоичную дробь
.111111... По этой причине BigDecimal позволяет Вам явно контролировать округление при выполнении
операций деления. Точное деление на показатель степени 10 поддерживается методом movePointLeft().*/

/*Используйте BigDecimal в качестве типа обмена
В SQL-92 есть тип данных DECIMAL, который является точным числовым типом для представления десятичных
чисел с фиксированной точкой и выполняет основную арифметическую операцию над двоичными числами. В
некоторых диалектах SQL предпочитают называть этот тип NUMERIC, а другие также содержат тип данных
MONEY, который определяется как десятичное число с двумя знаками справа от десятичной дроби.

Если Вы хотите сохранить число в поле DECIMAL в базе данных или извлечь значение из поля DECIMAL, то
как можно убедиться в том, что число будет передано точно? Вы не хотите использовать методы setFloat()
и getFloat(), обеспечиваемые JDBC классами PreparedStatement и ResultSet, поскольку конвертация из
числа с плавающей точкой в десятичное число может привести к потере точности. Вместо этого,
используйте setBigDecimal() и getBigDecimal() методы PreparedStatement и ResultSet.

Аналогично, XML-инструменты привязки данных, например, Castor, сгенерируют механизмы получения и
установки для десятичных атрибутов и элементов (которые поддерживаются в качестве основного типа
данных в XSD-схеме), используя BigDecimal.*/


/*Построение чисел BigDecimal
Существует несколько конструкторов для BigDecimal. Один в качестве входной информации использует
плавающую точку удвоенной точности, второй - целое число и коэффициент масштабирования, а третий -
String - представление десятичного числа. Вам нужно быть осторожными с конструктором BigDecimal(double),
поскольку он может позволить ошибкам округления появиться в Ваших вычислениях раньше, чем вы об этом
узнаете. Вместо этого используйте целое число или конструкторы, основанные на String.

Ненадлежащее использование конструктора BigDecimal(double) может проявляться в кажущихся странными
ошибках в JDBC-драйверах при передаче в JDBC setBigDecimal() метод. Например, рассмотрим следующий
JDBC-код, который хочет сохранить число 0.01 в десятичном поле:

PreparedStatement ps =
  connection.prepareStatement("INSERT INTO Foo SET name=?, value=?");
ps.setString(1, "penny");
ps.setBigDecimal(2, new BigDecimal(0.01));
ps.executeUpdate();

В зависимости от Вашего драйвера JDBC, этот кажущийся безобидным код может при выполнении выдать
некоторые запутанные ошибки, потому что приближенная величина с удвоенной точностью 0.01 приведет к
большому дифференцированному значению, которое может запутать JDBC-драйвер и базу данных. Ошибка
появится в JDBC драйвере, но весьма маловероятно, что она проявит себя, и Вы не будете знать, что не
так с Вашим кодом, до тех пор, пока Вы не поймете ограничения двоичных чисел с плавающей точкой.
Чтобы избежать возникновения таких проблем, сконструируйте BigDecimal, используя BigDecimal("0.01")
или BigDecimal(1, 2) , так как каждый из них, в конечном счете, приведет к точному десятичному
представлению.*/


public class Main {
}
