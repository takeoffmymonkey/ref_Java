package method_constructor;

import com.sun.istack.internal.NotNull;

import java.util.ArrayList;
import java.util.Collection;
import java.util.function.BiFunction;

import types_references_annotations.my_annotations.Ntrstn;

/* ОПРЕДЕЛЕНИЕ МЕТОДА
 * 1. Модификаторы
 *      - может отсутсвовать
 *          - т.е. default
 *
 * 2. Тип возвращаемого значения
 *      - void - если метод ничего не возвращает
 *
 * 3. Имя метода
 *      - первое или единственное слово должно быть глаголом
 *      - должно начинаться с маленькой буквы
 *      - !! может совпадать с именем конструктора
 *          - разница:
 *              - метод должен что-то возвращать
 *                  - в т.ч. void
 *              - имя метода по конвенции с маленькой буквы
 *
 * 4. Список принимаемых параметров
 *      - в скобках
 *          - через запятую
 *              - перед каждым указывается тип
 *          - параметр может быть финализирован
 *              - его значение нельзя изменить
 *          - перед типом параметра может идти аннотация
 *      - пустые скобки, если ничего не принимает
 *
 * 5. Список бросаемых исключений
 *
 * 6. Тело метода
 *      - в фигурных скобках
 *          - выражения
 *          - инструкции
 *          - классы
 *          - блоки кода
 *          - локальные переменные
 *          - инструкция return, если метод возвращает не void
 *              - должна возвращать тип, совместимый с объявленным возвращаемым типом
 *              - void метод может иметь return без ничего
 *                  - но это и так происходит автоматически*/


/* МЕСТО ОПРЕДЕЛЕНИЯ МЕТОДА
 * - должен находится внутри класса на уровне его членов
 * - не должен находится в любом другом месте
 *      - напр. вне класса, в другом методе или блоке кода */


/* ПЕРЕГРУЗКА МЕТОДА
 * - в классе присутствует больше 1 метода с одинаковым именем, но различными параметрами
 *      - другие типы
 *      - другое количество
 * - если для параметра нет собственного метода, то может использоваться автоматическое
 * преобразование
 *      - напр. аргумент типа int войдет в метод с типом double
 * - способствует полиморфизму
 *      - 1 название метода - разные реализации
 * - ухудщает читаемость */


/* СИГНАТУРА МЕТОДА
 * - в 1 классе/интерфейсе сигнатуры методов должны быть уникальны
 * - при определении сигнатуры не учитываются:
 *      - модификаторы
 *          - в т.ч. параметров
 *      - тип возвращаемого значения
 *      - выбрасываемое исключение
 * - 2 метода имеют одинаковую сигнатуру если у них:
 *      - одинаковое имя
 *      - одинаковые типы параметров
 *          - если они вообще есть
 *          - в т.ч. после стирания типов
 *      - тот же порядок параметров
 *
 * - todo ПОДСИГНАТУРА
 *      - необходимое понятие для выражения отношения между методами с разными сигнатурами, но 1
 *      может все-таки переопределить другую
 *      - сигнатура M1 является подсигнатурой М2, если:
 *          - у М2 такая же сигнатура как и М1
 *          - или после стирания типа сигнатура М2 стала такой же, как сигнатура М1
 *      - напр. метод, чья сигнатура не использует обобщенный тип, может переопределить любую
 *      обобщенную версию того же метода
 *          - нужно, чтобы создатели библиотек могли спокойно обобщать методы независимо от клиентов,
 *          которые определяют подклассы и подинтерфейсы из библиотеки
 *      - ЭКВИВАЛЕНТНОЕ ПЕРЕОПРЕДЕЛЕНИЕ
 *          - вызывает ошибку компилятора
 *          - M1 и M2 являются эквивалентами переопределения, если:
 *              - М1 является подсигнатурой М2
 *              - или М2 является подсигнатурой М1 */


/* ПЕРЕОПРЕДЕЛЕНИЕ
 * - если в подклассе определен метод, сигнатура которого совпадает с сигнатурой метода из
 * суперкласса, то метод подкласса переопределяет его, замещая собой
 *      - если только совпадает только имя, то методы являются просто перегруженными
 * - при переопределении метода необходимо сохранить совместимость возвращаемых типов
 *      - в подклассе возвращаемый тип может быть заменен на подтип изначального типа
 * - при переопределении область действия метода из подкласса должна быть не меньше области действия
 * метода из суперкласса
 *      - напр. был protected, значит должен остаться protected или стать public
 *      - нельзя переопределить:
 *          - private методы родителя
 *              - они не видны наследнику
 *          - final методы родителя
 *              - ошибка компилятора
 *              - если у класса стоит final - все его методы также final
 *              - можно изменить сигнатуру, но это уже не будет переопределением
 *          - static методы родителя
 *              - т.к. не привязаны к экземпляру
 *                  - следовательно не работает динамический полиморфизм
 *              - будет просто затемнение
 *                  - не работает для final static
 *                      - ошибка компилятора
 *              - "статичность" методов родителя и наследника с одной и той же сигнатурой должна
 *              совпадать
 *                  - иначе ошибка комплитора
 * - желательно указать @Override
 *      - если ошибемся в переопределении, получим ошибку компилятора
 * - если метод находится в финализированном классе, он также автоматически финализирован
 *      - т.е. не может быть переопределен
 * - когда родительский ничего не выбрасывает или выбрасывает непроверяемое исключение, то метод
 * наследника:
 *      - может ничего не выбрасывать
 *      - может выбрасывать любое непроверяемое исключение
 *      - не может выбрасывать проверяемое исключение
 *          - ошибка компилятора
 * - когда родительский выбрасывает проверяемое исключение, то метод наследника:
 *      - может ничего не выбрасывать
 *      - может выбрасывать любое непроверяемое исключение
 *      - не может выбрасывать другое или более обобщенное проверяемое исключение
 *          - ошибка компилятора */


/*                             |----------------------------|-----------------------------|
 *                             |Метод экземпляра суперкласса|Статический метод суперкласса|
 *|----------------------------|----------------------------|-----------------------------|
 *|Метод экземпляра подкласса  |Переопределение             |Ошибка компиляции            |
 *|----------------------------|----------------------------|-----------------------------|
 *|Статический метод подкласса |Ошибка компиляции           |Сокрытие                     |
 *|---------------------------------------------------------------------------------------|*/


/* ПАРАМЕТРЫ И АРГУМЕНТЫ
 * - ПАРАМЕТР - указан в определении метода:
 *      - может быть любой:
 *          - примитив
 *          - ссылка
 *      - имена параметров используются в теле метода для ссылки на переданный аргумент
 *      - должны быть уникальны в своей зоне действия
 *      - имя может совпадать с именем члена класса
 *          - происходит затемнение членов класса
 *              - т.е. к параметру метода можно обратится напрямую по имени
 *                  - а к члену - только по ссылке this
 *
 * - АРГУМЕНТ - передается при вызове метода */


/* ВЫЗОВ
 * - при вызове метода, тип и порядок аргументов должен совпадать с параметрами метода
 * - ВЫЗОВ ПО ЗНАЧЕНИЮ (применяется в Java):
 *      - при передаче аргументов, в стеке выделяется необходимая область памяти (фрейм метода),
 *      куда копируются значения переданных аргументов:
 *          - примитивные аргументы
 *              - т.е. метод не сможет изменить оригинальные значения переменных
 *          - ссылки на объекты
 *              - т.е. метод не сможет изменить адрес оригинальной ссылки
 *                  - !! но сможет изменить состояние объекта по ссылке
 *          - копии будет уничтожены при выходе из метода
 *
 * - ВЫЗОВ ПО ССЫЛКЕ (НЕ применяется в Java):
 *      - метод получает из вызывающей программы местоположение переменной
 *          - может модифицировать ее значение */


/* ВОЗВРАЩЕНИЕ ЗНАЧЕНИЯ
 * - возвращение в код, который вызвал метод, происходит когда:
 *      - он завершил все инструкции в методе
 *          - возвращается тип void
 *              - т.е. нет типа
 *      - достигнут оператор return
 *          - возвращается то, что указано в return
 *              - тип должен быть совместим с типом из декларации
 *                  - т.е. может быть подклассом класса, указанного в декларации
 *                  - если в декларации возвращаемы тип - интерфейс, то возвращаемый класс должен
 *                  его имплементировать
 *                      - или имплементировать совместимый с ним интерфейс
 *          - return может быть и в методе, возвращающем void
 *              - при достижении также произойдет выход
 *          - не путать с break
 *              - break - для выхода из цикла
 *      - выброшено исключение
 *          - если исключение бросается вручную инструкцией throw, то присутствие инструкции
 *          return компилятором не требуется!*/


/*~~~~~~~~~~~~~~~~~~~~~~~~~ПЕРЕМЕННОЕ ЧИСЛО АРГУМЕНТОВ~~~~~~~~~~~~~~~~~~~~~~~~~
 * - специальное обозначение параметра метода
 *      - Тип... переменная
 * - позволяет передавать разное число аргументов в метод
 *      - напр. если метод может работать с юзером, паролем, только с паролем или без пароля
 *          - а в реализации тогда юзер берется дефолтный
 * - у 1 метода может быть только 1 параметр переменной длины
 * - должен быть последним в списке параметров
 * - может не передаваться вообще
 *      - тогда это массив нулевой длины
 * - на самом деле является массивом:
 *      - можно передать в качестве аргумента массив нужного типа
 *      - в методе аргумент доступен как массив
 *          - в т.ч. нулевой длины если аргумент остутствует
 *      - напр. можно узнать длину
 *          - .lentgh
 * - можно перегружать, но может возникнуть неоднозначность, если вызывается пустым
 *      - т.к. переменное количество - это и 0
 *      - если есть подходящий метод, но без такого параметра, то будет выбран он
 *          - т.е. конфликта не будет */


/* ОСОБЫЕ ВИДЫ
 * - Статический:
 *      - перед декларацией стоит модификатор static
 *      - обращение через имя класса:
 *          - ClassName.methodName(args)
 *          - также можно обратится через имя объекта
 *      - методы экземпляра имеют прямой доступ к методам класса
 *      - могут быть перегружены
 *      - рекомендованы в 2 случаях:
 *          - методу не требуется доступ к данным о состоянии объекта, поскольку все необходимые
 *          параметры задаются явно
 *              - напр., в методе Math.pow(2, 3)
 *          - методу требуется доступ лишь к статическим полям класса
 *              - напр., при вызове метода Employee.getNextld()
 *      - ограничения:
 *          - могут непосредственно вызывать только другие статические методы
 *          - непосредственно доступны только статические переменные
 *          - не могут использовать ссылки this или super
 *          - не могут быть переопределены
 *              - в методе-наследнике можно также добавить static и тогда не будет ошибки компилятора
 *                  - но это уже не будет переопределением
 *
 * - Финализированный:
 *      - перед декларацией стоит final
 *      - не может быть переопределен в подклассах
 *      - все методы финализированного класса автоматически также являются финализированными
 *
 * - Обобщенный:
 *      - в методах обобщенного класса можно использовать параметр типа
 *          - т.е. они тоже становятся обобщенными, относительно этого параметра
 *      - может быть внутри обобщенного класса и использовать его параметр
 *      - может быть внутри необобщенного класса и принимать обобщенный параметр
 *          - перед объявлением возвращаемого значения нужно указать параметр
 *      - может быть переопределен
 *          - в т.ч. с учетом подсигнатуры */


@Ntrstn("Имя метода может совпадать с именем конструктора (но в отличие от него, должно что-то " +
        "возращать (напр. void))")
@Ntrstn("Определение метода может находится только на уровне членов его класса (в т.ч. внутреннего) " +
        "и больше нигде")
@Ntrstn("Тип возвращаемого метода и модификаторы не учитываются при определении сигнатуры ")
@Ntrstn("При перегрузке методов, если для параметра нет собственного метода, то может использоваться " +
        "автоматическое преобразование")
@Ntrstn("Переопределенный метод должен возвращать тот же тип или подтип возвращаемого типа " +
        "родительским методом")
@Ntrstn("При переопределении метода, модификатор доступа не должен становится строже, чем в " +
        "родительском")
@Ntrstn("Метод сможет изменить состояние объекта, переданного в качестве аргумента, но не сможет " +
        "изменить адрес оригинальной ссылки, т.к. работа идет с ее копией")
@Ntrstn("Аргумент переменной длины у метода является массивом, может быть пустым")
@Ntrstn("У методов с аргументом переменной длины могут возникать конфликты при вызове этих методов" +
        "без указания данного параметра (или нулевой длины) - если их сигнатуры в остальном" +
        "совпадают. Но в таком случае, если есть подходящий метод вообще без аргумента перенной " +
        "длины, то выберется именно он")
@Ntrstn("Не путай break и return: break - выход из цикла, return из метода")
@Ntrstn("К статическим членам можно обратиться не только через имя класса, но и через имя объекта")
@Ntrstn("Метод, возвращающий void, также может иметь инструкцию return (без возвращаемого значения), " +
        "однако это так происходит автоматически")
@Ntrstn("\"Статичность\" методов родителя и наследника должна совпадать - иначе ошибка комплитора")
@Ntrstn("При переопределении родительского метода, бросающего исключения, метод наследник может " +
        "ничего не выбрасывать, выбрасывать любое непроверяемое исключение, либо только проверяемое " +
        "исключение из родительского метода (или наследников его типа). Если родительский метод " +
        "ничего не бросает, то метод в наследнике может только ничего не выбрасывать или выбрасывать " +
        "любое непроверяемое исключение, но никакое проверяемое")
@Ntrstn("Если в теле метода есть инструкция throw, то дальнейший код выполнен не будет (об этом " +
        "предупреждает компилятор), но это позволяет не возвращать из метода заявленный тип - т.е. " +
        "инструкция return вообще может отстутсвовать без жалоб компилятора")
public class Method {
    /* ~~~~~~~~~~~~~~~~~~~~~~~~~ОПРЕДЕЛЕНИЕ~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /* ДОЛЖЕН БЫТЬ НА УРОВНЕ ДРУГИХ ЧЛЕНОВ КЛАССА */
    public static int meth(final @NotNull int a) throws ArithmeticException {
        Integer i = 2;
        {
            i += i;
            class Inner {
            }
            i += new Inner() {
                int innerField = 5;
            }.innerField;
        }
        return i / a; // возрващаемый тип должен быть совместим с int
    }

    /* МЕТОД МОЖЕТ ИМЕТЬ ТО ЖЕ ИМЯ, ЧТО И КОНСТРУКТОР */
    public Method() {
    }

    public void Method() {
    }

    /* ПРИМЕРЫ НАЗВАНИЙ */
    void run() {
    }

    void getMoney() {
    }

    void isEmpty() {
    }


    /*~~~~~~~~~~~~~~~~~~~~~~~~~ПЕРЕГРУЗКА МЕТОДА~~~~~~~~~~~~~~~~~~~~~~~~~*/
    static void overload() {
        System.out.println("Вызов overload()");
    }

    static void overload(int i) {
        System.out.println("Вызов overload(int i)");
    }

    static void overload(double d) {
        System.out.println("Вызов overload(double d)");
    }


    /*~~~~~~~~~~~~~~~~~~~~~~~~~СИГНАТУРА МЕТОДА~~~~~~~~~~~~~~~~~~~~~~~~~*/
    void signature() {
    }

    /* ВОЗВРАЩАЕМЫЙ ТИП НЕ УЧИТЫВАЕТСЯ ПРИ ОПРЕДЕЛЕНИИ СИГНАТУРЫ */
//    int signature(){ // та же сигнатура
//        return 4;
//    }

    /* МОДИФИКАТОРЫ НЕ УЧИТЫВАЮТСЯ ПРИ ОПРЕДЕЛЕНИИ СИГНАТУРЫ */
//    static private void signature() {
//    }

    void signature(int e, double d) { // другая сигнатура - отличаются параметры
    }

    void signature(double d, int e) { // другая сигнатура - отличается порядок параметров
    }

    /* МОДИФИКАТОРЫ ПАРАМЕТРА НЕ УЧИТЫВАЮТСЯ ПРИ ОПРЕДЕЛЕНИИ СИГНАТУРЫ */
//    void signature(double d, final int e) { // другая сигнатура - отличается порядок параметров
//    }

    /* ВЫБРАСЫВАЕМЫЕ ИСКЛЮЧЕНИЯ НЕ УЧИТЫВАЮТСЯ ПРИ ОПРЕДЕЛЕНИИ СИГНАТУРЫ */
//    void signature(double d, int e) throws IOException{ // другая сигнатура - отличается порядок параметров
//    }

    /* ПОДСИГНАТУРА МЕТОДА */
    class Parent {
        <T> void toList(Collection<T> c) {
        }

        /*ЭКВИВАЛЕНТНОЕ ПЕРЕОПРЕДЕЛЕНИЕ*/
//        void toList(Collection c) { // после стирания, такая же сигнатура как у toList(Collection<T> c)
//        }
    }

    class Child extends Parent {
        @Override
        void toList(Collection c) {
        }
    }


    /*~~~~~~~~~~~~~~~~~~~~~~~~~ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДА~~~~~~~~~~~~~~~~~~~~~~~~~*/
    class Parent2 {
        protected Number parentMeth() {
            return 3.5;
        }

        private void privateParentMeth() {
        }

        final void finalParentMeth() {
        }
    }

    class Child2 extends Parent2 {
        @Override
        /* ВОЗВРАЩАЕМЫЙ ТИП ДОЛЖЕН БЫТЬ СОВМЕСТИМ С РОДИТЕЛЬСКИМ */
        /* МОДИФИКАТОР ДОСТУПА НЕ ДОЛЖЕН БЫТЬ СТРОЖЕ, ЧЕМ У РОДИТЕЛЬСКОГО МЕТОДА */
        protected Integer parentMeth() {
            super.parentMeth(); // вызов родительского метода
            return 3;
        }

        /* ЯВЛЯЕТСЯ НЕ ПЕРЕОПРЕДЕЛЕНИЕМ, А ПРОСТОЙ ПЕРЕГРУЗКОЙ */
        // @Override - ошибка компилятора
        Number parentMeth(int i) { // т.к. сигнатура не совпадает с родительским методом
            return 3.5;
        }

        /* НАСЛЕДНИК НЕ ВИДЕТ PRIVATE МЕТОДЫ РОДИТЕЛЯ */
        private void privateParentMeth() {
        }

        /* FINAL МЕТОДЫ РОДИТЕЛЯ НЕЛЬЗЯ НАСЛЕДОВАТЬ */
//        final void finalParentMeth() { // ошибка компилятора
//        }
    }


    /*~~~~~~~~~~~~~~~~~~~~~~~~~ПЕРЕМЕННОЕ ЧИСЛО АРГУМЕНТОВ~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /* ЯВЛЯЕТСЯ МАССИВОМ */
    static void varArgMeth(int... ints) {
        System.out.println(ints.length);
        if (ints.length > 3) {
            System.out.println(ints[6]); // ArrayIndexOutOfBoundsException, если нет такого элемента
        }
    }

    /* ДОЛЖЕН БЫТЬ ПОСЛЕДНИМ В СПИСКЕ ПАРАМЕТРОВ */
//    static void varArgMeth2(int... ints, int i){
//    }

    /* ДОЛЖЕН БЫТЬ ЕДИНСТВЕННЫМ АРГУМЕНТОМ ПЕРЕМЕННОЙ ДЛИНЫ */
//    static void varArgMeth3(int... ints, boolean... booleans) {
//    }

    /* МОГУТ БЫТЬ КОНФЛИКТЫ ПРИ ПЕРЕГРУЗКЕ */
    static void varArgConflict(int... i) {
        // вызов, когда нет параметров
        // вызов, когда параметр один и он int
    }

    static void varArgConflict(boolean... b) {
        // вызов, когда нет параметров
    }

    static void varArgConflict(int a, int... i) {
        // вызов, когда параметр один и он int
    }

    /*ЭТОТ МЕТОД РАЗРЕШАЕТ КОНФЛИКТ ПРИ ВЫЗОВЕ МЕТОДА БЕЗ ПАРАМЕТРОВ */
    static void varArgConflict() {
        // вызов, когда нет параметров
    }

    /*~~~~~~~~~~~~~~~~~~~~~~~~~ВЫЗОВ МЕТОДА~~~~~~~~~~~~~~~~~~~~~~~~~*/
    static void passByValue(int i, InnerMeth object) {
        i = 1; // значение оригинальной i не изменится
        object.innerMethValue = 1; // значение поля объекта по оригинальной ссылке изменится
        object = new InnerMeth(); // оригинальной ссылке новый объект НЕ будет присвоен
    }

    static class InnerMeth {
        int innerMethValue;
    }


    /*~~~~~~~~~~~~~~~~~~~~~~~~~ВОЗВРАЩЕНИЕ ИЗ МЕТОДА~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /*RETURN МОЖЕТ БЫТЬ И В VOID МЕТОДЕ*/
    void returnMeth() {
        return;
    }

    static String returnMeth2(int i) {
        if (i > 0) {
            return "Положительное"; // выход из метода
        }

        if (i == 0) {
            for (int j = 0; j < 3; j++) {

                for (int k = 0; k < 3; k++) {
                    break; // выход из цикла
//                    return "В цикле 2"; // не достижимая операция
                }
                return "В цикле 1"; // выход из метода
            }
        }

        return "Отрицательное"; // выход из метода
    }

    Number returnClassMeth() {
        return new Integer(3); // возвращаемый тип должен быть совместим с типом в декларации
    }

    BiFunction returnInterface() {
        return (x, y) -> null; // возвращаю BinaryOperator, а он наследник BiFunction
    }


    /*~~~~~~~~~~~~~~~~~~~~~~~~~СТАТИЧЕСКИЙ МЕТОД~~~~~~~~~~~~~~~~~~~~~~~~~*/
    /*СТОИТ МОДИФИКАТОР STATIC*/
    static void staticMeth() {
        /*ОБРАЩЕНИЕ ЧЕРЕЗ ИМЯ КЛАССА*/
        Method.staticMeth();

        /*ТАКЖЕ МОЖНО ОБРАТИТСЯ ЧЕРЕЗ ИМЯ ОБЪЕКТА */
        Method method = new Method();
        method.staticMeth();

        /* ИМЕЮТ ПРЯМОЙ ДОСТУП К СТАТИЧЕСКИМ ЧЛЕНАМ */
        returnMeth2(2);

        /* НЕ ИМЕЮТ ДОСТУПА К НЕСТАТИЧЕСКИМ ЧЛЕНАМ */
//        regularMeth();

        /*НЕ МОГУТ ИСПОЛЬЗОВАТЬ THIS ИЛИ SUPER*/
//        this.getMoney();
//        super.toString();
    }

    /* МОГУТ БЫТЬ ПЕРЕГРУЖЕНЫ */
    static void staticMeth(int i) {
    }

    void regularMeth() {
        /*МЕТОДЫ ЭКЗЕМПЛЯРА ИМЕЮТ ПРЯМОЙ ДОСТУП К СТАТИЧЕСКИМ МЕТОДАМ КЛАССА */
        staticMeth();
    }


    /*~~~~~~~~~~~~~~~~~~~~~~~~~ОБОБЩЕННЫЙ МЕТОД~~~~~~~~~~~~~~~~~~~~~~~~~*/

    /* ВНУТРИ ОБОБЩЕННОГО КЛАССА ВСЕ МЕТОДЫ ЯВЛЯЮТСЯ ОБОБЩЕННЫМ */
    class Generic<T> {
        void meth() {
            ArrayList<T> list = new ArrayList(); // использование обобщенного типа класса в методе
        }
    }

    /* МОЖЕТ БЫТЬ ВНУТРИ НЕ ОБОБЩЕННОГО КЛАССА */
    class NonGeneric {
        <E> void genericMeth(ArrayList<E> list) {
        }

        <E> void genericMeth2(ArrayList<E> list) {
        }
    }

    /* МОЖЕТ БЫТЬ ПЕРЕОПРЕДЕЛЕН */
    class NonGenericChild extends NonGeneric {
        @Override
        <E> void genericMeth(ArrayList<E> list) {
        }

        /* ПЕРЕОПРЕДЕЛЕНИЕ С УЧЕТОМ ПОДСИГНАТУРЫ */
        @Override
        void genericMeth2(ArrayList list) {
        }
    }


    public static void main(String[] args) {
        /* ПРОВЕРКА ВЫЗОВОВ ПЕРЕГРУЖЕННЫХ МЕТОДОВ */
        overload(); // overload()
        overload(4); // overload(int i)
        float f = 3.4f;
        overload(f); // overload(double d)


        /* ПРОВЕРКА ПЕРЕДАЧИ ПО ЗНАЧЕНИЮ */
        int primitive = 0;
        InnerMeth object = new InnerMeth();
        object.innerMethValue = 0;
        passByValue(primitive, object);
        System.out.println(primitive); // 0
        System.out.println(object.innerMethValue); // 1


        /* ПРОВЕРКА АРГУМЕНТА ПЕРЕМЕННОЙ ДЛИНЫ */
        varArgMeth(2, 3, 5);
        varArgMeth(new int[]{2, 3, 5}); // тоже самое
        varArgMeth(); // можно вызвать без аргументов вообще
//        varArgMeth(2, 3, 5, 6); // ArrayIndexOutOfBoundsException, т.к. внутри вызов 6-ого индекса
//        varArgConflict(1); // ошибка компилятора - varArgConflict(int... i) или varArgConflict(int a, int... i)
        varArgConflict(); // конфликта нет - автоматически выбирается метод без аргументов


        /* ПРОВЕРКА ВЫХОДА ИЗ МЕТОДА */
        System.out.println(returnMeth2(-10)); // Отрицательное
        System.out.println(returnMeth2(10)); // Положительное
        System.out.println(returnMeth2(0)); // В цикле 1
    }
}


class A {
    static void meth() {
    }

    static void meth2() {
    }

    final static void meth3() {
    }
}

class B extends A {
    /*НЕ ЯВЛЯЕТСЯ ПЕРЕОПРЕДЕЛЕНИЕМ */
    //    @Override
    static void meth() { // затемняет метод суперкласса
    }

    /* СТАТИЧНОСТЬ НЕ ДОЛЖНА ОТЛИЧАТЬСЯ */
//    void meth2(){ // ошибка компилятора
//    }


    /* ФИНАЛИЗИРОВАННЫЕ СТАТИЧЕСКИЕ МЕТОДЫ НЕЛЬЗЯ ДАЖЕ ЗАТЕМНИТЬ */
//    static void meth3(){
//    }
}
