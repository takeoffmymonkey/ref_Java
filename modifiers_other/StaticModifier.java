package modifiers_other;

public abstract class StaticModifier {
    /* СТАТИЧЕСКОЕ ПОЛЕ
     * - инициализируется во время загрузки класса
     * - едины для всех экземпляров класса (1 ссылка)
     * - обращение через ИмяКласса.статическаяПеременная
     * - не сериализуются (только при реализации интерфейса Serializable)*/
    static int staticField;

    /*КОНСТРУКТОР
     * - не может быть статическим
     * - внутренний вызов конструктора (своего или суперкласса) с аргументом внутри - только с
     * использованием статической переменной*/
    StaticModifier() {
        this(staticField);
    }

    /*КОНСТРУКТОР С АРГУМЕНТОМ (для теста)*/
    StaticModifier(int staticField) {
    }

    /* СТАТИЧЕСКИЙ МЕТОД
     * - имеет доступ только к статическим переменным
     * - обращение через ИмяКласса.статическийМетод*/
    static void staticMethod() {
        /* ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ
         * - не могут быть статичными*/
        int a = 2;
    }

    /* ПЕРЕОПРЕДЕЛЕНИЕ МЕТОДА СУПЕРКЛАССА
     * - нельзя сделать статическим */
    @Override
    public String toString() {
        return super.toString();
    }

    /* АБСТРАКТНЫЙ МЕТОД
     * - не может быть объявлен статическим*/
    abstract void abstractMethod();


    /* СТАТИЧЕСКИЙ БЛОК
     * - выполняется во время загрузки класса
     * */static {
    }

    /* СТАТИЧЕСКИЙ (ВЛОЖЕННЫЙ) КЛАСС */
    static class StaticInnerClass {
    }

    /* ВНУТРЕННИЙ ИНТЕРФЕЙС
     * - может быть статическим, но это лишнее*/
    static interface StaticInnerInterface {
    }
}


/*ВНЕШНИЙ ИНТЕРФЕЙС
 * - не может быть статический*/
interface NonstaticOuterInterface {
    /*ПЕРЕМЕННАЯ ИНТЕРФЕЙСА
     * - всегда public static final*/
    int alwaysPublicStaticFinalVar = 0;

    /*МЕТОД ИНТЕРФЕЙСА
     * - может быть статический (с J8?)
     * - должен иметь тело*/
    static void staticMethod() {
        // Обязательное тело
    }
}