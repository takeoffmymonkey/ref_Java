package numbers_Numbers;

/* КЛАСС NUMBER
 * public abstract class Number
 * extends Object
 * implements Serializable
 * - известные наследники: AtomicInteger, AtomicLong, BigDecimal, BigInteger, Byte, Double,
 * DoubleAccumulator, DoubleAdder, Float, Integer, Long, LongAccumulator, LongAdder, Short
 * - абстрактный суперкласс для оболочек примитивных чисел */


/* МЕТОДЫ NUMBER (реализуются в конкретных классах)
 * ...Value () - возвращает указанное число в виде указанного типа (может привести к округлению или
 * усечению) */


/*ЗАЧЕМ НУЖНЫ ОБОЛОЧКИ
 * - передача объекта в качестве аргумента метода (часто используется при манипуляциях с коллекциями
 * чисел)
 * - использование констант этих классов (например, MIN_VALUE, MAX_VALUE)
 * - преобразование строки в нужную систему счисления и наоборот - parse...() */


/* ОБОЛОЧКИ ЯВЛЯЮТСЯ ФИНАЛИЗИРОВАННЫМИ КЛАССАМИ
 * - запрещено наследование*/


/* РЕАЛИЗУЮТ ИНТЕРФЕЙС COMPARABLE*/


/*ИМЕЮТ КОНСТРУКТОРЫ ДЛЯ ПРИМИТИВОВ И СТРОК
 * - но примитивом можно создавать объект без помощи конструктора (автоупаковка)
 * - у float есть еще конструктор с double
 * - если строка не является числом - NumberFormatException (в рантайме, но даже без обращения к
 * переменной!!!)*/


/* TOSTRING() ВОЗВРАЩАЕТ ЗНАЧЕНИЕ В ВИДЕ СТРОКИ */


/* ПОЗВОЛЯЕТ СОЗДАВАТЬ МАССИВЫ И ОБЪЕКТОВ РАЗНЫХ ТИПОВ */


/* ЦЕЛОЧИСЛЕННЫЕ МОЖНО ИСПОЛЬЗОВАТЬ В ОПЕРАТОРЕ SWITCH
 * - благодаря автоупаковке*/


/* ПРИ СОЗДАНИИ ОБЪЕКТОВ FLOAT И LONG НУЖНО ЯВНО УКАЗЫВАТЬ ТИП ЛИТЕРАЛА*/


/* ПОВЕДЕНИЕ ПРИ ПРЕОБРАЗОВАНИЯХ (ПО СРАВНЕНИЮ С ПРИМИТИВАМИ)
 * - АВТОМАТИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ:
 *      + продвижение типов при присваивании: аналогично, только если присваивается в примитив
 *      + продвижение типов в выражениях: полностью аналогично
 *      + в выражениях совмещенного присваивания автоматического продвижения не происходит:
 *          - повышение аналогично не происходит (так же возможна потеря данных)
 *          - но работает не по той же формуле
 *          - операция возможна только с совместимым типом (с учетом повышения некоторых из них в
 *          выражениях)
 *
 * - РУЧНОЕ ПРЕОБРАЗОВАНИЕ:
 *      + стандартные правила, если приводится примитив к обертке
 *      + обертки напрямую к примитивам не приводятся, так как являются объектами, и не являются
 *      наследниками друг друга
 *
 * - ПЕРЕПОЛНЕНИЕ:
 *      + аналогично для инкрементации/декрементации
 *      + совмещенное присваивание - работает проверка типа результата выражения
 *          - т.е. в byte, short не получится вписать выражение с результатом int*/


import java.util.ArrayList;

public class NumberMain {
    static byte byteA;
    static int intA;

    static Integer intB = 0;

    public static void main(String[] args) {
        /* ПОТЕРЯ ДАННЫХ (ПЕРЕПОЛНЕНИЕ)*/
        intB = 200;
        byteA = intB.byteValue(); // -56


        /* ИСПОЛЬЗОВАНИЕ */
        ArrayList<Integer> list = new ArrayList<>(); // в коллекциях нельзя использовать примитивы
        intA = Integer.MAX_VALUE; // назначить максимальное значение для типа
        intA = Integer.parseInt("234324"); // перевести строку в нужный тип


        /* ОБОЛОЧКИ ЯВЛЯЮТСЯ ФИНАЛИЗИРОВАННЫМИ КЛАССАМИ
         * - запрещено наследование*/
        // class i extends Integer


        /* РЕАЛИЗУЮТ ИНТЕРФЕЙС COMPARABLE */
        intB.compareTo(intA); // даст 1, 0 или -1


        /*ИМЕЮТ КОНСТРУКТОРЫ ДЛЯ ПРИМИТИВОВ И СТРОК
         * - но примитивом можно создавать объект без помощи конструктора
         * - у float есть еще конструктор с double
         * - если строка не является числом - NumberFormatException (в рантайме, но даже без
         * обращения к переменной!!!)*/
        Integer integer = new Integer(2334533);
        Integer integer1 = new Integer("2334533");
        Integer integer2 = 2334533; // автоупаковка
        Float float1 = new Float("34.4f");
        Float float2 = new Float("34.4");
        // Integer integer3 = new Integer("fsdfs"); // сразу в рантайме даст NumberFormatException


        /* TOSTRING() ВОЗВРАЩАЕТ ЗНАЧЕНИЕ В ВИДЕ СТРОКИ */
        System.out.println(intB.toString()); // даст 200


        /* ПОЗВОЛЯЕТ СОЗДАВАТЬ МАССИВЫ И ОБЪЕКТОВ РАЗНЫХ ТИПОВ */
        Number[] numbers = {23, intB, 234L, 0.22};


        /* ЦЕЛОЧИСЛЕННЫЕ МОЖНО ИСПОЛЬЗОВАТЬ В ОПЕРАТОРЕ SWITCH*/
        intB = 2;
        switch (intB) {
            case 1:
                System.out.println("case 1");
                break;
            case 2:
                System.out.println("case 2");
                break;
            default:
                System.out.println("default case");
        }



        /* ПРИ СОЗДАНИИ ОБЪЕКТОВ FLOAT И LONG НУЖНО ЯВНО УКАЗЫВАТЬ ТИП ЛИТЕРАЛА*/
        // Float f = 23.2; // нельзя
        Float f = 23.2f;
        // Long l = 322; // нельзя
        Long l = 322L;
        Byte b = 2;
    }
}