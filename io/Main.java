package io;

/* ФУНКЦИОНАЛ IO (НАХОДИТСЯ В ПАКЕТАХ JAVA.IO И JAVA.NIO)
 * - ввод и вывод через потоки данных, сериализацию и файловую систему
 * - наборы символов, декодеры и кодировщики для перевода между байтами и символами Unicode.
 * - доступ к файлу, его атрибутам и файловым системам
 * - API для постройке масштабируемых серверов при помощи асинхронного или мультиплексового
 * неблокирующего I/O */


/* JAVA.IO
 * - используется для системного IO через потоки данных и сериализацию
 *
 * - поток: НЕПРЕРЫВАЕМАЯ последовательность данных
 *
 * - потоки поддерживают разные типы данных, в т.ч.:
 *      - простые байты
 *      - примитивы
 *      - локализированные символы
 *      - объекты
 *
 * - входящий поток для чтения данных из источника, исходящий поток для записи данных в цель
 *
 * - байтовые потоки для байтового IO и символьные потоки для символьного IO
 *      - все классы байтовых потоков наследуют от InputStream или OutputStream
 *      - все классы символьных потоков наследуют от Reader или Write
 *      - байты/символы читаются/пишутся 1 за 1 в цикле
 *          - можно использовать буферизированные потоки BufferedInputStream/BufferedReader и
 *          BufferedOutputStream/BufferedWriter для улучшения производительности операций IO
 *              - оборачивают небуфиризированные потоки
 *              - читают данные из области памяти (буфера)
 *
 * - операции IO являются блокирующими
 *
 * - FILE IO:
 *      - класс File: представляет путь к файлу или папке
 *      - класс RandomAccessFile: чтение и запись в файл с неупорядоченным доступом */


/* JAVA NIO
 * - является расширением, а не заменой java.io
 *
 * - предоставляет высокоэффективный IO для операций на большинстве ОС
 *      - буферы для примитивных типов
 *      - кодеры/декодеры наборов символов
 *      - сверка с паттерном регуляртного выражения
 *      - каналы - трубопроводы, которые передают данные между буферами и сущностями на другом конце
 *          - данные помещаются в буфер, а буфер передается в канал
 *          - или данные забираются в буфер из канала
 *          - позволяют использовать нативные сервисы ОС без оверхеда
 *          - могут работать в блокирующем и неблокирующем режимах: только для
 *          stream-ориентированных потоков, напр. сокетов
 *          - FileChannel: RW канал
 *              - всегда блокирующий
 *              - не могут создаваться напрямую, а через getChannel() на файловом объекте типа
 *              RandomAccessFile, FileInputStream, или FileOutputStream
 *              - потокобезопасен
 *
 *      - файловый интерфейс, поддерживающий локи и мапинг памяти
 *      - мультиплексированные неблокирующие удобства для написания масштабируемых серверов
 *
 * */


/* IO VS NIO
 * - конструкции NIO делают операции IO быстрее традицонного IO, так как они ближе к нативному IO ОС
 * - чем больше размер передачи, тем заметнее
 * - NIO также предоставляет другие недоступные в IO фичи для потоковых операций
 * - но невозможно полностью заменить IO на NIO, так как NIO добавляет функционал к java.io
 *      - расширяет нативный IO API, добавляя новые возможности по манипулированию потоков данных
 *      более мощным способом */


/* IO VS NIO
 * - IO: удобно, когда нужно держать открытыми ширококанальные подключения (напр. P2P)
 *      - ориентирован на поток (stream):
 *          - чтение 1 или нескольких байт за раз из потока
 *              - они нигде не кешируются
 *              - нельзя двигаться вперед-назад по потоку
 *                  - чтобы можно было - нужно сперва закешировать их в буфер
 *      - блокирующий IO:
 *          - когда ветка вызывает read/write, она блокируется до конца выполнения
 *
 * - NIO: удобно, когда нужно управлять кучей малых коротких подключений одновременно (напр. чат)
 *      - ориентирован на буфер (buffer):
 *          - данные читаются в буфер, который затем обрабатывается
 *          - можно двигаться по буферу вперед-назад
 *      - неблокирующий IO:
 *          - ветка может запросить у канала чтение данных и получить только то, что сейчас доступно,
 *          или ничего, если ничего не доступно
 *              - не обязана ждать, пока появятся данные
 *              - аналогично с записью
 *              - может теперь заняться другими каналами
 *          - поэтому сложнее в работе, т.к. нужно постоянно запрашивать, заполнился ли буфер, чтобы
 *          можно было с ним работать
 *      - селекторы:
 *          - позволяют одной ветке мониторить несколько каналов входа, которые зарегистрированы в
 *          селекторе
 * */


/* ПАКЕТЫ
 * - java.io: поддержка системного IO при помощи потоков данных, сериализации и файловой системы
 *
 * - java.nio: буферы (контейнер данных) для "кусочных" операций с памятью. Буферы могут быть
 * аллоцированы прямо в памяти для высокой скорости
 *
 * - java.nio.channels: каналы - т.е. связь между устройствами, способными производить операции IO.
 * Также определяет селекторы для мультиплексированного неблокирующего IO
 *
 * - java.nio.channels.spi: имплементации для пакета java.nio.channels
 *
 * - java.nio.file: интерфейсы и классы для доступа к файлам, их атрибутам и файловой системе
 *
 * - java.nio.file.attribute: интерфейсы для и классы для доступа к атрибутам файловой системы
 *
 * - java.nio.file.spi: классы для создания имплементации файловой системы
 *
 * - java.nio.charset (description): наборы символов, кодеры/декодеры для перевода между байтами и
 * символами Unicode
 *
 * - java.nio.charset.spi: имплементации для наборов символов
 *
 * - com.sun.nio.sctp: API для Stream Control Transport Protocol (надежный ориентированный на
 * сообщения транспортный протокол) */








/* IO VS NIO VS NIO
 * - IO:
 *      - с 1.0
 *
 *
 * - NIO:
 *      - c 1.4
 *
 *
 * - NIO.2:
 *      - c 1.7
 *
 *
 *
 *
 * */


/*
 * - Файл идентифицируется своим путем в файловой системе, начиная с корневого узла
 *      - может быть файлом либо каталогом
 *
 * - Путь может быть:
 *      - абсолютным: от корневого узла
 *      - относительным: для нахождения файла должен быть объединен с другим
 *
 * - Делимитер - символ, используемый для разделения имен папок - специфичен для системы:
 *      - Windows: \
 *      - Solaris: /
 *
 *
 * - Некоторые системы поддерживают символические ссылки(symlink/soft link): специальный файл,
 * который служит ссылкой на другой файл
 *      - обычно операции с ними прозрачны для приложений - происходит автоматическая переадресация
 *      - при удалении или переименовании ссылки, сам объект по ссылке не меняется
 *      - разрешение ссылки - подстановка реального файла по адресу
 *
 * - Некоторые системы поддерживают жесткие символические линки:
 *      - адресат у линки обязан существовать
 *      - обычно запрещены для папок
 *      - должны ссылаться на то, что находится на том же диске и файловой системе
 *      - выглядит и ведет себя как обычный файл
 *
 * */


/* LEGACY FILE I/O CODE (до J7/API 26)
 * - недостатки:
 *      - многие методы не выбрасывали исключения при фейлах
 *          - например, при удалении файла и фейле, невозможно узнать из-за чего фейл: нет файла или
 *          разрешений и т.д.
 *      - метод rename не работал одинаково на всех платформах
 *      - не было нормальной поддержки симлинков
 *      - не было достаточной поддержки метаданных: разрешений, владельца файла, атрибутов безопасности
 *      - доступ к метаданным был не эффективным
 *      - многие методы File не масштабировались:
 *          - запрос листинга большой папки от сервера мог приводить к подвисанию
 *          - большие папки также могли приводить к проблемам с ресурсами памяти
 *      - нельзя было написать безопасный код для прохода по дереву каталога и адекватно обрабатывать
 *      рекурсивные симлинки
 *
 * - перевод File в Path и обратно:
 *      Path input = file.toPath();
 *      File file = Path.toFile(input);
 *
 * - соответствие функционала:
 *      - IO: java.io.File
 *      - NIO: java.nio.file.Path
 *
 *      - IO: java.io.RandomAccessFile
 *      - NIO: SeekableByteChannel
 *
 *      - IO: File.canRead, canWrite, canExecute
 *      - NIO: Files.isReadable, Files.isWritable, and Files.isExecutable
 *
 *      - IO: Files.isReadable, Files.isWritable, and Files.isExecutable
 *      - NIO: Files.isDirectory(Path, LinkOption...), Files.isRegularFile(Path, LinkOption...), and Files.size(Path)
 *
 *      - IO: File.lastModified() and File.setLastModified(long)
 *      - NIO: Files.getLastModifiedTime(Path, LinkOption...) and Files.setLastMOdifiedTime(Path, FileTime)
 *
 *      - IO: setExecutable, setReadable, setReadOnly, setWritable
 *      - NIO: setAttribute(Path, String, Object, LinkOption...)
 *
 *      - IO: new File(parent, "newfile")
 *      - NIO: parent.resolve("newfile")
 *
 *      - IO: File.renameTo
 *      - NIO: Files.move
 *
 *      - IO: File.delete
 *      - NIO: Files.delete
 *
 *      - IO: File.createNewFile
 *      - NIO: Files.createFile
 *
 *      - IO: File.deleteOnExit
 *      - NIO: createFile(DELETE_ON_CLOSE)
 *
 *      - IO: File.createTempFile
 *      - NIO: Files.createTempFile(Path, String, FileAttributes<?>), Files.createTempFile(Path, String, String, FileAttributes<?>)
 *
 *      - IO: File.exists
 *      - NIO: Files.exists and Files.notExists
 *
 *      - IO: File.compareTo and equals
 *      - NIO: Path.compareTo and equals
 *
 *      - IO: File.getAbsolutePath and getAbsoluteFile
 *      - NIO: Path.toAbsolutePath
 *
 *      - IO: File.getCanonicalPath and getCanonicalFile
 *      - NIO: Path.toRealPath or normalize
 *
 *      - IO: File.toURI
 *      - NIO: Path.toURI
 *
 *      - IO: File.isHidden
 *      - NIO: Files.isHidden
 *
 *      - IO: File.list and listFiles
 *      - NIO: Path.newDirectoryStream
 *
 *      - IO: File.mkdir and mkdirs
 *      - NIO: Path.createDirectory
 *
 *      - IO: File.listRoots
 *      - NIO: FileSystem.getRootDirectories
 *
 *      - IO: File.getTotalSpace, File.getFreeSpace, File.getUsableSpace
 *      - NIO: FileStore.getTotalSpace, FileStore.getUnallocatedSpace, FileStore.getUsableSpace, FileStore.getTotalSpace
 * */


/* NIO (new IO) - неблокирующее IO - набор API для интенсивных IO операций.
 * - Был добавлен в 1.4
 * - дополняет существующий IO
 *
 *
 * - NIO2 - расширение для NIO, предоставляет новое API файловой системы
 * - был добавлен в 1.7
 * */


/*Поток
 * [РЕСУРС ДАННЫХ] -> -> (входящий поток) -> -> [ПРОГРАММА] -> -> (исходяший поток) -> -> [ЦЕЛЬ ДАННЫХ]
 * - Чтение с потока:
 *      - идентифицировать ресурс (напр. файл, строка, массив, сетевое подключение)
 *      - построить входящий поток при помощи идентифицированного ресурса
 *          - поток сразу предоставляется программе для чтения, его не нужно отдельно открывать
 *      - прочитать данные из входящего потока
 *          - обычно в цикле, 1 единица данных за другой, до уведомления о конце потока
 *      - закрыть входящий поток
 *
 * - Запись в поток:
 *      - идентифицировать цель (напр. файл, строка, массив, сетевое подключение)
 *      - построить исходящий поток при помощи идентифицированной цели
 *          - поток сразу предоставляется программе для записи, его не нужно отдельно открывать
 *      - записать данные в исходящий поток
 *      - закрыть поток
 *
 * - потоки основаны на Декораторе
 * */

/* NIO
 * - здесь операции IO идут с каналами и буферами
 * - канал - как поток - представляет связь между ресурсом/целью и программой для передачи данных, но
 * в отличие от потока, является двунаправленным
 *      - из канала можно читать и в него можно писать
 *      - можно получать read-only, write-only и read-write каналы в зависимости от необходимости
 * - потоки читают пишут побайтово, что очень медленно - NIO решаает эту проблему: передача идет не
 * байтами, а буферами
 *      - буфер - контейнер для данных с установленным верхним лимитом
 * - чтобы записать в цель:
 *      - нужно записать данные в буфер
 *      - затем передать его в канал
 *      - после этого данные будут из буфера записаны в цель
 *
 * - чтобы прочитать из источника:
 *      - нужно передать буфер в канал
 *      - канал считывает данные в буфер
 *      - затем я считывают данные из буфера
 *
 * - т.е. ключевыми действиями являются запись и чтение данных из буфера
 *
 * */


/* NIO2
 * - добавлено много фич, связанных с эффективной работой с файловой системой и отсутствующих в
 * оригинальном IO
 * - с 1.7
 * - добавлены пакеты:
 *      - java.nio.file
 *      - java.nio.file.attribute
 *      - java.nio.file.spi
 *
 * - некоторые фичи:
 *      - возможность работы с разными ФС в 1 унифицированном виде
 *          - поддержка ФС расширяема - можно использовать дефолтные имплементации либо
 *          имплементировать самостоятель
 *      - поддержка базовых файловых операций (копирование, перенос и удаление) для все ФС
 *          - возможность атомический файловых операций переноса
 *          - улучшенная работа с обработкой исключений
 *      - поддержка симлинков
 *          - когда возможно, в операциях с симлинками осуществляется переход к их целям
 *      - (одно из главных дополнений) поддержка доступа к атрибутам файловой системы и файлов
 *      - возможность создавать сервис отслеживания событий (напр. добавление новых файлов) в
 *      директории
 *          - программа получает уведомление при наступлении отслеживаемого события
 *      - API для прохода по файловому дереву
 *          - возможность производить операции с узлами
 *      - поддержка асинхронного IO для сетевых сокетов и файлов
 *      - мультикастинг при помощи DatagramChannel
 *
 * */

import types_references_annotations.my_annotations.Ntrstn;

@Ntrstn("NIO является не заменой IO, а скорее расширением")
@Ntrstn("Одним из главных различий IO и NIO является то, что второй выполняет операции, не блокируя")
public class Main {
}
