package operators_bitwise;

/* Значение левого операнда перемещается влево на количество битов, указанное в правом операнде*/

public class MoveLeft {
    /* - только для целочисленных: long, int, short, char и byte*/
    static int intA = 60; //   (0000 0000 0000 0000 0000 0000 0011 1100)
    static byte byteB = 60; // (0011 1100)
    static int intC = -2147483648; // (1000 0000 0000 0000 0000 0000 0000 0000)


    public static void main(String[] args) {
        System.out.println("\"MoveLeft\"");

        /* ОБЫЧНЫЙ СДВИГ
         * (0000 0000 0000 0000 0000 0000 0011 1100) = 60
         * (0000 0000 0000 0000 0000 0000 1111 0000) = 240*/
        System.out.println(intA << 2); // даст 240


        /* АВТОМАТИЧЕСКОЕ РАСШИРЕНИЕ ДО INT
         * (0000 0000 0000 0000 0000 0000 0011 1100) = 60
         * (0000 0000 0000 0000 0000 0000 1111 0000) = НЕ -32! Происходит расширение до int!!*/
        System.out.println(byteB << 2); // все равно даст 240
        //byte byteD = (byte) byteB << 2; // ДАЖЕ НЕ РАЗРЕШАЕТ ПРИВЕДЕНИЕ! Даже, если указать сдвиг 0
        // Только так
        int intD = byteB << 2;


        /*При сдвиге двоичного разряда значения за пределы, оно теряется
         * (1000 0000 0000 0000 0000 0000 0000 0000) = -2147483648
         * (0000 0000 0000 0000 0000 0000 0000 0000) = 0*/
        System.out.println(intC << 1); // даст 0
    }
}
