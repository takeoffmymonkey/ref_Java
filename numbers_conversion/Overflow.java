package numbers_conversion;

/* ПЕРЕПОЛНЕНИЕ
 * - происходит при присваивании, когда:
 *      + присваеваемый результат выражения не вмещается в целевой тип
 *      + при этом не происходит автоматического продвижения целевого типа (т.е. расширения его
 *      диапазона)
 *
 * - НЕ происходит при присваивании литерала, который не вмещается в целевой тип:
 *      + вместо этого происходит ошибка компилятора */


/*СЛУЧАЕТСЯ
 * - при инкрементации и декрементации целочисленных
 * - в выражениях совмещенного присваивания
 * - при ручном приведении*/


/* ПРИ ПЕРЕПОЛНЕНИИ ПРОИСХОДИТ УСЕЧЕНИЕ ЛИШНИХ СТАРШИХ БИТОВ
 * - это МОЖЕТ соответствовать делению по модулю приводимого значения на диапазон целевого:
 *      + если будущий старший бит это 0 - результат модуля будет соответствовать значению,
 *      которое будет вписано в целевое
 *      + если будущий старший бит это 1 - результат модуля НЕ будет соответствовать значению,
 *      которое будет вписано в целевое. Вписано будет какое-то отрицательное значение в рамках
 *      целевого диапазона */


/*ИНКРЕМЕНТАЦИЯ И ДЕКРЕМЕНТАЦИЯ ЧИСЕЛ
 * - у целочисленных:
 *   + MAX_VALUE меняется местами с MIN_VALUE
 *   + т.е. ведут себя зацикленно
 *
 * - у дробных НЕ ПРОИСХОДИТ:
 *   + при инкрементации значение остается предельным для положительных
 *   + при декрементации значение остается предельным для отрицательных*/


/* ВЫРАЖЕНИЯ СОВМЕЩЕННОГО ПРИСВАИВАНИЯ
 * - проверка типа не происходит (можно вписать несовместимые типы без ошибки, даже double в byte!!) */


/* РУЧНОЕ ПРИВЕДЕНИЕ
 * - см. ручное приведение
 *
 * */


/* ПОВЕДЕНИЕ В ТИПАХ-ОБЕРТКАХ
 * - аналогично для инкрементации/декрементации
 * - совмещенное присваивание - работает проверка типа результата выражения
 *      + т.е. в byte, short не получится вписать выражение с результатом int*/


/*ТИПЫ
 * - byte (8-bit signed integers); MIN_VALUE: -128; MAX_VALUE: 127
 * - short (16-bit signed integers); MIN_VALUE: -32768; MAX_VALUE: 32767
 * - char (16-bit unsigned integers); MIN_VALUE: 0; MAX_VALUE: 65535
 * - int (32-bit signed integers); MIN_VALUE: -2147483648; MAX_VALUE: 2147483647
 * - long (64-bit signed integers); MIN_VALUE: -9223372036854775808; MAX_VALUE: 9223372036854775807
 * - float (32-bit floating point); MIN_VALUE (не отрицательное): 1.4E-45; MAX_VALUE: 3.4028235E38
 * - double (64-bit floating point); MIN_VALUE (не отрицательное): 4.9E-324; MAX_VALUE: 1.7976931348623157E308
 * - boolean (32-bit signed integers); false, true*/

public class Overflow {
    static byte byteA = 1;
    static short shortA = 1;
    static int intA = 1;
    static char charA = 1;
    static long longA = 1L;
    static float floatA = 1f;
    static double doubleA = 1;

    static Byte byteB = 1;
    static Short shortB = 1;
    static Integer intB = 1;
    static Character charB = 1;
    static Long longB = 1L;
    static Float floatB = 1f;
    static Double doubleB = 1d;

    public static void main(String[] args) {

        /* ПРИ ПЕРЕПОЛНЕНИИ ПРОИСХОДИТ УСЕЧЕНИЕ ЛИШНИХ СТАРШИХ БИТОВ */
        shortA = 129;
        byteA = (byte) shortA; // - 127
        // 0000_0000_1000_0001 обрезаем в byte:
        //           1000_0001 переводим в положительное (сначала инвертируем)
        //           0111_1110 (затем добавляем 1 бит)
        //           0111_1111 получаем 127 (и помним, что должен быть минус)


        /*ЭТО МОЖЕТ СООТВЕТСТВОВАТЬ ДЕЛЕНИЮ ПО МОДУЛЮ ПРИВОДИМОГО ЗНАЧЕНИЯ НА ДИАПАЗОН ЦЕЛЕВОГО
         * - если будущий старший бит это 0 - результат модуля будет соответствовать значению,
         * которое будет вписано в целевое
         * - если будущий старший бит это 1 - результат модуля НЕ будет соответствовать значению,
         * которое будет вписано в целевое. Вписано будет какое-то отрицательное значение в рамках
         * целевого диапазона */
        shortA = 32639; // 0111_1111_0111_1111 - будущий старший бит (8-мой) это 0
        System.out.println(32639 % 256); // даст 127 (или 0111_1111)
        byteA = (byte) shortA;
        System.out.println(byteA); // даст 127

        shortA = 32767; // 0111_1111_1111_1111 - будущий старший бит (8-мой) это 1
        System.out.println(32767 % 256); // даст 255 (или 1111_1111)
        byteA = (byte) shortA;
        System.out.println(byteA); // даст -1


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /*ИНКРЕМЕНТАЦИЯ И ДЕКРЕМЕНТАЦИЯ ЧИСЕЛ*/

        /* ИНКРЕМЕНТАЦИЯ И ДЕКРЕМЕНТАЦИЯ ЦЕЛОЧИСЛЕННЫХ
         * - ведут себя зацикленно
         * - т.е. MAX_VALUE меняется местами с MIN_VALUE*/
        byteA = 127;
        byteA++; // станет -128
        byteA--; // станет снова 127
        shortA = 32767;
        shortA++; // станет -32768
        shortA--; // станет снова 32767
        charA = 65535;
        charA++; // станет 0
        charA--; // станет снова 65535
        intA = 2147483647;
        intA++; // станет -2147483648
        intA--; // станет снова 2147483647
        longA = 9223372036854775807L;
        longA++; // станет -9223372036854775808
        longA--; // станет снова 9223372036854775807

        /* ИНКРЕМЕНТАЦИЯ И ДЕКРЕМЕНТАЦИЯ ДРОБНЫХ
         * - !!! У ДРОБНЫХ ПЕРЕПОЛНЕНИЯ НЕ ПРОИСХОДИТ:
         *      + при инкрементации значение остается предельным для положительных
         *      + при декрементации значение остается предельным для отрицательных*/
        floatA = Float.MAX_VALUE; // 3.4028235E38 или 111_1111_0111_1111_1111_1111_1111_1111
        floatA++; // 3.4028235E38 или 111_1111_0111_1111_1111_1111_1111_1111
        doubleA = Double.MAX_VALUE; // 1.7976931348623157E308 или 111_1111_1110_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111
        doubleA++; // 1.7976931348623157E308 или 111_1111_1110_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111
        floatA = -Float.MAX_VALUE; // -3.4028235E38 или 1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_0111_1111_1111_1111_1111_1111
        floatA--; // -3.4028235E38 или 1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_0111_1111_1111_1111_1111_1111
        doubleA = -Double.MAX_VALUE; // -1.7976931348623157E308 или 1100_0111_1110_1111_1111_1111_1111_1111_1110_0000_0000_0000_0000_0000_0000_0000
        doubleA--; // -1.7976931348623157E308 или 1100_0111_1110_1111_1111_1111_1111_1111_1110_0000_0000_0000_0000_0000_0000_0000


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /*ОПЕРАЦИИ СОВМЕЩЕННОГО ПРИСВАИВАНИЯ
         * 1. доходит до предела
         * 2. меняет диапазонное значение
         * 3. остаток операции проивзодится с ним*/
        byteA = 120; // 0111_1000
        byteA += 19;// даст -117
        // то же, что byteA = (byte) (byteA + 19)
        // 120  = 0111_1000 +
        // 19   = 0001_0011 =
        // -117 = 1000_1011
        // или
        // дойти до предела: 120 + 17 (остаток 2)
        // переход к обратной границе диапазона: -127
        // прибавить остаток: -127 + 2
        byteA = -127;
        byteA -= 3; // даст 126

        /*ПРОВЕРКА ТИПА НЕ ПРОИСХОДИТ
         * - компилятор игнорирует попытку присвоить результат, который не подходит в целевой тип*/
        byteA += 1232131343;
        byteA += 1232131343 + 324453434;
        byteA += 1232131343342342342L;
        byteA += 1232131.42d;


        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
        /* ПОВЕДЕНИЕ В ТИПАХ-ОБЕРТКАХ
         * - аналогично для инкрементации/декрементации
         * - совмещенное присваивание - работает проверка типа результата выражения
         *      + т.е. в byte, short не получится вписать выражение с результатом int*/
        byteB = 127;
        byteB++; // -128
        byteB--; // 127

        byteB = 127;
        //byteB += 1; // не дает вписать результат int
        intB = Integer.MAX_VALUE;
        intB += 12; // -2147483637
    }
}