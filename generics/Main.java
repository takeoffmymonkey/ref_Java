package generics;

import java.io.Closeable;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import _types_references_annotations.my_annotations.Ntrstn;

/* ОБОБЩЕННЫЙ КОД
 * - это код, который предназначен для работы с разными типами
 *
 * - этого можно достичь 2 способами:
 *      - (раньше) использовать в обобщенном коде тип Object (или другой тип, когда нужно ограничить
 *      иерархию сверху) в качестве временной замены реального типа, который приходит в этот код
 *          - в экземпляр обобщенного кода из моего кода можно передать объект любого (или
 *          ограниченного) типа
 *              - т.е. если стоит ограничение Number, я смогу туда передать сначала Integer, а потом
 *              и Number - без предупреждения компилятора
 *                  - но (напр.) коллекция Integer не должна иметь внутри объекты Number!
 *          - когда нужно получить объект обратно, необходимо в моем коде делать обратное приведение
 *          вручную
 *              - т.е. приводить объект обратно к Integer
 *                  - а если вернется тот объект Number - я получу ClassCastException
 *
 *      - (сейчас) использовать "обобщенный синтаксис" с параметром типа
 *          - параметр ведет себя как переменная, в которой находится какой-то реальный переданный
 *          обобщенному коду тип
 *          - для экземпляра обобщенного кода существует только этот конкретный установленный
 *          параметр типа, поэтому в него можно передавать только объекты устанновленного типа или
 *          совместимые с ним
 *              - напр. если установлен тип Number, я могу передать Integer или Double, но не Object
 *                  - т.е. принимаются только те типы, которые можно безопасно привести к
 *                  установленному
 *          - чтобы получить объект обратно, не нужно делать обратное приведение
 *              - приведения автоматически проставляет сам компилятор */


/* ОБОБЩЕНИЯ ПОЗВОЛЯЮТ
 * - разным типам работать с 1 кодом
 *      - функционал обобщенного класса/интерфейса/метода/конструктора одинаково работает для разных
 *      ссылочных типов (классовых и интерфейсных)
 *          - т.е. не нужно дублировать код для всех типов, с которыми он может работать
 *          - но компилятор не знает реальный тип, который передается в экземпляр обобщенного кода
 *
 * - указывать верхний иерархический предел для типов, с которым может работать обобщенный код
 *      - таким кодом можно пользоваться, только если данный тип входит в указанный диапазон
 *          - это открывает доступ к методам класса, который указывается как верхний предел
 *
 * - (если используется "обобщенный синтаксис") избежать ручного приведения типов и связанных с
 * неправильным приведением runtime исключений
 *      - экземпляр обобщенного кода имеет конкретный установленный тип, о котором знает компилятор,
 *      поэтому компилятор:
 *          - не позволит передать в этот код объект несовместимого типа
 *          - самостоятельно автоматически проставит приведения, где объект будет обратно
 *          возвращаться в мой код
 *              - делая мой код чище
 *              - исключая ClassCastException по моей неосторожности
 *          - и т.о. обеспечит типобезопасность на стадии компиляции */


/* ОБОБЩЕННЫЙ ТИП И ПАРАМЕТР ТИПА
 * - сам класс/интерфейс, который оперирует переданным ему параметром типа
 *       - т.е. в объявлении у него указан параметр типа
 *
 * - параметр типа объявляется единижды в треугольных скобках, а дальше используется в обобщенном
 * коде как обычная переменная, внутри которой находится значение переданного типа
 *      - т.е. напр. я указываю его после имени класса в объявлении, а дальше (там же - в объявлении)
 *      указываю, что имплементирую обобщенный интерфейс - а такой интерфейс требует в свои
 *      треугольные скобки уже конкретный параметр типа (ведь это не объявление самого интерфейса, а
 *      объявление о его имплементации). И я могу уже указать вместо конкретного типа этого
 *      интерфейса переменную типа, которую только что объявил для класса.
 *          - т.е. для этой конкретной реализации интерфейса будет использоваться тот тип, который
 *         будет передаться в обобщенный класс как параметр типа при создании экземпляра такого
 *         класса
 *
 * - имя у параметра (переменной) типа может быть какое угодно
 *      - аналогично обычной переменной
 *      - но обычно используют:
 *          - T – тип
 *          - E – элемент
 *          - K – ключи
 *          - V - значения
 *          - N – числа
 *          - S, U, V и т.д. - второй, третий, четвертый и т.д. типы
 *
 * - у 1 обобщенного класса/интерфейса могут быть несколько параметров типа
 *      - перечисляются через запятую в одних треугольных скобках
 *
 * - параметр типа может использоваться внутри обобщенного класса/интерфейса в любом месте, где
 * необходимо указывать конкретный тип для ссылочной переменной или ссылочного параметра (
 * обобщенного метода/конструктор), в качестве:
 *          - классовой переменной
 *          - интерфейсной переменной
 *          - массивной переменной
 *          - аргумента типа при создании экземпляра другого обобщенного кода
 *      - ограничения:
 *          - внутри обобщенного кода нельзя создавать объекты типа, который был указан в качестве
 *          параметра типа для экземпляра этого кода
 *              - т.к. объекты создаются во время работы программы, а реальный тип, переданный
 *              параметру типа обобщенного кода, к этому моменту уже неизвестен (стерт при компиляции)
 *              - в т.ч. массив с таким типом */


/* (КОНКРЕТНЫЙ) ПАРАМЕТРИЗИРОВАННЫЙ ТИП И АРГУМЕНТЫ ТИПА
 * - чтобы обратиться к обобщенному коду, нужен его экземпляр
 *      - при создании экземпляра необходимо указать конкретное значение (аргумент) типа для
 *      параметра типа
 *          - похоже на передачу конкретного значения параметру метода
 *          - напр. ArrayList<String> stringArray = new ArrayList<String>();
 *              - т.е. для данного экземпляра обобщенного класса ArrayList<T>, параметр типа T
 *              становится конкретным типом String
 *
 * - аргументы типа
 *      - должны соответствовать установленным границам параметра типа
 *      - могут быть только:
 *          - ссылочные типы
 *              - т.е. не должны быть примитивами
 *                  - но может быть массивом примитивов
 *                      - т.к. он является объектом
 *          - метасимволы
 *              - т.е. указывается, что тип, с которым создается экземпляр класса/интерфейса точно
 *              неизвестен
 *              - это не работает для обобщенного метода/конструктора
 *                  - todo наверно, потому что им нужен конкретный экземпляр обобщенного типа
 *                  для работы
 *          - переменные типа
 *              - которые действуют в данной области
 *          - другие параметризированные типы
 *              - напр. ArrayList<ArrayList<String>>
 *                  - т.е. для данного экземпляра обобщенного класса ArrayList<T>, T становится
 *                  конкретным типом ArrayList<String> */


/* ОБОБЩЕННЫЕ МЕТОДЫ И КОНСТРУКТОРЫ
 * - методы и конструкторы могут использовать в своем коде параметр типа
 *          - сам класс при этом может оставаться не обобщенным и работать независимо
 *
 * - область действия ограничивается собственным телом
 *
 * - собственные параметры типа указываются в объявлении
 *      - у методов перед возвращаемым типом
 *      - у конструкторов перед его именем
 *      - если метод/конструктор не использует собственные параметры типа, а только те, что указаны
 *      для его класса/интерфейса, то объявлять отдельно такие параметры типа не нужно
 *
 * - обобщенные методы могут быть:
 *      - статические и нестатические
 *          - у статического нет доступа к параметру типа своего класса
 *              - даже если класс статический
 *      - переопределены
 *      - перегружены
 *          - но после стирания типа не должны возникать конфликты
 *
 * - обобщенный параметр, вероятно, будет в списке перадаваемых методу/конструктору параметров, т.к.
 * самостоятельно они не смогут создать экземпляры такого типа
 *
 * - удобно для полиморфизма
 *      - напр. классу нужен Double, но конструктор может принимать любые типы от Number и ниже
 *          - т.к. у Number есть метод doubleValue()
 *              - т.е. можно преобразовать любое переданное значение в Double */


/* ВЕРХНЯЯ ГРАНИЦА ДОПУСТИМЫХ ПАРАМЕТРОВ ОБОБЩЕННЫХ КЛАССОВ/ИНТЕРФЕЙСОВ/МЕТОДОВ/КОНСТРУКТОРОВ
 * - означает, что в качестве параметра принимается только указанный тип и его наследники
 *      - но не родители или другие типы
 *          - т.к. нет безопасной совместимости
 *
 * - благодаря этому ограничению предоставляется доступ к методам указанного типа
 *
 * - указывается при объявлении обобщения словом extends
 *      - используется в общем смысле для обобщенных типов
 *              - т.е. если границей выступает интерфейс, то подразумевается implements
 *
 * - границ может быть несколько
 *      - перечисляются через &
 *          - т.к. запятыми разделяются параметры типа
 *          - т.е. передаваемый тип должен удовлетворять им всем
 *      - классовая граница может быть только 1
 *          - и она должна идти первой в перечислении */


/* ИЕРАРХИЯ НАСЛЕДОВАНИЯ ОБОБЩЕННЫХ ТИПОВ (КЛАССОВ И ИНТЕРФЕЙСОВ) И ПРИВЕДЕНИЕ
 * - наследование обобщенных типов работает так же, как и у обычных типов - через extends/implement:
 *      - у необобщенного родителя может быть обобщенный наследник
 *      - у обобщенного родителя может быть обобщенный наследник с дополнительными параметрами типа
 *      - у обобщенного родителя может быть необобщенный наследник, но наследник обязан передавать
 *      конкретное значение типа вверх по иерархии
 *          - оно указывается в треугольных скобках после имени родителя при объявлении наследования
 *              - оно также может быть переменной типа, объявленной в самом наследнике как параметр
 *              типа
 *          - похоже на передачу аргументов родительскому конструктору вверх по иерархии
 *          - параметр, передаваемый обобщенному родителю не может быть шире, чем он может принять
 *
 * - определение иерархии у конкретных экземпляров обобщенных типов работает по их обобщенному типу,
 * при условии, что аргумент типа у них одинаковый
 *      - Parent <Integer> является родителем для Child <Integer> или Child <Integer, String>
 *          - Child <Integer, String> просто добавил еще 1 параметр, а прежний остался
 *      - Parent <Number> не является родителем для Child <Integer>
 *          - иначе можно было бы назначить ссылку Parent <Number> на объект Child <Integer> и
 *          добавить в него (напр. методом add()) объект типа Number
 *              - но это нарушает типобезопасность
 *          - но в обобщенный метод у экземпляра класса Parent <Number> можно передать Integer
 *              - т.к. проставленные при компиляции приведения являются безопасными для наследников
 *                  new Parent<Number>.add(new Integer(1));
 *          - родителем Child <Integer> является Parent <Integer>
 *          - т.е. параметр типа инвариантен
 *              - инвариантность - куда подходит 1 тип, никакой другой тип подходить не может
 *              - поэтому говорят, что обобщения в Java "инвариантны"
 *      - Parent <Number> не совместим с Parent <Integer>
 *          - по причинам, описанным выше
 *          - у обоих родитель Object
 *      - правила приведения экземпляров стандартные:
 *          - upcast не требует явного приведенения:
 *              Parent <Integer> p = new Child<Integer>;
 *              Parent <Integer> p = new Child<Integer, String>;
 *          - downcast требует явного приведения:
 *              Child <Integer> c = (Child<Integer>) new Parent<Integer>; */


/* ВЫВЕДЕНИЕ АРГУМЕНТОВ ТИПА, ЯВНОЕ И НЕЯВНОЕ УКАЗАНИЕ АРГУМЕНТОВ ТИПА, РОМБОВИДНЫЙ ОПЕРАТОР
 * - c Java7 компилятор может самостоятельно вывести аргументы типа для вызовов обобщенных методов и
 * обобщенных конструкторов (т.е. при создании обобщенных классов)
 *      - можно их явно не указывать
 *
 * - для конструкторов нужно использовать пустые треугольные скобки после имени класса
 *      - т.н. ромбовидный оператор
 *      - т.к. без скобок создается объект базового типа
 *      - аргументы типа могут быть выведены автоматически по:
 *          - целевому типу
 *              - т.е. напр. при помощи аргументов типа у ссылки, которой присваивается данный объект
 *              обобщенного класса
 *          - по передаваемым конструктору аргументам (обычным)
 *              - т.е. при передаче в конструктор объектов, обобщенные параметры конструктора
 *              становятся типами этих объектов
 *
 * - для вызова обобщенных методов треугольные скобки можно полностью опустить перед именем метода
 *      - аргументы типа могут быть выведены автоматически по:
 *          - по передаваемым методу аргументам (обычным)
 *          - и (если возможно) по возвращаемому типу
 *              - напр. обобщенный метод принимает параметр типа и возвращает этот же тип, а
 *              результат работы метода присваивается в объект типа Serializable, следовательно
 *              этим типом должет стать Serializable
 *                  - т.е. по сути по целевому типу
 *      - todo до Java8 компилятор не всегда может определить предлагаемый методу тип
 *          - напр. void processStringList(List<String> stringList){} ожидает список со строками, а
 *          Collections.emptyList() даст ему List<Object>
 *              - т.е. автоматического преобразования не произойдет
 *              - нужно явно указывать аргумент типа:
 *                  processStringList(Collections.<String>emptyList());
 *                  - т.н. type witness */


/* БАЗОВЫЙ ТИП (ОБОБЩЕННОГО ТИПА) И UNCHECKED CONVERSION
 * - базовый тип (raw type) - необобщенная версия обобщенного класса/интерфейса
 *      - т.е. без указания аргумента типа
 *      - напр. List
 *
 * - компилятор больше не гарантирует типовую безопасность
 *      - т.е. базовый тип ведет себя как простой тип, где параметры типа заменены на Object (или
 *      другой тип-ограничение, если он есть)
 *          - т.е. снова требуется ручное приведение
 *              - и снова возможны ClassCastException во время работы
 *          - т.е. доступны методы типа-ограничения
 *      - когда компилятор замечает, что больше не сможет гарантировать типовую безопасноть, он
 *      сообщает об этом при помощи подсказки Unchecked Conversion:
 *              - потеря типобезопасности происходит при:
 *                  - todo создании базового объекта (или ссылки?) - не подтверждено
 *                  - назначении базового объекта обобщенной ссылке
 *                      - в т.ч. при назначении любого объекта через приведение к обобщенной ссылке
 *                  - вызове обобщенного метода у базового объекта
 *              -  потеря типобезопасности не происходит при назначении базовой ссылке обобщенного
 *              объекта
 *                  - т.к. никаких новых потерь не происходит
 *                      - todo об изначальных потерях было сообщено при создании базового объекта
 *              - предупреждения по дефолту отключены
 *              - полностью отключить предупреждения:
 *                  -Xlint:-unchecked flag.
 *              - подавить предупреждение:
 *                  - аннотация @SuppressWarnings("unchecked")
 *
 *  - нужны, чтобы сохранять совместимость со старыми классами коллекций, которые не были обобщенными
 *      - поведение базовых версий эквивалентно поведению классов до Java 5.0
 *          - т.е. внутри вместо параметра типа используется Object или первый ограничивающий тип
 *              - для остальных ограничений компилятор выставляет приведение
 *          - но компилятор не обеспечивает типобезопасность
 *      - если код выше Java 5.0, обязательно надо использовать обобщенные версии */


/* СТИРАНИЕ ОБОБЩЕННОГО ТИПА ПРИ КОМПИЛЯЦИИ
 * - код обобщенного класса компилируется в 1 файл, от которого во время работы создаются различные
 * конкретные экземпляры
 *
 * - при этом (почти) все сведения об обобщенных типах стираются компилятором:
 *      - параметры типа заменяются их типами-ограничениями
 *          - или Object, если нет ограничения
 *          - если ограничений несколько, типом берется первое из них, а для остальных компилятор
 *          ставит приведение, где это требуется
 *              - поэтому если есть маркерные интерфейсы, то для повышения эффективности лучше их
 *              первыми не ставить
 *      - в моем коде, где я получаю обратно свой объект из обобщенного кода, добавляются нужные
 *      приведения типов
 *          - исходя из переданных аргументов типа в обобщенный код
 *      - в итоге в моем коде вместо экземпляров обобщенных классов по сути создаются их обычные
 *      базовые версии (но с указанными выше дополнениями)
 *
 * - в результате стирания могут возникать разные непредвиденные эффекты, в т.ч. ошибки
 * неоднозначности:
 *      - напр. когда у методов с одинаковым названием начинают совпадать сигнатуры
 *          - если это была перегрузка, то нужно изменить названия методов
 *          - если это было переопределение, в наследнике автоматически добавляется мостовой метод:
 *              - его сигнатура соответствует сигнатуре родительского после стирания
 *              - в нем происходит вызов правильного переопределенного метода в наследнике, которому
 *             передаются все параметры, переданные этому (мостовому) методу, но с корректным
 *             приведением
 *              - появляются на уровне байт-кода
 *
 * - благодаря стиранию и обеспечивается совместимость со старым (до Java 5.0) кодом */


/* ВОЗМОЖНОЕ ЗАГРЯЗНЕНИЕ КУЧИ И ОБОБЩЕННЫЕ МЕТОДЫ С ПЕРЕМЕННЫМ ЧИСЛОМ ПАРАМЕТРОВ
 * - загрязнение кучи (Heap Pollution) происходит, когда объект по ссылке не совместим (не является
 * наследником) с типом самой ссылки, напр:
 *      List<A> listOfAs = new ArrayList<>();
 *      List<B> listOfBs = (List<B>)(Object)listOfAs; // listOfAs не совместим с List<B>
 *
 * - обобщенные методы с переменным числом параметров могут приводить к загрязнению кучи
 *      - компилятор переводит формальные параметры varargs в массив, чего (вообще-то) нельзя делать:
 *          T... elements -> T[] elements -> Object[] elements
 *              - т.к. теперь это массив типа Object, в него можно записывать любые типы, значит:
 *                  - возможно загрязнение кучи
 *                  - компилятор больше не гарантирует типобезопасность
 *      - раньше, при каждом вызове такого метода компилятор выводил предупреждение "unchecked
 *      generics array creation for varargs parameter", и нужно было его подавлять
 *          - теперь автор метода может указать @SafeVarargs, если уверен, что все правильно, и
 *          избавить от необходимости подавления пользователями метода
 *              - аннотация требует, чтобы метод был статический или финализирован */


/* ДОСТУПНОСТЬ ИНФОРМАЦИИ О ТИПЕ В RUNTIME, НЕМАТЕРИАЛИЗИРУЕМЫЕ ТИПЫ И ПРОВЕРКА ТИПА ПРИ ПОМОЩИ
 * INSTANCEOF
 * - доступность виртуальной машине информации о типе (т.е. в runtime) позволяет:
 *      - узнавать тип при помощи оператора instanceof
 *      - использовать тип в качестве элемента массива
 *
 * - материализируемые - информация о типе доступна в runtime
 *      - примитивы
 *      - массивы
 *      - обычные типы
 *      - базовые типы
 *      - обобщенные типы с неограниченным метасимволом
 *          - напр. List<?>
 *              - т.е. параметр типа нас не интересует
 *                  - т.к. это может быть вообще любой параметр
 *
 * - нематериализируемые - информация о типе стерта при компиляции
 *      - вызов обобщенных типов, которые не определены как неограниченные метасимволы
 *          - напр. List<String> и List<Number> не отличимы для JVM
 *          - напр. для List<? extends Number> пришлось бы убедиться, что у объекта параметр типа
 *          соответствует указанной границе
 *
 * - т.е. конкретный экземпляр обобщенного класса можно проверить при помощи instanceof только на
 * принадлежность к базовому типу, а также к обобщенному типу с неограниченным метасимволом в
 * качестве параметра типа */


/* todo С ПОМОЩЬЮ РЕФЛЕКСИИ МОЖНО ВОССТАНОВИТЬ ТОЛЬКО ТО, КАК БЫЛО ОБЪЯВЛЕНО ОБОБЩЕНИЕ
 * - можно определить имеет ли:
 *      - обобщенный метод параметр типа Т
 *      - параметр типа ограниченный подтип, который сам является обобщенным
 *      - ограничивающий тип подставляемый параметр
 *      - подставляемый параметр ограниченный супертип
 *      - обобщенный метод обобщенный массив в качестве своего параметра*/


/* ИТОГО НЕЛЬЗЯ:
 * - передавать в качестве аргумента примитив
 *       - т.к. после стирания тип меняется на ссылочный (напр. Object)
 *
 * - в runtime узнавать тип обобщенного экземпляра
 *      - т.к. он к этому моменту стерт, поэтому:
 *          - instanceof не работает
 *              - проверить можно только принадлежность экземпляра к базовому типу
 *              - но работает для типа с неограниченным метасимволом (т.е. подразумевается любой тип),
 *              т.к. для для определения типа объекта не нужно знать его параметр
 *                  - а для instanceof с ограниченным метасимволом пришлось бы как-то эту границу
 *                  проверять
 *          - возникает предупреждение Unchecked Conversion при приведении
 *
 * - создавать в своем коде массивы обобщенного типа
 *      - массивы ковариантны:
 *          - в Number[] можно добавлять любые элементы-наследники Number
 *              - при доставании объектов из массива, они могут быть безопасно приведены к Number
 *          - Object[] является родителем Number[]
 *              - значит Number[] можно назначить ссылке типа Object[] и добавить элемент Object
 *                  - но это приведет к загрязнению кучи
 *      - массивы материализируемы:
 *          - чтобы избежать загрязнения кучи, JVM должна знать в runtime настоящий тип массива
 *              - чтобы выбросить ArrayStoreException при попытке добавить несовместимый объект
 *      - но настоящий параметр типа обобщенного класса неизвестен JVM в runtime
 *          - поэтому она не сможет контролировать загрязнение кучи
 *      - но для массива, который получается из параметра с переменным числом аргументов, правила
 *      ослаблены
 *          - возникает предупреждение компилятора, которые можно подавить
 *      - при этом, ссылку на массив обобщенного типа можно объявлять, без создания самого массива:
 *          G2<String>[] d; // OK
 *          d = G2<String>[1]; // NOT OK
 *      - также можно создать массив с типом неограниченного метасимвола
 *              - т.к., как и при использовании instanceof, JVM не требуется знание реального
 *              параметра типа
 *              - в такой массив все равно можно добавить только null
 *                  - значит не будет загрязнения кучи
 *
 * - внутри обобщенного кода создавать объекты (в т.ч. массивы) по переданному в него параметру типа
 *      - т.к. объекты создаются во время работы программы, а к этому моменту все параметры заменены
 *      на Object или ограничение
 *          - также неизвестно, есть ли подходящий конструктор у такого типа
 *      - но ссылке параметризированного типа можно назначить уже существующий объект такого типа
 *          - напр. переданный в качестве параметра методу/конструктору
 *
 * - в статических членах нельзя использовать параметр типа, объявленный в классе
 *      - статический член существует независимо от класса
 *      - но у статических методов можно использовать свой независимый параметр типа
 *
 * - нельзя генерировать или перехватывать экземпляры обобщенного класса в виде исключений
 *      - блок catch может работать только с необобщенными классами
 *          - т.к. после стирания типов блоки станут выглядеть одинаково для JVM
 *      - иными словами обобщенный класс не может расширять (Throwable)
 *          - но сам класс и его наследники могут быть в качестве параметра типа
 *              - напр. static <T extends Throwable> void doIt(T t) throws T{} */


@Ntrstn("Обобщенный код означает код, который может работать с разными типами. Т.е., например, " +
        "классы, которые работают с Object (т.е. принимают все объекты) или классы которые работают " +
        "с Number (т.е. принимают объекты типа Number и подтипы), можно назвать обобщенными классами." +
        "Внутри таких классов для передаваемых в них объектов доступны методы верхней границы типа - " +
        " Object или Number соответственно")

@Ntrstn("В качестве обобщенного кода могут выступать классы, интерфейсы, методы и конструкторы")

@Ntrstn("Обобщенный код существовал и до введения \"обобщенного синтаксиса\" с использованием " +
        "параметра типа, но преимущество нового синтаксиса в том, что компилятор теперь гарантирует " +
        "типовую безопасность: в конкретный экземпляр обобщенного кода я могу передать только объект " +
        "того типа, который установлен для данного экземпляра в качестве его параметра типа, а при " +
        "возвращении объекта из экземпляра обобщенного кода в мой, компилятор автоматически " +
        "проставляет необходимые приведения (делая код чище). Это делается благодаря тому, что " +
        "компилятору известен конкретный тип, который передается в обобщенный код, и исключает " +
        "возможные исключения ClassCastException (следствие моей неосторожной работы с типами во " +
        "время работы программы).")

@Ntrstn("Oт применения обобщенного синтаксиса выигрывает только тот код, в котором присутствует много " +
        "операций приведения от самых общих типов (напр. Object или Comparable)")

@Ntrstn("Есть 2 фронта работы с обобщенным кодом: внутри этого кода и снаружи (при обращениях к нему," +
        "т.е. при передаче каких-либо объектов в него и получении их обратно")

@Ntrstn("Параметры типа (их может быть несколько) указываются единожды в местах их объявления в " +
        "обобщенном коде, а дальше они используется аналогично переменным - под их именами " +
        "подразумеваются те типы, которые будут переданы в код в качестве аргументов типа при " +
        "создании экземпляра такого обобщенного кода. Эти переменные типа можно использовать в любых " +
        "местах внутри обобщенного кода, где требуется указание конкретного типа - будь-то тип поля " +
        "данного обобщенного класса, тип параметра данного обобщенного метода или тип для " +
        "конкретного экземпляра другого обобщенного кода (напр. при указании реализации обобщенного " +
        "интерфейса обобщенным классом). 2 ограничения на использование параметра типа - от него " +
        "нельзя создавать конкретные объекты его типа и он не доступен в статических членах. Имена " +
        "параметров (переменных) типа могут быть какие угодно, аналогично именам переменных в " +
        "обычном коде (но есть конвенции)")

@Ntrstn("Параметры типа указываются в треугольных скобках. Для класса/интерфейса - после объявления " +
        "его имени. Для метода/конструктора - после модификаторов")

@Ntrstn("Чтобы обратиться к обобщенному коду, нужно создать его экземляр, передав в него аргумент " +
        "типа. Аргумент типа должен соответствовать установленной параметром типа границе. Он также " +
        "может быть только ссылочного типа, переменной типа (если мы находимся внутри обобщенного " +
        "кода), метасимволом (но не для обобщенных методов/интерфейсов, т.к. им требуется реальный " +
        "объект для работы) или другим (конкретным) параметризированным типом (напр. " +
        "List<List<String>>). Т.е. он не должен быть только примитивным типом")

@Ntrstn("Обобщенный метод или конструктор также использует параметр типа. При этом параметр типа " +
        "может принадлежать как классу/интерфейсу, которому принадлежит этот метод/конструктор, так " +
        "и самому методу/конструктору. Т.е. класс/интерфейс при этом необязательно должен быть " +
        "обобщенным.")

@Ntrstn("Из статического обобщенного метода нет доступа к параметру типа своего класса, даже если " +
        "сам класс статический")

@Ntrstn("Обобщенные методы, как и обычные, могут быть статическими и простыми, перегруженными и " +
        "переопределенными")

@Ntrstn("Учитывая, что в обобщенном классе в runtime неизвестно, какой конкретный параметр типа " +
        "используется в данный момент, и, соответственно, нельзя создавать экземпляры такого типа, то " +
        "они, скорее всего, будут передаваться в обобщенный конструктор/метод данного класса, откуда " +
        "уже можно будет присвоить ссылочной переменной обобщенного типа, объявленной внутри " +
        "обобщенного класса, такой конкретный объект.")

@Ntrstn("Обобщенный конструктор удобно использовать для полиморфизма. Напр. класс должен создаваться " +
        "от параметра Double. Можно смягчить это требование - параметр типа конструктора указывает " +
        "границу принимаемого параметра как Number, а у Number есть метод doubleValue(). Т.е. " +
        "конструктор теперь может принимать любое число, а зная, что у переданного типа точно есть " +
        "метод doubleValue(), мы им пользуемся в конструкторе, чтобы перевести значение в Double " +
        "представление")

@Ntrstn("Типу, принимаемому в качестве параметра, можно установить верхнюю границу, т.е. запретить " +
        "принимать типы объектов, которые иерархически стоят выше указанной границы, или не " +
        "относятся к его иерархии вообще. Для этого используется слово extends, которое для классов " +
        "означает extends, а для интерфейсов implements")

@Ntrstn("Верхних границ у параметра типа может быть несколько и передаваемый тип должен всем им " +
        "соответствовать. Если среди границ есть класс, то он обязательно должен идти первым, " +
        "а затем идет перечисление остальных интерфейсов через & (т.к. запятыми разделяются " +
        "переменные типа). Т.к. множественного наследования у классов не бывает, указываемых в " +
        "качестве границ классов может быть не больше 1")

@Ntrstn("Указание верхней границы для параметра является своего рода гарантией, что будет принят " +
        "только указанный тип или его наследники, а значит у них всех доступны методы родителя. Как " +
        "следствие, эти методы становятся доступными и в обобщенном типе")

@Ntrstn("Наследование работает для обобщенных классов/интерфейсов так же, как и для обычных классов: " +
        "класс наследуется через extends, а интерфейс через implements. У необобщенного родителя " +
        "может быть обобщенный наследник. У обобщенного родителя может быть необобщенный наследник, " +
        "но обобщенный родитель требует передавать ему конкретное значение параметра типа (в <> " +
        "после имени родителя). У обобщенного родителя может быть обобщенный наследник с " +
        "дополнительными параметрами типа. Параметр типа обобщенного наследника не должен быть шире " +
        "родительского")

@Ntrstn("Определение иерархии у конкретных экземпляров обобщенных типов работает по их обобщенному " +
        "типу, при условии, что аргумент типа у них одинаковый! Т.е. Gen <Number> не является " +
        "родственником ни GenSon<Integer> ни даже Gen <Integer>, но является родственником " +
        "GenSon<Number> или даже GenSon<Number, String>. Т.е. при определении наследования у " +
        "экземпляров обобщенных классов для параметров типа наследование не работает. При этом " +
        "экземпляру Gen <Number> спокойно можно передать в его параметризированный метод тип Integer, " +
        "т.к. это безопасное приведение (upcast). Когда тип (здесь параметра) совместим только с " +
        "самим собой - это называется инвариантность.")

@Ntrstn("Конкретные экземпляры обобщенных типов можно приводить друг к другу, если их обобщенные " +
        "типы совместимы иерархически, и у них установлены одинаковые аргументы типа. Правила " +
        "приведения стандартные - upcast можно делать неявно, а downcast нужно делать явно (напр. " +
        "Child <Integer> c = (Child<Integer>) new Parent<Integer>;)")

@Ntrstn("С Java7 стало необязательным указывать аргументы типа при вызове обобщенных методов и " +
        "конструкторов (т.е. при создании обобщенных классов), т.к. компилятор научился их выводить " +
        "самостоятельно. Это делается либо по аргументам типа, указанным при объявлении ссылочной " +
        "переменной, которой назначается создаваемый объект обобщенного класса, либо по передаваемым " +
        "(обычным) аргументам в обобщенный конструктор/метод. Иногда для метода также можно вывести " +
        "тип по возвращаемому типу (напр. обобщенный метод принимает параметр типа и возвращает этот " +
        "же тип, а результат работы метода присваивается в объект типа Serializable, значит этим " +
        "типом должет стать Serializable - т.е. по сути определяется опять-таки по целевому типу). " +
        "Для конструктора все же нужно указывать пустой ромбовидный оператор после имени класса, " +
        "чтобы не создавался объект базового типа, а для методов можно ничего не указывать перед их" +
        "именем. Кроме того, до Java8 выведение аргумента типа работало не полностью для методов, но " +
        "компилятор предупреждает о таких ситуациях (т.е. нужно указать аргументы явно - это, кстати, " +
        "называется type witness)")

@Ntrstn("Базовый тип - необобщенная версия обобщенного класса/интерфейса, а экземпляры такого " +
        "типа создаются без передачи в него аргументов типа. Главная цель такого типа - сохранить " +
        "совместимость старого кода (до обобщенного синтаксиса) с новым. Поведение такого типа " +
        "полностью идентично поведению обобщенных классов, но больше без гарантии компилятором " +
        "типовой безопасности (т.к. снова требуется ручное приведение) - т.е. абсолютно так же, как " +
        "это было до появления обобщенного синтаксиса. Этим и обеспечивается полная совместимость.")

@Ntrstn("Т.к. компилятор больше не может гарантировать типовую безопасность для базовых типов, в " +
        "моменты, когда он это понимает, он выдает сообщение \"unchecked conversion\". Такие моменты " +
        "происходят при создании экземпляра базового типа (не подтвержено), при назначении такого " +
        "экземпляра ссылке типа обобщенной версии такого класса, а также при вызове обобщенных " +
        "методов у экземпляра базового типа. Предупреждения не происходит, когда базовой ссылке " +
        "назначается объект обобщенного типа, т.к. сообщение было уже выдано при создании экземпляра " +
        "базового типа")

@Ntrstn("Использование базовых типов в коде, полностью написанным после появления обобщенного " +
        "синтаксиса (Java 5.0) не имеет смысла")

@Ntrstn("При компиляции (почти) вся информации о типе стирается - все параметры типа в обобщенном " +
        "коде заменяются на Object или на установленное первое ограничение (а для остальных " +
        "компилятор ставит приведение, где нужно), т.е. класс становится обычной базовой версией. " +
        "В моем коде при создании экземпляра обобщенного класса, создается базовая версия, а где " +
        "получаю свои объекты обратно из этого экземпляра, автоматически добавляется приведение к " +
        "типу, который был указан в качестве аргумента. Стирание - механизм, обеспечивающий " +
        "совместимость старого кода (до обобщенного синтаксиса) с новым.")

@Ntrstn("Стирание информации о типе может приводить к непредвиденным эффектам, в т.ч. к ошибкам " +
        "неоднозначности, когда сигнатуры у методов с одинаковым названием начинают совпадать. Если " +
        "это была перегрузка, то придется переименовывать методы. Если это было переопределение, то " +
        "для сохранения полиморфизма, компилятор автоматически создаст мостовой метод в наследнике - " +
        "он будет полностью соответствовать родительскому методу после стирания (т.е. параметр типа " +
        "так же будет (напр.) Object, как и у родителя), а в теле этого метода будет уже вызываться " +
        "правильный метод в наследнике, и при его вызове нужный ему параметр типа будет приведен " +
        "компилятором к реальному переданному аргументу типа). Но о мостовых методах не нужно " +
        "париться, пока они не появляются в стек трейсе")

@Ntrstn("Обобщенные массивы запрещены, поскольку массивы в Java являются ковариантными - в массив " +
        "родительского типа можно добавить элемент типа наследника и массив типа наследника можно " +
        "назначить ссылке типа родительского массива. Во втором случае в массив можно добавить " +
        "элемент родительского типа (что является неправильным) без предупреждения компилятора. " +
        "Также массивы являются материализируемыми - JVM знает реальный тип массива, поэтому в " +
        "случае попытки добавить родительский элемент в реальный массив типа наследника, будет " +
        "выброшено исключение ArrayStoreException. Но для обобщенных массивов тип неизвестен, " +
        "поэтому JVM не сможет контролировать неправильное добавление элементов в такой массив " +
        "(что приводет к загрязнению кучи). И это также является нетипобезопасным. Между тем можно " +
        "создать массив с указанием неограниченного метасимвола в качестве аргумента, но в такой " +
        "массив можно добавить только null (поэтому загрязнения не произойдет).")

@Ntrstn("Загрязнение кучи происходит, когда тип объекта по ссылке не соответствует типу самой ссылки " +
        "или не совместим с ним (т.е. не является наследником этого типа). В обобщениях такое " +
        "возможно, если ссылке обобщенного типа назначить через ручное приведение объект базового " +
        "типа. Также такое возможно при работе с обобщенными методами, у которых в качестве " +
        "обобщенного параметра стоит varargs - т.е. обобщенный массив. Несмотря на то что массивы " +
        "обобщенного типа запрещены, для varargs это условие ослаблено до простого предупреждения, " +
        "которое можно подавить. В результате тип массива будет стерт до ограничивающего типа, а " +
        "затем его можно будет назначить ссылке родительского типа и добавить родительский элемент, " +
        "что приведет к загрязнению")

@Ntrstn("Обобщенные типы относятся к нематериализируемым типам - т.е. тем, чей тип нельзя узнать во " +
        "время работы программы. Поэтому из них нельзя создавать массивы и оператор instanceof можно " +
        "вызвать только для базового типа или для типа у которого параметр указан как неограниченный " +
        "метасимвол. Во втором случае метасимвол обозначает неизвестный (а следовательно и неважный) " +
        "параметр типа, и при сравнении типа объекта с указанным типом, его можно просто " +
        "проигнорировать. В то же время экземпляр обобщенного класса, для которого в качестве " +
        "параметра указан ограниченный метасимвол, является нематериализируемым, т.к. JVM для " +
        "сравнения нужно будет выяснить, соответствует ли тип объекта указанной границе")

@Ntrstn("С помощью рефлексии можно реконструировать все, что было объявлено в реализации обобщенных " +
        "классов и методов. Но вряд ли можно узнать, каким образом разрешались параметры типа для " +
        "конкретных объектов и вызовов методов")

@Ntrstn("Итоговый список ограничений для обобщенного кода:" +
        "1. В качестве аргумента типа нельзя указывать примитив - после стирания он должен стать " +
        "объектом" +
        "2. В рантайме нельзя узнать реальный тип параметра экземпляра обобщенного кода - он стерт" +
        "3. Нельзя создавать массивы обобщенного типа - т.к. тип стерт, JVM не сможет отследить " +
        "добавление несовместимого типа, что нарушает типобезопасность и приводит к загрязению кучи" +
        "4. Внутри обобщенного кода нельзя создавать объекты по типу параметра - т.к. реальный " +
        "параметр стерт к моменту работы программы (когда и создаются объекты)" +
        "5. Из статического контекста нет доступа к переменной типа его класса" +
        "6. Нельзя использовать экземпляр обобщенного класса в блоке catch - т.к. после стирания " +
        "типа JVM не сможет правильно различать разные блоки. Т.е. обобщенный класс не может " +
        "наследовать Throwable")

@Ntrstn("Обобщения приносят пользу только тогда, когда вы хотите использовать параметры-типы, более " +
        "универсальные, чем конкретный тип (и все его подтипы), - то есть если код должен работать в " +
        "границах нескольких классов. В результате параметры-типы и их применение в практическом " +
        "обобщенном коде обычно сложнее простой замены класса. Впрочем, это не значит, что любая " +
        "конструкция <T extends SomeType> бесполезна. Например, если класс содержит метод, который " +
        "возвращает Т, обобщения приносят пользу, потому что они возвращают точный тип")

        /* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ПРЕИМУЩЕСТВА~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
class Advantages {
    void meth() {
        /* ПРЕИМУЩЕСТВО ОБОБЩЕНИЙ - ПРОВЕРКА ПЕРЕДАВАЕМОГО ТИПА ПРИ КОМПИЛЯЦИИ */
        List<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("a");
//        stringList.add(1); // ошибка при компиляции


        /* ПРЕИМУЩЕСТВО ОБОБЩЕНИЙ - НЕТ НЕОБХОДИМОСТИ В ОБРАТНОМ ПРИВЕДЕНИИ */
        String s1 = (String) stringList.get(1);
    }
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ОБОБЩЕННЫЙ ТИП~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/* ПАРАМЕТР ТИПА УКАЗЫВАЕТСЯ ПРИ ДЕКЛАРАЦИИ*/
class Generics<T> {
    /* МЕСТА ИСПОЛЬЗОВАНИЯ ПЕРЕДАННОГО АРГУМЕНТА ТИПА */
    T field; // поле
    T[] fieldArray; // массив
    T clazz; // класс
    Inner<T, T, T> inner; // другая переменная типа

    void meth(T param) { // параметр
        T local = null; // локальная переменная

        /* НЕЛЬЗЯ СОЗДАВАТЬ ЭКЗЕМПЛЯРЫ ПО ТИПУ*/
//        T clazz = new T(local); // после стирания типа, он более неизвестен
//        T[] arr = new T[10];
    }

    /* ПАРАМЕТРОВ ТИПА МОЖЕТ БЫТЬ НЕСКОЛЬКО */
    interface Inner<T1, T2, T3> {
    }
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~(КОНКРЕТНЫЙ) ПАРАМЕТРИЗИРОВАННЫЙ ТИП~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
class Parameterized {
    Generics<String> stringGeneric = new Generics<>();


    /* АРГУМЕНТ ТИПА НЕ ДОЛЖЕН БЫТЬ ПРИМИТИВОМ */
    //Generics<int> intGeneric = new Generics<>();


    /* АРГУМЕНТОМ ТАКЖЕ МОЖЕТ БЫТЬ ДРУГОЙ ПАРАМЕТРИЗИРОВАННЫЙ ТИП */
    Generics<Generics<String>> stringGenericGeneric = new Generics<>();
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ОБОБЩЕННЫЕ МЕТОДЫ И КОНСТРУКТОРЫ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
class NonGeneric {

    /* КОНСТРУКТОР */
    public <T1 extends Number, T2 extends Number> NonGeneric(T1 param1, T2 param2) {
        Double d = param1.doubleValue() * param2.doubleValue();
    }

    static void statMeth() {
        new NonGeneric(2, 2);
        new NonGeneric(2.3, 2.4);
    }


    /* МЕТОД */
    <T1> void methGen(T1 param) {
        T1 local;
    }

    /* СТАТИЧЕСКИЙ МЕТОД */
    static <T2> void statMethGen() {
        T2 local;
    }
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~УСТАНОВКА ВЕРХНЕЙ ГРАНИЦЫ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* МОГУТ БЫТЬ МНОЖЕСТВЕННЫЕ ГРАНИЦЫ */
class UpperLimit<T extends Number & Serializable & Closeable & Comparable> { // класс идет первым
    interface UpperLimitInterface<V extends Integer> {
    }

    public <S extends Number & Serializable & Closeable & Comparable> UpperLimit() {
    }

    <U extends Number & Serializable & Closeable & Comparable<U>> void meth(U num1, U num2) {
        /* ЕСТЬ ДОСТУП К МЕТОДАМ ТИПА */
        Integer i = num1.intValue();
        num1.compareTo(num2);
    }
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~НАСЛЕДОВАНИЕ~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
class Parent<E> {
    E ob;

    public void setOb(E ob) {
        this.ob = ob;
    }
}

class Child<E> extends Parent<E> { // значение параметра типа будет передано родителю
    E t;

    void add(E t) {
        this.t = t;
    }

    void meth() {
        new Child<Number>().add(new Integer(2)); // ок
        new Child<Number>().add(new Double(2.2)); // ок
    }
}

interface ParentInterface<T> {
}

interface ChildInterface<T> extends ParentInterface<T> {
}


/* РОДИТЕЛЬ ТРЕБУЕТ КОНКРЕТНЫЙ ТИП */
class Child1 extends Parent<String> {
}


/* МОЖНО ДОПОЛНЯТЬ СВОИМИ ПАРАМЕТРАМИ */
class Child2<E, T> extends Parent<E> {
}

interface ChildInterface2<T, B> extends ParentInterface<T> {
}


/*В НАСЛЕДНИКЕ МОЖНО ОГРАНИЧИТЬ ДИАПАЗОН */
class Child3<E extends Number> extends Parent<E> {
}


/* НАСЛЕДОВАТЬ МОЖНО ОТ НЕ ОБОБЩЕННОГО КЛАССА/ИНТЕРФЕЙСА */
class AnotherChild1<E> extends Parent {
}

interface AnotherChildInterface<T> extends ParentInterface {
}


/* ПРИВЕДЕНИЕ */
class Cast {
    void m() {
        /* ДОЛЖНЫ БЫТЬ СОВМЕСТИМЫ ИЕРАРХИЧЕСКИ И ИМЕТЬ ОДИНАКОВЫЙ АРГУМЕНТ*/
        Parent<Number> p1 = null;
        Parent<Integer> p11 = null;
        Child<Number> c1 = null;
        Child<Integer> c11 = null;
        Child2<Number, String> c2 = null;
        Child2<Integer, String> c22 = null;

//        p1 = p11; // разные аргументы
        p1 = c1; // ок
        p1 = c2; // ок
        c1 = (Child<Number>) p1; // необходимо ручное приведение
    }
}


/* ~~~~~~~~~~~~~~~~~~ЯВНОЕ И НЕЯВНОЕ УКАЗАНИЕ ТИПА, ВЫВЕДЕНИЕ И РОМБОВИДНЫЙ ОПЕРАТОР ~~~~~~~~~~~~~*/
class Infer {

    void m() {
        G<Integer, String> g = new G<Integer, String>(); // До Java7
        G<Integer, String> g1 = new G<>(); // c Java7 - типы выведены из ссылки
        new G<Integer, String>();
        new G<>();// todo как выводится тип аргумента здесь?
        new G<>(1, 1); // тип выведен по переданным параметрам
        new G<Integer, String>(1, "One");
        g.<Integer>meth(1); // type witness
    }

    class G<T, V> {
        T ob;
        V ob1;

        G() {
        }

        G(T ob, V ob1) {
            this.ob = ob;
            this.ob1 = ob1;
        }

        <S> void meth(S s) {
        }
    }
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~БАЗОВЫЙ ТИП ~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
class Raw {

    void meth() {
        // обобщенный тип
        Generics<String> generic = new Generics<>();
        Generics<String> generic2 = new Generics<>();

        // базовый тип - обобщенный тип без параметра
        Generics rawGeneric = new Generics();
        Generics rawGeneric2 = null;

        /* ~~~~~~~~~~~~UNCHECKED CONVERSION~~~~~~~~~~~~ */
        generic = rawGeneric; // при назначении базового объекта обобщенной ссылке
        generic = (Generics<String>) rawGeneric; // в т.ч. при помощи приведения к обобщенной ссылке
        rawGeneric2 = generic2; // нет предупреждения, т.к. не происходит дополнительной потери
        // типовой безопасности, кроме той, что уже произошла при создании объекта raw
        rawGeneric.meth(new Object()); // при вызове обобщенного метода
        rawGeneric2.meth(new Object()); // при вызове обобщенного метода
    }
}


/* ~~~~~~~~~~~~~~~~~~~~~~~~СТИРАНИЕ, ОШИБКИ НЕОДНОЗНАЧНОСТИ, МОСТОВЫЕ МЕТОДЫ~~~~~~~~~~~~~~~~~~~~~~~~*/
class Gen<T> {
    T ob;
    Object obj;

    public Gen(T ob) {
        this.ob = ob;
    }

    public void setOb(T ob) { // после стирания setObj(Object ob)
        this.ob = ob;
    }

//    public void setOb(Object ob) { // ошибка неоднозначности при перегрузке
//        this.obj = ob;
//    }
}

class Gen2 extends Gen<String> {

    public Gen2(String ob) {
        super(ob);
    }

    @Override
    public void setOb(String ob) { // сигнатура не совпадает с родительским setObj(Object ob)
        super.setOb(ob);
    }

    /* Поэтому компилятор создает такой мостовой метод */
//    public void setOb(Object ob) {
//        setOb((String) ob);
//    }
}


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~ЗАГРЯЗНЕНИЕ КУЧИ~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
class HeapPollution {
    //    @SafeVarargs
    final <T> void pollution(T... t) {
        /* ТИП ССЫЛКИ НЕСОВМЕСТИМ С ОБЪЕКТОМ ПО ССЫЛКЕ */
        List<Integer> integers = new ArrayList<>();
        List<String> strings = (List<String>) (Object) integers; // типы несовместимы

        /* ВЫЗОВ ОБОБЩЕННОГО МЕТОДА С ПЕРЕМЕННЫМ ЧИСЛОМ ПАРАМЕТРОВ */
        pollution(integers); // unchecked generics array creation for varargs parameter
    }
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~ОГРАНИЧЕНИЯ~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
class Limitations {


    /* НЕЛЬЗЯ СОЗДАВАТЬ ЭКЗЕМПЛЯРЫ ОБОБЩЕННОГО ТИПА ПО ПАРАМЕТРУ ТИПА*/
    static class Gen<T> {
        void m(T t) {
//            new T(); // компилятор не знает, какой объект создавать, ведь в рантайме это Object
            T t1 = t; // но можно назначить существующий объект
        }


        /* В СТАТИЧЕСКИХ ЧЛЕНАХ ПАРАМЕТРЫ ТИПА КЛАССА НЕ ДОСТУПНЫ */
//        static T i;
//        static void stat() {
//            T o;
//        }


        /* НЕЛЬЗЯ СОЗДАВАТЬ ОБЪЕКТЫ-МАССИВЫ ПО ПАРАМЕТРУ ТИПА */
        void m2(T[] t, T... elements) {
//            T[] arr = new T[1];
            T[] arr = t; // можно назначить существующий объект
            T[] arr2 = elements;
        }


        /* НЕЛЬЗЯ СОЗДАВАТЬ МАССИВЫ ИЗ ССЫЛОК КОНКРЕТНОГО ТИПА */
        void m3(T... elements) {
//            Gen<Integer> [] gens = new Gen<Integer>[10];

            Integer[] integers = new Integer[1];
            Object[] objects = integers;
            objects[0] = "n";

            Gen<?>[] gens = new Gen<?>[10]; // но вот так можно
        }
    }


    /* THROWABLE НЕЛЬЗЯ НАСЛЕДОВАТЬ ОБОБЩЕННЫМ КЛАССОМ */
    class Gener<T> extends Object {
    }

//    class Gener2<T> extends Throwable {
//    }

    <E extends Throwable> void doIt(E t) throws E { // но параметр типа (Throwable) можно выбрасывать
    }
}

public class Main {
    public static void main(String[] args) {

    }
}

//class MyClass implements Comparable<T>{
//    @Override
//    public int compareTo(Integer o) {
//        return 0;
//    }
//}

class MyClass2 implements Comparable<Integer> {

    @Override
    public int compareTo(Integer o) {
        return 0;
    }
}