package types_references_arrays;

/* МАССИВ
 * - тип массива - массив типа содержащихся в нем значений
 * - после задания размера, его нельзя изменить
 * - размер - значение поля length
 * - доступ к элементам по индексу:
 *      - индекс первого элемента – 0, индекс последнего – на 1 меньше длины
 *      - если нет элемента с таким индексом ArrayIndexOutOfBoundsException */


/* ОБЪЯВЛЕНИЕ (СОЗДАНИЕ ССЫЛКИ)
 * - определяется ссылочная переменная типа конкретного массива
 * - нельзя использовать без инициализации
 * - здесь не указывается длина массива, т.к. работа идет с ссылкой
 * - можно объявлять несколько через запятую:
 *      - но если после переменной указать[], то последующие переменные без [] не будут массивами*/


/* СОЗДАНИЕ (ОБЪЕКТА В ПАМЯТИ)
 * - указывает количество элементов в массиве (размер):
 *      - может быть как литералом, так и переменной, т.к. размер используется только в рантайме
 * - выделяется место для массива в оперативной памяти (оператором new)
 * - переменной-ссылке присваивается адрес массива оператором =
 * - все элементы массива автоматически инициализируются значениями по умолчанию */


/* ОБЪЯВЛЕНИЕ И СОЗДАНИЕ МОЖНО ОБЪЕДИНИТЬ*/


/* ИНИЦИАЛИЗАЦИЯ (ЗНАЧЕНИЙ)
 * - способ 1 (присвоить каждому элементу конкретное значение):
 *      - массив должен быть создан и объявлен
 *      - элементы инициализированы дефолтными значениями
 *      - изменить значение можно обратившись к каждому элементу отдельно
 *
 * - способ 2 (перечисление значений в фигурных скобках):
 *      - на этапе создания
 *      - на этапе объявления:
 *          - если массив объявлен, то такой синтаксис нельзя использовать */


/* МАССИВ-ЛИТЕРАЛ
 * - это то, что в фигурных скобках при инициализации массива
 * - !! элементы являются произвольными выражениями, вычисляемыми в рантайме, а НЕ постоянными
 * выражениями, вычисляемыми компилятором (т.е. по сути НЕ литералы?!)
 * - поэтому, если нужно разместить в программе много данных, лучше не включать их непосредственно в
 * массив (много действий компилятора и интерпретатора), а сохранять данные во внешнем файле и
 * считывать их в программу во время ее выполнения
 * todo разобраться, имеет ли результат компиляции посчитанные значения выражения */


/* АНОНИМНЫЙ МАССИВ
 * - нет имени
 * - нужен только 1 раз*/


/*МАССИВ НУЛЕВОЙ ДЛИНЫ
 * - инициализировать массив нулевой массив нельзя (нет элементов для этого)
 * - принято использовать в тех местах программы, где заранее неизвестно, будут элементы или нет:
 *      - если элементы будут, то возвращается непустой массив
 *      - если элементов нет - пустой массив
 * - лучше, чем null, потому что не требует отдельного if'а для обработки (if != null). То же верно
 * для списков и других коллекций. Именно поэтому существуют методы Collections.emptyList, emptySet,
 * emptyMap.*/


/* МНОГОМЕРНЫЕ МАССИВЫ
 * - содержит другие массивы в качестве элементов
 * - длина массива определяется по левому измерению
 * - объявление, создание, инициализация:
 *       - также необходимы все эти стадии
 *       - можно инициализировать массивом-литералом
 *       - при резервировании памяти нужно указать размер только левого (главного) измерения:
 *          - обращаться с главным измерением нужно как с МАССИВОМ конкретного типа, а не как с
 *          переменной конкретного типа
 *          - обращаться к остальным измерениям можно только ПОСЛЕ их создания
 *       - левые размеры лучше делать меньше - уменьшает фрагментацию и размер необходимой памяти
 *
 * - 2-мерный массив это таблица
 *
 * - если количество элементов в строках отличается – это уже не матрица
 *
 * - для обработки используются вложенные циклы с счетчиками:
 *      - for: если нужно считать или изменить значения
 *      - for each: если нужно только считать значения */


/* МАССИВЫ КОВАРИАНТНЫ И МАТЕРИАЛИЗИРУЕМЫ
 * - ковариантны:
 *      - в массив родительского типа можно добавлять элементы-наследники:
 *          Number [] n = new Number[2];
 *          n[0] = new Integer(1); // OK
 *          n[1] = new Double (1.1); // OK
 *
 *      - массив родительского типа является родителем массива типа наследника:
 *          - т.е. массив типа наследника можно назначить ссылке на массив (любого) родительского типа
 *              - и без ошибки компилятора добавить элемент родительский элемент
 *                  - что приведет к загрязнения кучи
 *
 * - материализируемы:
 *      - JVM знает в runtime какой тип на самом деле имеет массив
 *          - чтобы избежать загрязнения кучи будет выброшено исключение ArrayStoreException при
 *          попытке добавить элемент родительского типа */


/* СРАВНЕНИЕ
 * - нужно использовать статические методы Arrays.equals и Arrays.deepEquals:
 *       - Arrays.equals: для 1-мерных массивов
 *       - Arrays.deepEquals: для многомерных
 *       - равны, если:
 *          - имеют одинаковое количество элементов
 *          - и все соответствующие пары элементов равны
 *          - или если оба null*/


/* КОПИРОВАНИЕ
 * - можно вручную в цикле for
 * - если массив 1-мерный, то быстрее выполнится:
 *      - Arrays.copyOf(): создает новый массив
 *      - System.arraycopy(): нативный метод (может быть еще быстрее)
 * - можно clone()
 *      - т.к. массивы имлементируют Cloneable
 *      - значения содержащихся примитивов или неизменяемых объектов клонируется корректно
 *      - для изменяемых объектов клонируются только ссылки на них
 *          - и они продолжают ссылаться на те же объекте
 *              - т.е. изменения в 1 массиве приведет к изменению в другом */


/* ПЕЧАТЬ
 * - toString() не переопределен
 * - нужно использовать:
 *      - Arrays.toString(): для 1-мерных
 *      - Arrays.deepToString(): для много-мерных */


/* VARARGS ЭТО 1-МЕРНЫЙ МАССИВ
 * - в аргументах метода массив и Varargs взаимозаменяемы
 *      - только для 1-мерных - иначе возьмется первое измерение*/


/* ПОЛЕЗНЫЕ СТАТИЧЕСКИЕ МЕТОДЫ java.util.Arrays
 * - методы перегружены для всех примитивных типов
 * - asList() − возвращает массив как коллекцию
 * - binarySearch(): поиск при помощи алгоритма binary search
 * - copyOf(): копирование указанного массива
 * - copyOfRange() − копирует часть массива
 * - deepToString(): печать многомерного массива
 * - deepEquals(): сравнение многомерного массива
 * - equals(): сравнение 1-мерного массива
 * - fill(): назначить указанное значение указанному диапазону
 * - setAll(): установить все значения указанному массиву
 * - sort(): сортировка указанного диапазона при помощи указанного компаратора
 * - toString(): печать 1-мерного массива*/

import java.util.Arrays;

import types_references_annotations.my_annotations.Ntrstn;

@Ntrstn("Тип массива - объект типа, содержащегося в массиве")
@Ntrstn("Все массивы имплементируют интерфейс Cloneable, а метод clone() для них возвращает массив " +
        "типа, содержащихся в нем объектов")
@Ntrstn("Если клонировать массив методом clone(), то примитивные значение и неизменяемые объекты по " +
        "ссылкам будут правильно клонированы, а для ссылочных переменных с изменяемыми объектами " +
        "будут созданы копии ссылок, а не самих объектов")
@Ntrstn("Коллекцию удобно создавать методом Arrays.asList(4, 5, 65, 6, 34)")

@Ntrstn("Cами массивы имплементированы в JVM, а единственные методы, которые им доступны - Object")
public class Main {
    static int[] arrA;
    static String[] stringArr;
    static int intA;

    public static void main(String[] args) {
        /* ТИП МАССИВА - МАССИВ ТИПА СОДЕРЖАЩИХСЯ В НЕМ ЭЛЕМЕНТОВ */
        stringArr = new String[5];
        System.out.println(stringArr instanceof Object); // true
        System.out.println(stringArr instanceof String[]); // true
        arrA = new int[5];
        System.out.println(arrA instanceof int[]); // true
//        System.out.println(arrA instanceof Integer[]); // нет


        /* УЗНАТЬ РАЗМЕР - ПОЛЕ LENGTH*/
        System.out.println(stringArr.length); // даст 5


        /* ДОСТУП К ЭЛЕМЕНТАМ ПО ИНДЕКСУ */
        stringArr[0] = "first"; // начинается с 0
        stringArr[stringArr.length - 1] = "last"; // последний элемент: длина - 1
//        stringArr[5] = "no such element"; // ArrayIndexOutOfBoundsException


        /* ~~~~~~~~~~~~~~~~~~ОБЪЯВЛЕНИЕ (ССЫЛКИ) ~~~~~~~~~~~~~~~~~~ */
        int[] arrT; // ссылка на массив типа int
        int arrT1[]; // ссылка на массив типа int
        int[][] arrT2; // ссылка на 2-мерный массив типа int
        int[] arrT3[]; // ссылка на 2-мерный массив типа int

        /* МНОЖЕСТВЕННОЕ ОБЪЯВЛЕНИЕ */
        String[] arrT4, arrT5, arrT6; // несколько ссылок на массив типа String
        int arr7[], arr8; // arr8 НЕ ЯВЛЯЕТСЯ МАССИВОМ!!


        /* ~~~~~~~~~~~~~~~~~~СОЗДАНИЕ (ОБЪЕКТА В ПАМЯТИ)~~~~~~~~~~~~~~~~~~*/
        arrA = new int[10]; // выделить место для массива с 10 элементами, адрес присвоить ссылке
        intA = 10 * 1;
        arrA = new int[intA]; // создание происходит в рантайме
        System.out.println(arrA[5]); // даст 0 - эл-ты инициализируются дефолтными значениями типа


        /* ~~~~~~~~~~~~~~~~~~ОБЪЯВЛЕНИЕ + СОЗДАНИЕ~~~~~~~~~~~~~~~~~~ */
        int[] arr9 = new int[5]; // одновременное объявление и создание


        /* ~~~~~~~~~~~~~~~~~~ИНИЦИАЛИЗАЦИЯ (ЗНАЧЕНИЙ)~~~~~~~~~~~~~~~~~~ */
        /* СПОСОБ 1 (ПРИСВОЕНИЕ КАЖДОМУ ЭЛЕМЕНТУ КОНКРЕТНЫХ ЗНАЧЕНИЙ) */
        arrA = new int[10]; // предварительно должен быть объявлен и создан
        arrA[0] = 2; // назначение конкретного значения, обратившись по индексу
        arrA[1] = 3; // назначение конкретного значения, обратившись по индексу

        /* СПОСОБ 2 (ПЕРЕЧИСЛЕНИЕ ЗНАЧЕНИЙ В ФИГУРНЫХ СКОБКАХ) */
        int[] arr10;
        arr10 = new int[]{3, 2}; // на этапе создания
        int[] arr11 = {3, 2}; // на этапе объявления
//        arr10 = {3, 2}; // нельзя, т.к. массив уже объявлен


        /* ~~~~~~~~~~~~~~~~~~ МАССИВ-ЛИТЕРАЛ ~~~~~~~~~~~~~~~~~~*/
        int[] arr12 = {(1 + 2) / 3, 2}; // (1 + 2) / 3 = результат {1, 2} - массив-литерал
        int[] arr13 = new int[2]; // результат компиляции массива-литерала
        arr13[0] = 1; // результат компиляции массива-литерала
        arr13[1] = 2; // результат компиляции массива-литерала


        /* ~~~~~~~~~~~~~~~~~~АНОНИМНЫЙ МАССИВ~~~~~~~~~~~~~~~~~~ */
        System.out.println(new char[]{'H', 'e', 'l', 'l', 'o'});


        /* ~~~~~~~~~~~~~~~~~~МАССИВ НУЛЕВОЙ ДЛИНЫ~~~~~~~~~~~~~~~~~~ */
        /*МАССИВ НУЛЕВОЙ ДЛИНЫ*/
        int[] arr14 = new int[0]; // нет элементов, т.е. длина 0
//        arr14[0] = 1; // элементы нельзя инициализировать - NullPointerException
        if (returnArrOfVarLength(arr14) != null) { // такая проверка теперь не нужна
            System.out.println(arr14.length); // false
        }


        /* ~~~~~~~~~~~~~~~~~~МНОГОМЕРНЫЕ МАССИВЫ~~~~~~~~~~~~~~~~~~ */
        /* ОБЪЯВЛЕНИЕ, СОЗДАНИЕ, ИНИЦИАЛИЗАЦИЯ*/
        int arr15[][] = { // инициализация 2-мерным массивом-литералом
                {1, 2, 3},
                {1, 2, 3},
                {1, 2, 3},
                {1, 2, 3}
        };
        int arr16[][] = new int[2][]; // для создания необходимо только левое измерение
        arr16[0] = new int[10]; // отдельная резервация памяти для конкретных объектов
        arr16[1] = new int[10]; // отдельная резервация памяти для конкретных объектов
        int arr17[][][]; // объявление ссылки на 3-мерный массив
        arr17 = new int[2][][];
//        arr17[0] = 0; // ошибка компиляции: первое измерение это массивы типа int, а не примитивы
//        arr17[0][0][0] = 10; // NullPointerException, т.к. массивы еще не созданы
        int[][] arr18 = new int[10][1000]; // 11 объектов в памяти
        int[][] arr19 = new int[1000][10]; // 1001 объект в памяти

        /* ДЛИНА*/
        int arr20[][] = new int[2][15];
        System.out.println(arr20.length); // 2 - т.к. левое измерение состоит из 4 элементов
        System.out.println(arr20[1].length); // 15

        /* ОБРАБОТКА */
        // for (чтение и изменение)
        for (int i = 0; i < arr20.length; i++) {
            for (int j = 0; j < arr20[i].length; j++) {
                arr20[i][j] = 666;
                System.out.printf("запист 666 в [%d][%d]\n", i, j);
            }
        }
        // foreach (только чтение!!!)
        for (int[] i : arr20) {
            for (int j : i) {
                System.out.printf("только чтение: %d\n", j);
                // i[j] = 555; // значение сохраняется только до конца текущего цикла
            }
        }


        /*~~~~~~~~~~~~~~~~~~МАССИВЫ КОВАРИАНТНЫ И МАТЕРИАЛИЗИРУЕМЫ~~~~~~~~~~~~~~~~~~*/
        /* КОВАРИАНТНОСТЬ */
        // при компиляции в родительский массив можно добавить элементы-наследники
        Number[] numbers = new Number[2];
        numbers[0] = 1; // Integer
        numbers[1] = 2.1; // Double
        // ссылка на массив родительского типа может хранить массив типа наследника
        Object[] objects = numbers;


        /* МАТЕРИАЛИЗИРУЕМОСТЬ */
        // JVM знает какой тип на самом деле имеет массив, поэтому бросит исключение при добавлении
        // несовместимого типа
//        objects[0] = new Object(); // ArrayStoreException


        /*~~~~~~~~~~~~~~~~~~СРАВНЕНИЕ~~~~~~~~~~~~~~~~~~*/
        int[] arr21 = {1, 2, 3};
        int[] arr22 = {1, 2, 3};
        int[] arr23 = {3, 4, 5};
        int[] arr24 = null;
        int[] arr25 = null;
        System.out.println(arr21 == arr22); // false - разные объекты
        System.out.println(arr21.equals(arr22)); // false - метод не переназначен
        System.out.println(Arrays.equals(arr21, arr22)); // true
        System.out.println(Arrays.equals(arr21, arr23)); // false
        System.out.println(Arrays.equals(arr24, arr25)); // true - null объекты равны
        int[][] arr26 = {
                {1, 2, 3},
                {1, 2, 3}
        };
        int[][] arr27 = {
                {1, 2, 3},
                {1, 2, 3}
        };
        int[][] arr28 = {
                {1, 2, 3},
                {4, 5, 6}
        };
        int[][] arr29 = null;
        int[][] arr30 = null;
        System.out.println(Arrays.equals(arr26, arr27)); // false
        System.out.println(Arrays.deepEquals(arr26, arr27)); // true
        System.out.println(Arrays.deepEquals(arr26, arr28)); // false
        System.out.println(Arrays.deepEquals(arr29, arr30)); // true


        /* ~~~~~~~~~~~~~~~~~~КОПИРОВАНИЕ~~~~~~~~~~~~~~~~~~*/
        /*ВРУЧНУЮ*/
        int[][] multiArr = {
                {6, 5, 4},
                {3, 2, 1}
        };
        int[][] multiArr2 = new int[multiArr.length][];
        for (int i = 0; i < multiArr.length; i++) {
            int[] temp = new int[multiArr[i].length]; // массивы еще не созданы
            for (int j = 0; j < multiArr[i].length; j++) {
                temp[j] = multiArr[i][j];
            }
            multiArr2[i] = temp; // назначение новых массивов
        }

        /* МЕТОД CLONE()*/
        int[] arr = {1, 2, 3};
        int[] arr2 = arr.clone(); // нормальное клонирование
        String[] sArr = {"1", "2", "3"};
        String[] sArr2 = sArr.clone(); // нормальное клонирование
        Object[] oArr = {new Object()};
        Object[] oArr2 = oArr.clone(); // КОПИРУЮТСЯ ТОЛЬКО ССЫЛКИ НА ОБЪЕКТЫ

        /*СТАТИЧЕСКИМИ МЕТОДАМИ*/
//        int[][] multiArr2 = new int[2][3]; // не работает для многомерных массивов
        int[] multiArr3 = {1, 2, 3};
        int[] multiArr4 = Arrays.copyOf(multiArr3, multiArr3.length); // нужно указать длину
        int[] multiArr5 = new int[3];
        System.arraycopy(multiArr3, 0, multiArr5, 0, multiArr3.length); // можно указывать отрезок
        System.out.println(Arrays.toString(multiArr5));


        /* ~~~~~~~~~~~~~~~~~~ПЕЧАТЬ~~~~~~~~~~~~~~~~~~
         * - toString() не переопределен
         * - нужно использовать:
         *      - Arrays.toString(): для 1-мерных
         *      - Arrays.deepToString(): для много-мерных */
        int[] arr31 = new int[5];
        arr31.toString(); // [I@1716361 - метод не переопределен
        System.out.println(Arrays.toString(arr31)); // [0, 0, 0, 0, 0]
        int[][] arr32 = new int[5][];
        System.out.println(Arrays.toString(arr32)); // [null, null, null, null, null]
        int[][] arr33 = new int[5][5];
        System.out.println(Arrays.toString(arr33)); // [[I@1f3c5b5, [I@164951d, [I@11210ee, [I@17e1886, [I@d1a2f1]
        System.out.println(Arrays.deepToString(arr33)); // [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]


    }


    /* ~~~~~~~~~~~~~~~~~~VARARGS ЭТО 1-МЕРНЫЙ МАССИВ~~~~~~~~~~~~~~~~~~*/
    void varArgument(int... varArg) {
        int a = varArg[23];
    }


    /* Заранее неизвестен размер возвращаемого массива */
    static int[] returnArrOfVarLength(int[] arr) {
        double d = Math.random();
        if (d < 0.5) {
            arr = new int[0];
        } else arr = new int[1];
        return arr;
    }
}