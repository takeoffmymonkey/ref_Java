package types_references;

import types_references_annotations.my_annotations.Ntrstn;

/* ССЫЛОЧНЫЕ ТИПЫ
 * - все, кроме примитивов:
 *   + классы
 *   + интерфейсы
 *   + строки
 *   + перечисления
 *   + массивы
 *   + обертки
 *   + аннотации*/


/*ОБЪЯВЛЕНИЕ
 * - ассоциирует имя переменной с типом объекта
 * - можно объявить ссылочную переменную без указания адреса объекта, на который она должна ссылаться
 *      - т.е. без самого объекта*/


/* СОЗДАНИЕ
 * - перед работой с объектом, требуется его создание
 * - создание происходит оператором new:
 *      - new требует вызова конструктора класса после него
 *      - JVM выделяет память для объекта
 *      - JVM возвращает адрес объекта в памяти
 *          - адрес может быть присвоен ссылочной переменной целевого типа
 *          - а может быть и не присвоен
 *              - может быть напрямую использована в выражении */


/* ИНИЦИАЛИЗАЦИЯ
 * - задание нужного состояния у создаваемого объекта
 *      - с помощью конструктора */


/* ПОВЕДЕНИЕ
 * - если разные ссылочные переменные ссылаются на 1 и тот же объект, то действия над этими
 * переменными, будут приводить к изменениям 1 и того же объекта*/


/* ДОПУСТИМЫЕ ОПЕРАЦИИ
 * - Присваивание
 *      - компилятор осуществляет контроль типов
 * - Обращение к полям и методам объекта
 *      - внутри объекта - просто по имени
 *      - извне объекта - по имениКласса.имяПеременной
 * - Приведение типов
 * - Проверка на принадлежность типу оператором instanceof: <variable> instanceof <Type>.
 *      - Если variable не является типом Type или его наследником, оператор всегда вернет false
 * - Сравнение ссылок ==, !=.
 * - Тернарный оператор: <выражение1> ? <выражение2> : <выражение3>;
 *      - Результаты выражений 2 и 3 должны соответствовать отношению is-a к типу возвращаемого
 *      результата
 *          - Иначе ошибка компиляции
 * - Операция конкатенации +:
 *      - всегда возвращает String
 *      - требует, чтобы тип как минимум одного из операндов был String
 *          - несоответствующие операнды будут преобразованы методом toString()
 * - Передача через параметр метода*/


/* ДРУГИЕ ОСОБЕННОСТИ
 * - унаследованы от класса Object
 * - не может быть статических классов верхнего уровня
 * - == сравнивает не значение, а адрес
 * - значение переменной по умолчанию – null (ссылка на объект пуста)
 * - ссылочная переменная + final != константа (в отличие от примитива) - объект можно менять, но
 * ссылку нельзя переназначить
 * - размер переменной не зависит от объектов на которые указывает (ее величина может меняться в
 * разных версиях JVM, но в пределах одной версии она постоянна)
 * - узнать тип переменной: a.getClass().getName();*/


@Ntrstn("Если разные ссылочные переменные ссылаются на 1 и тот же объект, то действия над этими " +
        "переменными, будут приводить к изменениям 1 и того же объекта")

@Ntrstn("У ссылочных переменных == сравнивает не значение, а адрес объекта по ссылке")

@Ntrstn("У ссылочных переменных final значит только, что нельзя назначить эту ссылку на другой объект")

@Ntrstn("Размер всех ссылочных переменных в рамках одной JVM постоянный")
public class Main {

    static boolean booleanA;
    static Integer intB = 0;
    static Integer intB1 = 0;
    static String stringA;
    static Comparable comparableA = intB;
    static int[] arrayA = {};
    static Object unInitializedObj;

    enum enumA {ONE}

    public static void main(String[] args) {
        /* ОБЪЯВЛЕНИЕ */
        Object object;


        /* СОЗДАНИЕ */
        object = new Object(); // обязательно требуется конструктор после new
        new Object(); // адрес может не присваиваться ссылочной переменной
        String s = new Object().toString(); // может напрямую использоваться в выражении


        /* ИНИЦИАЛИЗАЦИЯ */
        new Integer(3);


        /* ПОВЕДЕНИЕ
         * - если разные ссылочные переменные ссылаются на 1 и тот же объект, то действия над этими
         * переменными, будут приводить к изменениям 1 и того же объекта*/
        Object obj1 = new Object(); // есть ссылка типа Object на конкретный объект в памяти
        Object obj2 = null; // есть ссылка типа Object, но пока никуда не ссылается
        obj2 = obj1; // теперь ссылка o2 ссылается на тот же объект в памяти, что и о1
        obj1.toString(); // вызов toString() у одного и того же объекта, хоть и по разным ссылкам
        obj2.toString(); // вызов toString() у одного и того же объекта, хоть и по разным ссылкам


        /* ДОПУСТИМЫЕ ОПЕРАЦИИ*/
        obj1 = obj2; // Присваивание (компилятором осуществляется контроль типов)
        obj1.toString(); // Обращение к полям и методам объекта
        obj1 = (Object) intB; // Приведение типов
        booleanA = intB instanceof Integer; // Проверка на принадлежность типу оператором instanceof
        booleanA = obj1 == obj2 && obj1 != intB; // Сравнение ссылок ==, !=.
        obj1 = 1 == 2 ? intB : obj2; // Тернарный оператор (должен возвратить совместимый тип)
        stringA = "Результат метода toString() у переменной obj1" + obj1; // Конкатенация
        method(obj1); // Передача через параметр метода


        /*~~~~~~~~~~~~~~~~~~~ДРУГИЕ ОСОБЕННОСТИ~~~~~~~~~~~~~~~~~~~*/

        /* ВСЕ УНАСЛЕДОВАНЫ ОТ КЛАССА OBJECT*/
        booleanA = intB instanceof Object; // даст true
        booleanA = "" instanceof Object; // даст true
        booleanA = comparableA instanceof Object; // даст true
        booleanA = arrayA instanceof Object; // даст true
        booleanA = enumA.ONE instanceof Object; // даст true
        //TODO: не уверен, что правильно обращаюсь к enum
        //TODO: не знаю, как протестить аннотации

        /* == СРАВНИВАЕТ НЕ ЗНАЧЕНИЕ ПО ССЫЛКЕ, А ТОЛЬКО ОБЪЕКТ, КУДА ОНА ССЫЛАЕТСЯ
         * - !!! КРОМЕ:
         *      + целочисленные в диапазоне byte (-128..127) будут ссылаться на 1 объект
         *      + у строк свой пул*/
        Object o1 = new Object();
        Object o2 = new Object();
        booleanA = o1 == o2; // даст false

        Integer i1 = 127;
        Integer i2 = 127;
        booleanA = i1 == i2; // даст true
        i1 = 128;
        i2 = 128;
        booleanA = i1 == i2; // даст false

        String s1 = "string";
        String s2 = "string";
        booleanA = s1 == s2; // даст true


        /* ЗНАЧЕНИЕ ПО УМОЛЧАНИЮ У ССЫЛОЧНОЙ ПЕРЕМЕННОЙ NULL*/
        System.out.println(unInitializedObj); // null


        /*ССЫЛОЧНАЯ ПЕРЕМЕННАЯ + FINAL != КОНСТАНТА (В ОТЛИЧИЕ ОТ ПРИМИТИВА)
         * - объект можно менять, но ссылку нельзя переназначить */
        final int FINAL_PRIMITIVE = 123;
        // FINAL_PRIMITIVE = 1; // нельзя
        final Integer integer = 123;
        Integer integer1 = 234;
        // integer = integer1; // нельзя переназначить
        // integer = 1234; // так же переназначение - нельзя


        /* УЗНАТЬ ТИП ПЕРЕМЕННОЙ*/
        System.out.println(integer.getClass().getName()); // даст java.lang.Integer

    }

    static void method(Object object) {
    }
}