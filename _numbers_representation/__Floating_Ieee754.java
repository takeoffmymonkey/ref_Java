package _numbers_representation;

//TODO: не закончено

/*IEEE754
 * - используется в программных (компиляторы) и аппаратных (CPU, FPU) реализациях арифметических
 * действий
 * - описывает:
 *   + формат чисел с плавающей точкой
 *   + представление:
 *     - +0 и -0
 *     - +бесконечность и -бесконечность
 *     - NaN
 *   + методы, используемые при преобразовании числа при математических операциях
 *   + исключительные ситуации:
 *      - деление на 0
 *      - переполнение
 *      - потеря значимости
 *      - работа с денормализированными числами
 *   + операции:
 *      - арифметические
 *      - другие */


/* ФОРМАТ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ
 * - дробные числа представляются 3 целыми числами по формуле: (-1)^s * c * b^q, где:
 *   + s - знак (0 - плюс, 1 - минус)
 *   + c - мантисса (коэффициент)
 *   + q - экспонента (степень)
 *   + b - основание (система счисления) */


/* ПРИМЕР ЗАПИСИ 10-ИЧНОГО
 * - знак: минус (1)
 * - мантисса: 12345
 * - экспонента: -3
 * - основание: 10
 * - получается: (-1)^1 * 12345 * 10^-3 = -12.345 */


/* НЕКОТОРЫЕ ОСНОВНЫЕ ФОРМАТЫ (наиболее используемые)
 * - Одинарная точность:
 *   + в Java: float
 *   + основание: 2
 *   + количество разрядов мантиссы: 24
 *   + экспонента (бит): 8
 *   + смещение экспоненты: 2^7 − 1 = 127
 *   + emin: -126
 *   + emax: +127
 *
 * - Двойная точность:
 *   + в Java: double
 *   + основание: 2
 *   + количество разрядов мантиссы: 53
 *   + экспонента (бит): 11
 *   + смещение экспоненты: 2^10 − 1 = 1023
 *   + emin: -1022
 *   + emax: +1023 */


/* ДИАПАЗОН ВОЗМОЖНЫХ ЗНАЧЕНИЙ
 * - определяется:
 *   + основанием b
 *   + количеством знаков в мантиссе с (с точностью p)
 *   + и максимальным значением emax (степень)
 *
 * - с должен быть целым числом в диапазоне от 0 до b^p - 1:
 *   + напр. если b = 10, p = 7, то с может быть в диапазоне от 0 до 9999999
 *
 * - q должно быть целым числом в диапазоне 1 − emax ≤ q + p − 1 ≤ emax:
 *   + напр. если p = 7 и emax = 96, то q может быть от −101 до 90 (-95 ≤ q + 6 ≤ 96)
 *
 * - т.е.
 *   + наименьшее отличное от нуля: 1 * 10^-101
 *   + наибольшое: 9999999 * 10^96
 *
 * - числа -b^1-emax и b^1-emax (−1 × 10-95 и 1 × 10-95) являются самыми маленькими (по абсолютной
 * величине) нормальными числами; ненулевые числа между этими наименьшими числами -
 * денормализированные */


/* ПРЕДСТАВЛЕНИЕ И КОДИРОВАНИЕ В ПАМЯТИ
 * - если b = 10 и р = 7, то число −12,345 может быть представлено как: −12345 * 10^-3, −123450 * 10^-4
 * или −1234500 * 10^-5
 * - когорта: совокупность таких возможных представлений
 * - когда есть несколько вариантов, стандарт определяет какой именно нужно использовать:
 *   + для бинарных форматов - наименьший представляемый показатель:
 *       - для чисел с показателем в нормальном диапазоне (не все из них или все нули), ведущий бит
 *       мантиссы всегда будет равен 1.
 *       - значит его можно опустить, тем самым сохранив 1 бит для точности (называется "ведущая
 *       битная конвенция")
 *       - ведущая битная конвенция не используется для денормализированных*/


/* НОРМАЛЬНАЯ И НОРМАЛИЗИРОВАННАЯ ФОРМЫ ЗАПИСИ ЧИСЛА С ПЛАВАЮЩЕЙ ЗАПЯТОЙ
 * - нормальная: мантисса (без учета знака) находится в полуинтервале 0 ⩽ a < 1, значит 0,0001 можно
 * записать как 0,000001 * 10^2, 0,00001 * 10^1 и т.д.
 *
 * - нормализированная (пример сразу в двоичной) находится в полуинтервале: 1 ⩽ a < 10, т.е. все
 * числа (кроме 0), начинаются с 1
 *   + поэтому для 0 есть отдельный признак (бит)*/


/* ДРУГИМИ СЛОВАМИ или ПРИМЕР 32-БИТОВОГО ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ
 * - напр, 5 (в 10-чной) = 101 (в 2-чной) = 1.01e2 (с плавающей точкой), где:
 *      + 1.01 - мантисса, 1. опускаем
 *      + 2 порядок (степень, т.е. на сколько сдвинута точка влево) = 0000_0010
 *      + чтобы порядок был неотрицательным, нужно прибавить к нему 127 (нахуя?):
 *          + 0000_0010 (2) +
 *          + 0111_1111 (127) =
 *          + 1000_0001 (129)
 *      + получаем: 0(знак 1 бит)_10000001(порядок 8 бит)_01000000000000000000000(мантисса 23 бита)
 *
 * - напр, 2.5 (в 10-чной) = 1.01 (в 2-чной) = 1.01e1 (с плавающей точкой), где:
 *      + 1.01 - мантисса 1. опускаем
 *      + 1 порядок (степень, т.е. на сколько сдвинута точка влево) = 0000_0001
 *      + чтобы порядок был неотрицательным, нужно прибавить к нему 127 (нахуя?):
 *          + 0000_0001 (1) +
 *          + 0111_1111 (127) =
 *          + 1000_0000 (129)
 *      + получаем: 0(знак 1 бит)_10000000(порядок 8 бит)_01000000000000000000000(мантисса 23 бита)
 *
 * - т.е. чтобы из 0_10000001_01000000000000000000000 обратно получить 5:
 *      + знаковый бит - число положительное
 *      + порядок 10000001 = 129, отнять 127 = 2
 *      + мантисса 01000000000000000000000 или 01, и добавить 1. вначале, т.е. 1.01
 *      + получаем 1.01e2 = 101 = 5*/


/* ДОГОВОРЕННОСТЬ О ПРЕДСТАВЛЕНИИ НУЛЕЙ, БЕСКОНЕЧНОСТЕЙ И НЕОПРЕДЕЛЕННОСТИ
 * - т.е. из-за первого обязательного бита невозможно записать 0, поэтому договорились представлять:
 *      + 0 как минимальное значение порядка (-128) и мантисса 0 (при этом может быть положительным
 *          или отрицательным - поэтому при делении на какой-то 0 получим соотв. бесконечность)
 *      + бесконечность как максимальное значение порядка (127) и мантисса 0 (при этом может быть
 *          положительной или отрицательной)
 *      + неопределенность как максимальное значение порядка (127) и мантисса НЕ 0. При этом одна
 *          неопределенность может быть не равна другой.
 *
 * - эти значения существуют для того, чтобы в случае возникновения ошибок, например, арифметического
 * переполнения, извлечения квадратного корня из отрицательного числа и деления на 0, можно было
 * получить результат, представленный в диапазоне значений с плавающей точкой.*/


/*МАШИННЫЙ ЭПСИЛОН
 * - сетка чисел, которые способна отобразить арифметика с плавающей запятой, неравномерна: она более
 * густая для чисел с малыми порядками и более редкая — для чисел с большими порядками
 * - относительная погрешность записи чисел одинакова и для малых чисел, и для больших
 * - машинный эпсилон наименьшее положительное число ε такое, что 1 + ε != 1 (грубо говоря, числа
 * a и b, соотносящиеся так, что 1 < a/b < 1 + ε, машина не различает
 * - для одинарной точности (7 значащих цифр): ε = 2^-24 или примерно 5.96 * 10^-8
 * - для двойной (15 значащих цифр): ε = 2^-53 или примерно 1.11.* 10^-16*/


/* РАСШИРЕННЫЕ ФОРМАТЫ ТОЧНОСТИ
 * - рекомендованы для обеспечения большей точности, чем базовые форматы
 * - позволяет пользователю задавать параметры b, p и emax
 * - т.е. BigDecimal (?) */


/*~~~~~~ОСОБЕННОСТИ ИСПОЛЬЗОВАНИЯ~~~~~~*/

/* РАБОТА С БЕСКОНЕЧНОСТЬЮ И НЕОПРЕДЕЛЕННОСТЬЮ
 * ВЫРАЖЕНИЕ	                        РЕЗУЛЬТАТ
 * Math.sqrt(-1.0)	                -> NaN
 * 0.0 / 0.0	                    -> NaN
 * 1.0 / 0.0	                    -> бесконечность
 * -1.0 / 0.0	                    -> -бесконечность
 * NaN + 1.0	                    -> NaN
 * бесконечность + 1.0	            -> бесконечность
 * бесконечность + бесконечность	-> бесконечность
 * NaN > 1.0	                    -> ложь
 * NaN == 1.0	                    -> ложь
 * NaN < 1.0	                    -> ложь
 * NaN == NaN	                    -> ложь
 * 0.0 == -0.01	                    -> истина (хотя мне дает false)*/


/* КЛАССЫ-ОБЕРТКИ ВЕДУТ СЕБЯ ИНАЧЕ
 * - у float NaN не равны, у Float - равны (иначе будет невозможно использовать NaN объект
 * Float в качестве ключа в HashMap)
 * - у float 0 и -0 равны, у Float - нет (-0 меньше 0)*/


/*ОШИБОЧНЫЕ ПРЕДСТАВЛЕНИЯ
 * Данное выражение...	не обязательно тождественно...	при условии, что...
 * 0.0 - f	                        -f	                    f равно 0
 * f < g	                    ! (f >= g)	            f или g являются NaN
 * f == f	                        верно	                f является NaN
 * f + g - g	                     f	            g является бесконечностью или NaN*/


/*ОШИБКИ ОКРУГЛЕНИЯ
 * Операции над числами с плавающей точкой могут привести к ошибкам округления, выдавая результат,
 * близкий - но не равный - тому результату, который можно было ожидать (из-за того, что некоторые
 * значения нельзя представить в двоичной форме)*/


/* ДЛЯ СРАВНЕНИЯ ЛУЧШЕ ИСПОЛЬЗОВАТЬ ЭПСИЛОН
 * - сравнивать абсолютное значение их разности с каким-либо предварительно выбранным значением
 * эпсилон
 * - т.е. сравнивать насколько числа "близки"
 * - (если не известен коэффициент масштабирования основных измерений, то использование проверки
 * "abs(a/b - 1) < эпсилон", вероятно, будет более надежным, чем простое сравнение разности.)*/


/*Неупорядоченность NaN увеличивает вероятность появления ошибок при сравнении чисел с плавающей
точкой. Хорошим практическим приемом для предотвращения многих сбоев, связанных с бесконечностью и
NaN при сравнении чисел с плавающей точкой, является явная проверка валидности значения, вместо
попыток исключения невалидных значений. В листинге 1 присутствуют две возможных реализации схемы
настройки для свойства, которое может принимать только неотрицательные значения. В первом случае
будет допустим NaN, во втором - нет. Вторая форма является более предпочтительной, так как она явно
проверяет ту область значений, которую Вы считаете валидной.

Листинг 1. Лучшие и худшие способы для обеспечения неотрицательного плавающего значения
// Trying to test by exclusion - this doesn't catch NaN or infinity
public void setFoo(float foo) {
  if (foo < 0)
      throw new IllegalArgumentException(Float.toString(f));
    this.foo = foo;
}

// Testing by inclusion - this does catch NaN
public void setFoo(float foo) {
  if (foo >= 0 && foo < Float.INFINITY)
    this.foo = foo;
  else
    throw new IllegalArgumentException(Float.toString(f));
}*/


/*Некоторые нецелые значения, например десятичные дроби в стоимостном выражении (долларо-центы),
требуют точности. Числа с плавающей точкой не являются точными, и манипулирование ими приведет к
ошибкам округления. В общем, не очень хорошо использовать плавающую точку для представления таких
точных величин, как денежные суммы. Использование плавающей точки для вычислений стоимости является
решением данной проблемы. Числа с плавающей точкой лучше всего приберечь для таких значений,
например измерения, где величины являются изначально неточными.*/


public class __Floating_Ieee754 {

    static float floatA;
    static double doubleA;
    static float floatA1;
    static Float floatB;
    static Float floatB1;

    public static void main(String[] args) {
        /*ПРИМЕР 32-БИТНЫХ ЧИСЕЛ С ПЛАВАЮЩЕЙ ТОЧКОЙ*/
        floatA = 0f; // 0
        floatA = 1f; // 0011_1111_1000_0000_0000_0000_0000_0000
        floatA = 0.1f; // 0011_1101_1100_1100_1100_1100_1100_1101
        floatA = 5f; // 0100_0000_1010_0000_0000_0000_0000_0000
        floatA = 2.5f; // 0100_0000_0010_0000_0000_0000_0000_0000


        /* РАБОТА С БЕСКОНЕЧНОСТЬЮ И НЕОПРЕДЕЛЕННОСТЬЮ */
        System.out.println(Math.sqrt(-1.0)); // NaN
        System.out.println(0.0 / 0.0); // NaN
        System.out.println(1.0 / 0.0); // Infinity
        System.out.println(-1.0 / 0.0); // -Infinity
        System.out.println(Float.NaN + 1.0); // NaN
        System.out.println(Float.POSITIVE_INFINITY + 1.0); // Infinity
        System.out.println(Float.POSITIVE_INFINITY + Float.POSITIVE_INFINITY); // Infinity
        System.out.println(Float.NaN > 1.0); // false
        System.out.println(Float.NaN == 1.0); // false
        System.out.println(Float.NaN < 1.0); // false
        System.out.println(Float.NaN == Float.NaN); // false
        System.out.println(0.0 == -0.01); // false (хотя писали, что true)


        /*КЛАССЫ-ОБЕРТКИ ВЕДУТ СЕБЯ ИНАЧЕ
         * - у float NaN не равны, у Float - равны (иначе будет невозможно использовать NaN объект
         * Float в качестве ключа в HashMap)
         * - у float 0 и -0 равны, у Float - нет (-0 меньше 0)*/
        /*СРАВНЕНИЕ NaN*/
        floatA = Float.NaN;
        floatA1 = Float.NaN;
        System.out.println(floatA == floatA1); // false
        floatB = Float.NaN;
        floatB1 = Float.NaN;
        System.out.println(floatB.equals(floatB1)); // true

        /*СРАВНЕНИЕ +0 и -0*/
        floatA = 0;
        floatA1 = -0;
        System.out.println(floatA == floatA1); // true
        floatB = 0f;
        floatB1 = -0f;
        System.out.println(floatB.equals(floatB1)); // false
        System.out.println(floatB.compareTo(floatB1)); // 1, т.е. больше


        /*ОШИБОЧНЫЕ ПРЕДСТАВЛЕНИЯ
         * Данное выражение...	не обязательно тождественно...	при условии, что...
         * 0.0 - f	                        -f	                    f равно 0
         * f < g	                    ! (f >= g)	            f или g являются NaN
         * f == f	                        верно	                f является NaN
         * f + g - g	                     f	            g является бесконечностью или NaN*/



        /* ОШИБКИ ОКРУГЛЕНИЯ
         * - некоторые значения нельзя точно представить в бинарном виде*/
        floatA = 0f;
        for (int i = 0; i < 10; i++) {
            floatA += 0.1;
            System.out.println(floatA);
        }
        /* 0.1
         * 0.2
         * 0.3
         * 0.4
         * 0.5
         * 0.6
         * 0.70000005
         * 0.8000001
         * 0.9000001
         * 1.0000001*/

        doubleA = 29 * 0.01;
        System.out.println(doubleA); // 0.29
        System.out.println((int) (doubleA * 100)); // 28

    }
}
