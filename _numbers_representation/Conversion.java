package _numbers_representation;

/*ПЕРЕВОД ЦЕЛЫХ ЧИСЕЛ
 * - из 10-тичной в 2-ичную (напр. 47):
 *       47 / 2 = 23 + остаток 1 --->      1
 *       23 / 2 = 11 + остаток 1 --->     11
 *       11 / 2 = 5  + остаток 1 --->    111
 *       5  / 2 = 2  + остаток 1 --->   1111
 *       2  / 2 = 1    остаток 0 ---> 101111 (и 1, т.к. ее не поделишь)
 *
 * - из 10-тичной в 16-ричную (напр. 3060)
 *      3060 / 16 = 191   + остаток 4     --->    4
 *      191  / 16 = 11(B) + остаток 15(F) --->  BF4 */


/*ПЕРЕВОД ДРОБНЫХ ЧИСЕЛ
 * - из 10-тичной в 2-ичную (0.273)
 *       0.273 * 2 = 0.546 (единицы нет)           ---> 0.0
 *       0.546 * 2 = 1.092 (единица есть, забрали) ---> 0.01
 *       0.092 * 2 = 0.184 (единицы нет)           ---> 0.010
 *       0.184 * 2 = 0.368 (единицы нет)           ---> 0.0100
 *       0.368 * 2 = 0.736 (единицы нет)           ---> 0.01000
 *       0.736 * 2 = 1.472 (единица есть, забрали) ---> 0.010001
 *       0.472 * 2 = 0.944 (единицы нет)           ---> 0.0100010
 *       0.944 * 2 = 1.888 (единица есть, забрали) ---> 0.01000101
 *       0.888 * 2 = 1.776 (единица есть, забрали) ---> 0.010001011
 *       0.776 * 2 = 1.552 (единица есть, забрали) ---> 0.0100010111...
 *       ... продолжать пока не останется 0 или не будет достигнута требуемая точность числа*/


/* ПЕРЕВЕСТИ ЧИСЛО В ОТРИЦАТЕЛЬНОЕ
 * - см. ДОПОЛНИТЕЛЬНЫЙ КОД
 * - инверсия битов
 * - добавить 1 бит
 *   0 010 1010 - 42
 *   1 101 0101 - инверсия
 *   1 101 0110 - добавление 1 бита*/


/*ПЕРЕВЕСТИ ЧИСЛО ОБРАТНО В ПОЛОЖИТЕЛЬНОЕ
 * - инверсия битов
 * - добавить 1 бит
 * 1 101 0110 = -42
 * 0 010 1001 = инверсия
 * 0 000 0001 = добавляем 1 бит
 * 0 010 1010 = получаем обратно 42 */

public class Conversion {
}
