package _oop_inheritance;

import _types_references_annotations.my_annotations.Ntrstn;


/* ЗАЧЕМ
 * - super:
 *      - помогает обратится к нужному члену родительского класса при сокрытии
 * - super():
 *      - вызов родительского конструктора */


/* ЯВЛЯЕТСЯ НЕСТАТИЧЕСКОЙ ПЕРЕМЕННОЙ
 * - на нее нельзя ссылаться из статического контекста
 * - как и this */


/* НЕ ЯВЛЯЕТСЯ ССЫЛКОЙ НА ОБЪЕКТ
 * - только сообщает компилятору, что нужно сделать вызов из родителя
 * - в отличие от this */


@Ntrstn("Как и this, super используется в 2 целях: 1 - внутри метода или конструктора, чтобы " +
        "ссылаться на объект родительского класса; 2 - внутри конструктора для вызова родительского " +
        "конструктора")

@Ntrstn("Использование super внутри метода или конструктора: часто, чтобы избежать затемнения имени " +
        "поля или метода, унаследованного от родителся. Как и this, нельзя использовать в " +
        "статическом контексте. Но, в отличие от this, super не является ссылкой на родительский " +
        "объект! Т.е. по ней нельзя присвоить объект родительского класса другой ссылке - она только " +
        "сообщает, что нужно сделать вызов из родителя.")

@Ntrstn("Использование super внутри конструктора наследника идентично this - после super должы быть " +
        "скобки, должно идти первым в теле конструктора, является взаимоисключающим с this и в " +
        "конструктор нельзя передавать поля экземпляра, т.к. они еще не созданы")


class ParentSuper {
    int parentSuperField;
}

class ChildSuper extends ParentSuper {
    /* ОБРАЩЕНИЕ К РОДИТЕЛЬСКОМУ ЧЛЕНУ ПРИ СОКРЫТИИ */
    int parentSuperField = super.parentSuperField;


    /* ВЫЗОВ РОДИТЕЛЬСКОГО КОНСТРУКТОРА */
    public ChildSuper() {
        super();
    }


    /* ЯВЛЯЕТСЯ НЕСТАТИЧЕСКОЙ ПЕРЕМЕННОЙ КАК И THIS*/
    static void staticChildSuperMeth() {
//        int parentSuperField2 = super.parentSuperField; // вызов из статического контекста запрещен
//        int parentSuperField2 = this.parentSuperField; // вызов из статического контекста запрещен
    }


    void childSuperMeth() {
        Object o = new Object();
        /* НЕ ЯВЛЯЕТСЯ ССЫЛОЧНОЙ ПЕРЕМЕННОЙ В ОТЛИЧИЕ ОТ THIS */
//        o = super;
        o = this; // this является ссылочной переменной
    }
}

public class Super {
}