package __ClassLoaders_Initialization;

/* ТИПЫ ИНИЦИАЛИЗАЦИИ
 * - в месте объявления:
 * - в конструкторе (обычно)
 * - в инициализационном блоке (статическом и простом)*/


/* ПОРЯДОК ИНИЦИАЛИЗАЦИИ
 * 1. Инициализация полей в месте объявления и/или в инициализационном блоке происходит до
 * инициализации в конструкторе
 *
 * 2. Инициализация полей в месте объявления и в инициализационных блоках выполняются в порядке их
 * объявления в классе
 *
 * 3. Инициализация полей родительского класса происходит полностью до инициализации подкласса, т.е.
 * сначала выполняются все инициализаторы родительского класса, а потом все инициализаторы
 * производного подкласса*/


/* ПОРЯДОК СТАТИЧЕСКОЙ ИНИЦИАЛИЗАЦИИ
 * - выполняется БЕЗ (до) создания экземпляра класса
 * - по тем же правилам, что для обычных полей*/


/* ФИНАЛИЗИРОВАННОЕ ПОЛЕ
 * - обязательно должно быть инициализировано
 * - если статическое:
 *      - либо в месте объявления
 *      - либо в статическом инициализационном блоке
 *
 * - если нестатическое:
 *      - либо в месте объявления
 *      - либо в простом инициализационном блоке
 *      - либо в конструкторе */


import types_references_annotations.my_annotations.Ntrstn;

@Ntrstn("Если класс еще не был загружен, при получении его переменной через метод Class.forName(), " +
        "он будет загружен, но при обращении к его переменной класса через .class (альтернатива " +
        "Class.forName()) - нет")


/*СНАЧАЛА ПРОИСХОДИТ ИНИЦИАЛИЗАЦИЯ ПОЛЕЙ (В Т.Ч. СТАТИЧЕСКИХ) РОДИТЕЛЯ*/
class InitializationParent {
    /* ИНИЦИАЛИЗАЦИЯ В МЕСТЕ ОБЪЯВЛЕНИЯ
     * - происходит в порядке объявления
     * - происходит до инициализации в конструкторе
     * - статическое элементы инициализируется до создания экземпляра
     *      - к ним уже есть доступ*/
    int field = 10;
    final int finalField = 12; // обязательная инициализация финализированной переменной
    static int staticField = 11;


    /* ИНИЦАЛИЗАЦИЯ В БЛОКЕ
     * - происходит в порядке объявления
     * - происходит до инициализации в конструкторе
     * - статический блок выполняется до создания экземпляра */
    final int finalField2; // обязательная инициализация финализированной переменной

    {
        System.out.println("В простом инициализационном блоке родителя");
        System.out.println("Здесь есть доступ ко всему статическому и ко всему, объявленному выше");
        finalField2 = 12;
    }

    final static int staticFinalField; // обязательная инициализация финализированной переменной

    static {
        System.out.println("В статическом инициализационном блоке родителя");
        System.out.println("Здесь есть доступ ко всему статическому родителей и всему статическому, " +
                "объявленному выше");
        staticFinalField = 11;
    }


    final int finalField3; // обязательная инициализация финализированной переменной

    /*ИНИЦИАЛИЗАЦИЯ В КОНСТРУКТОРЕ
     * - выполняется в последнюю очередь*/
    public InitializationParent() {
        System.out.println("В конструкторе родителя");
        System.out.println("Здесь есть доступ ко всему статическому и ко всему своему нестатическому");
        finalField3 = 12;
    }
}


public class Initialization extends InitializationParent {
    {
        System.out.println("В простом инициализационном блоке ребенка");
        System.out.println("Здесь есть доступ ко всему статическому, ко всему родительскому и ко " +
                "всему, объявленному выше");
    }

    static {
        System.out.println("В статическом инициализационном блоке ребенка");
        System.out.println("Здесь есть доступ ко всему статическому родителей и всему статическому, " +
                "объявленному выше");
    }

    public Initialization() {
        System.out.println("В конструкторе ребенка");
        System.out.println("Здесь есть доступ ко всему статическому и нестатическому (своему и " +
                "родительскому)");
    }


    public static void main(String[] args) {
        new Initialization();
    }
}