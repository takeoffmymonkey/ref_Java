package oop_inheritance;

import _types_references_annotations.my_annotations.Ntrstn;

/* АБСТРАКЦИЯ ТРЕБУЕТ РЕАЛИЗАЦИИ ПЕРЕД ИСПОЛЬЗОВАНИЕМ
 * - определяется модификатором abstract */


/* ABSTRACT VS FINAL VS STATIC
 * - abstract:
 *      - классы: для создания объекта требуется реализация всех его абстрактных методов
 *          - при помощи переопределения
 *          - в случае с вложенным статическим - создание объекта не требуется
 *      - методы: требует объявления сущности как абстрактной
 *      - поля/переменные: не могут быть абстрактными
 *
 * - final:
 *      - классы: запрещает наследование класса
 *      - методы: при наследовании запрещает переопределение
 *      - поля/переменные: запрещают присваивание других значений или объектов
 *
 * - static:
 *      - классы: не используется с классами верхнего уровня
 *          - вложенные статические: ведет себя как класс верхнего уровня
 *          - не наследуются
 *      - методы:
 *          - доступны без экземпляра класса
 *          - не наследуются
 *      - поля:
 *          - доступны без экземпляра класса
 *          - не наследуются */


/* МОГУТ БЫТЬ АБСТРАКТНЫМИ:
 * - классы
 *      - нельзя создавать объект от абстрактного класса
 *          - можно создавать объект неабстрактного класса, который расширяет абстрактный класс
 *      - могут иметь неабстрактные члены
 *          - в т.ч. статические
 *              - т.к. для использования не нужен экземпляр
 *          - в т.ч. финализированные
 *              - т.е. напр. методы просто нельзя будет переопределять в наследнике
 *          - в т.ч. конструктор!
 *              - если нет недефолтного, итак используется дефолтный
 *              - вызов через super()
 *              - напр. для установления значений не абстрактных членов
 *      - могут не иметь абстрактных методов!
 *          - просто, чтобы запретить создание объектов
 *      - абстрактный класс не требует реализации всех методов интерфейса
 *          - но их должен реализовать неабстрактный наследник
 *      - классы верхнего уровня не могут быть одновременно абстрактными и статическими
 *          - статических классов верхнего уровня не бывает
 *      - не могут быть одновременно абстрактными и финализированными
 *          - т.к. это антонимы
 *
 * - методы
 *      - должен предоставить имплементацию в наследнике
 *      - класс должен быть объявлен абстрактным, если есть хоть 1 (нереализованный) абстрактный
 *      метод
 *          - в т.ч. нереализованный метод интерфейса
 *          - не относится к перечислению
 *              - здесь можно объявить абстрактный метод, не объявляя сам класс абстрактным
 *                  - но необходимо его реализовать в статических элементах этого же перечисления
 *      - абстрактные методы наследуются
 *          - т.е. 1 абстрактный класс может наследоваться другим абстрактным классом
 *              - и тогда неабстрактному классу нужно будет имплементировать абстрактные методы обоих
 *                  - в т.ч. абстрактные методы интерфейсов родителей, которые они не реализовали
 *      - статический метод не может быть абстрактным
 *          - т.к. не доступен для переопределения
 *      - финализированный метод не может быть абстрактным
 *          - т.к. запрещает переопределение */


/* НЕ МОГУТ/НЕ ДОЛЖНЫ БЫТЬ АБСТРАКТНЫМИ
 * - переменные
 *      - не бывают абстрактными
 *          - даже в интерфейсе они финализированы
 * - анонимные классы
 *      - т.к. у класса нет имени
 * - методы абстрактного класса в неабстрактном классе
 *      - иначе этот класс и сам должен быть объявлен абстрактным
 * - статические методы
 *      - метод будет не доступен для переопределения
 * - финализированные методы
 *      - запрещают переопределение
 * - финализированные классы
 *      - запрещают наследование
 * - конструкторы
 *      - неявно имеет реализацию
 *          - т.е. вызов super()
 * - интерфейсы
 *      - автоматически абстрактные
 * - методы интерфейса
 *      - автоматически абстрактные
 * - дефолтные методы интерфейса
 *      - должны предоставлять реализацию
 * - статические методы интерфейса
 *      - должны предоставлять реализацию
 * - поля интерфейса
 *      - автоматически финализированы
 * - перечисления
 *      - являются неявно финализированными
 *      - но может иметь абстрактный метод для дальнейшей реализиации в подклассе!*/


/* НЕРЕАЛИЗОВАННЫЕ МЕТОДЫ ИНТЕРФЕЙСА ВЕДУТ СЕБЯ КАК АБСТРАКТНЫЕ МЕТОДЫ
 * - т.е. также могут передаваться по наследству для реализации */


@Ntrstn("Абстрактных полей не бывает - даже в интерфейсе они финализированы")

@Ntrstn("Абстрактный класс может не содержать абстрактных методов, чтобы просто запретить создание " +
        "экземпляров")

@Ntrstn("Несмотря на то что перечисления являются неявно финализированными, они могут иметь " +
        "абстрактные методы для дальнейшей реализации в статических элементах этого же перечисления")

@Ntrstn("Абстрактный класс может не реализовать все абстрактные методы интерфейса - тогда это нужно " +
        "будет сделать в неабстрактном наследнике")

@Ntrstn("Абстрактный класс может иметь конструктор (итак имеет дефолтный), например для установки " +
        "неабстрактных значений")

@Ntrstn("Абстрактный вложенный класс может быть одновременно статическим (но унаследовать его можно " +
        "только внутри такого класса)!")

@Ntrstn("abstract несовместим c final в декларациях классов и методов: абстракция требует реализации, " +
        "а финализированность не позволяет наследовать класс или переопределять метод (где и должна " +
        "происходить требуемая реализация). abstract несовместим со static в декларациях методов, " +
        "т.к. метод будет существовать в единичном экземпляре и его невозможно переопределить. " +
        "Статические классы верхнего уровня запрещены, а вложенные статические классы могут быть " +
        "абстрактными, т.к. ведут себя как простые классы верхнего уровня, просто вложенные в другие " +
        "классы верхнего уровня для удобства, поэтому также допускают наследование. В то же время, " +
        "абстрактный класс может иметь статические или финализированные члены.")
/*~~~~~~~~~~~~~~~~~АБСТРАКТНЫЙ КЛАСС~~~~~~~~~~~~~~~~~*/
/* НЕ МОЖЕТ БЫТЬ FINAL*/
//abstract final class ParentAbstract {
//}


/* НЕ МОЖЕТ БЫТЬ STATIC*/
//abstract static class ParentAbstract {
//}


abstract class ParentAbstract {
    /* ВЛОЖЕННЫЙ КЛАСС МОЖЕТ БЫТЬ ОДНОВРЕМЕННО СТАТИЧЕСКИМ И АБСТРАКТНЫМ */
    abstract static class AbstactFinalClassInner {
        static int abstactFinalClassInnerStaticField; // есть доступ без экземпляра внешнего
        int abstactFinalClassInnerField2;
    }


    /* МОЖЕТ ИМЕТЬ НЕ АБСТРАКТНЫЕ ЧЛЕНЫ */
    int parentAbstractField;

    void parentAbstractNonAbstractMethod() {
    }

    class parentAbstractInner {
    }

    public ParentAbstract() { // имеет дефолтный конструктор
    }

    public ParentAbstract(int parentAbstractField) { // конструктор может устанавливать значения
        this.parentAbstractField = parentAbstractField;
    }

    class ChildConcrete extends ParentAbstract {
        public ChildConcrete() {
            super(4); // вызов родительского конструктора
            int val = parentAbstractField;
        }
    }


    /* МЕТОДЫ МОГУТ БЫТЬ СТАТИЧЕСКИМИ ИЛИ ФИНАЛИЗИРОВАННЫМИ */
    final static int parentAbstractStaticField = 0;

    final static void parentAbstractNonAbstractStaticMethod() {
    }

    final static class parentAbstractStaticInner {
    }


    /* НЕ МОГУТ БЫТЬ АБСТРАКТНЫМИ */
//    abstract int abstractClassField; // поля

//    abstract static void parentAbstractAbstractStaticMethod() { // статические методы
//    }

//    abstact final void parentAbstractAbstractStaticMethod() { // финализированные методы
//    }

//    abstract final class AbstactFinalClass { // финализированные классы
//    }

//    abstract public ParentAbstract() { // конструкторы
//    }

    abstract interface parentAbstractAbstractInterface {
        final int field = 0; // поля интерфейса неявно финализированы

        abstract void meth(); // методы интерфейса итак абстрактные

        default void meth2() { // дефолтный метод - есть реализация
        }

        static void meth3() { // статический метод - есть реализация
        }
    } // интерфейсы итак абстрактные


//    abstract enum parentAbstractAbstractEnum {} // является неявно финализированным


    /* ПЕРЕЧИСЛЕНИЕ МОЖЕТ ИМЕТЬ АБСТРАКТНЫЙ МЕТОД */
    enum parentAbstractEnum {
        ONE {
            public void abstractMeth() {
            }
        };

        abstract void abstractMeth();
    }


    /* МОЖЕТ НЕ СОДЕРЖАТЬ АБСТРАКТНЫХ МЕТОДОВ */


}

interface SomeInterface {
    void someMeth();
}

abstract class ParentAbstract2 implements SomeInterface {
    /* РЕАЛИЗАЦИЯ МЕТОДОВ НЕ ТРЕБУЕТСЯ, ЕСЛИ КЛАСС ОБЪЯВЛЕН КАК ABSTRACT*/
}


public class Abstract {
    public static void main(String[] args) {
        /*НЕЛЬЗЯ СОЗДАВАТЬ ЭКЗЕМПЛЯРЫ АБСТРАКТНОГО КЛАССА*/
//        new ParentAbstract();

        /* НО ЕСТЬ ДОСТУП К ЕГО СТАТИЧЕСКИМ ЧЛЕНАМ */
        int i2 = ParentAbstract.parentAbstractStaticField;

        /* НЕЛЬЗЯ СОЗДАВАТЬ ЭКЗЕМПЛЯРЫ АБСТРАКТНОГО СТАТИЧЕСКОГО ПОДКЛАССА */
//        new ParentAbstract.AbstactFinalClassInner(); // является статическим

        /* ЕСТЬ ДОСТУП К СТАТИЧЕСКИМ ПОЛЯМ СТАТИЧЕСКОГО АБСТРАКТНОГО ПОДКЛАССА */
        int i = ParentAbstract.AbstactFinalClassInner.abstactFinalClassInnerStaticField;

        /* ВНУТРЕННИЙ НЕЛЬЗЯ СОЗДАТЬ БЕЗ ЭКЗЕМЛПЯРА ВНЕШНЕГО КЛАССА */
//        new ParentAbstract.AbstactFinalClassInnerChild();
    }
}