package _generics;

import java.util.ArrayList;
import java.util.List;

import _types_references_annotations.my_annotations.Ntrstn;

/* МЕТАСИМВОЛ ОБОЗНАЧАЕТ ОПРЕДЕЛЕННОЕ СЕМЕЙСТВО НЕИЗВЕСТНЫХ ПАРАМЕТРОВ ТИПА ДЛЯ ЭКЗЕМПЛЯРА
 * ОБОБЩЕННОГО ТИПА
 * - т.е. в месте использования экземпляра его реальный параметр типа можно полностью или частично
 * игнорировать
 *      - зависит от того, указана ли граница для метасимвола
 *      - значит компилятор не знает реальный тип параметра
 *          - т.е. он абстрактен
 *          - поэтому даже 2 одинаковых реальных параметра типа для компилятора будут потенциально
 *          разными, если они скрыты метасимволом
 *              - все, что он знает - у них общий родитель Object
 *                  - или верхняя граница, если она указана
 *              - т.е. для компилятора 2 метасимвола скрывают 2 абслютно несвязанных объекта
 *                  - или частично связанных, если указана граница */


/* МЕТАСИМВОЛЫ НЕОБХОДИМЫ, ЧТОБЫ ОСЛАБИТЬ ИНВАРИАНТНОСТЬ ПАРАМЕТРА ТИПА У ОБОБЩЕНИЙ
 * - т.е. напр. в место, где требуется параметр типа <Number>, можно передать только <Number>
 *     - но метасимволом можно сменить инвариантность на:
 *          - ковариантность: можно также передавать наследников <Number> в качестве параметра типа
 *              - при помощи ограниченного сверху метасимвола
 *          - или контравариантность: можно также передавать родителей <Number> в качестве параметра
 *          типа
 *              - при помощи ограниченного снизу метасимвола */


/* ОГРАНИЧЕНИЯ У МЕТАСИМВОЛОВ
 * - виды:
 *      - неограниченный - <?>
 *          - сокращение от <? extends Object>
 *              - не путать с просто <Object>, куда можно добавлять объекты типа Object
 *                  - чего нельзя делать для <? extends Object> (см. ниже)
 *          - допускается, что у экземпляра обобщенного типа стоит абсолютно любой параметр типа
 *              - совместимость типов ссылок и реальных объектов работает по обычным правилам, а их
 *              скрытые неограниченным метасимволом параметры не сверяются
 *              - все параметризированные типы в экземпляре достаются только как Object
 *                  - т.к. любой реальный тип параметра типа при возвращении в мой код можно
 *                  безопасно привести только к Object
 *                     - т.е. upcasting - у реального типа точно есть методы Object
 *                  - у них доступны только методы Object
 *              - в экземпляр нельзя добавить никакой объект
 *                  - т.к. реальный тип может оказаться несовместим с ним
 *                      - т.е. я не могу передать Object в экземпляр, где реальный параметр типа
 *                      стоит Number
 *                          - т.е. downcasting - у Object нет всех методов реального типа (Number)
 *                  - только null
 *
 *      - ограниченный сверху - <? extends ...>
 *          - допускается, что у экземпляра обобщенного типа стоит параметр типа либо тот, что
 *          указан, либо все, что ниже его по иерархии
 *              - т.е. ковариантность
 *              - совместимость типов ссылок и реальных объектов работает по обычным правилам, а их
 *              скрытые ограниченным метасимволом параметры сверяются только на соответствие границе
 *              - для интерфейсов аналогичен implements
 *              - все параметризированные типы в экземпляре достаются с типом указанной границы
 *                  - т.к. любой реальный тип параметра типа гарантированно является наследником
 *                  граничного типа, а значит при возвращении в мой код он может без потерь быть
 *                  приведен к граничному типу
 *                      - т.е. upcasting - у реального типа точно есть методы граничного типа
 *                  - доступны все методы граничного типа
 *              - в экземпляр нельзя добавить никакой объект
 *                  - т.к. реальный тип может оказаться несовместим с ним
 *                      - т.е. если граница указана Number, то я не могу передать в экземпляр даже
 *                      Number, т.к. реальный параметр типа может быть Integer
 *                          - т.е. downcasting - у Number нет всех методов реального типа (Integer)
 *                  - только null
 *
 *      - ограниченный снизу - <? super ...>
 *          - допускается, что у экземпляра обобщенного типа стоит параметр типа либо тот, что
 *          указан, либо все, что выше его по иерархии
 *              - т.е. контравариантность
 *              - todo совместимость типов ссылок и реальных объектов работает по обычным правилам, а их
 *              скрытые ограниченным метасимволом параметры сверяются только на соответствие границе
 *              - все параметризированные типы в экземпляре достаются только как Object
 *                  - т.к. любой реальный тип параметра типа при возвращении в мой код можно
 *                  безопасно привести только к Object
 *                     - т.е. upcasting - у реального типа точно есть методы Object
 *                  - у них доступны только методы Object
 *              - в экземпляр можно добавить только объект граничного типа
 *                  - т.к. реальный тип гарантировано может быть совместим только с ним
 *                      - т.е. если граница указана Integer, я не могу передать в экземпляр Object,
 *                      т.к. реальный параметр типа может быть Number, и не могу передать Number,
 *                      так как реальным параметром может быть и Integer
 *                          - т.е. downcasting - у Object нет всех методов реального типа (Number),
 *                          у Number нет всех методов реального типа (Integer)
 *                      - но какой бы ни был реальный параметр, нижнюю границу всегда можно к нему
 *                      безопасно привести
 *                          - т.е. upcasting - у Integer точно есть методы и Number и Object
 *
 *      - т.е. неограниченный подразумевает больше типов, а ограниченный несет больше информации о
 *      типе
 *
 * - ограничение может быть указано только одно
 *
 * - границами могут быть только ссылочные типы, включая параметризированные типы, но не примитивы */


/* ДОПУСТИМЫЕ МЕСТА ИСПОЛЬЗОВАНИЯ МЕТАСИМВОЛОВ
 * - метасимвол используется в качестве аргумента типа у ссылки обобщенного типа
 *
 * - можно:
 *      - аргумент типа у ссылки обобщенного типа
 *          List<?> list = new ArrayList<String>();
 *      - аргумент типа у ссылки обобщенного типа, которая является параметром у метода
 *          void meth(List<?> list){}
 *      - возвращаемый тип у метода
 *          List<?> meth() {}
 *          - todo лучше быть более конкретным
 *      - (только неограниченный) аргумент типа у типа для оператора instanceof
 *          list instanceof List<?>;
 *          - параметр типа просто игнорируется JVM
 *      - (только неограниченный) аргумент типа для обобщенного массива
 *          List<?> [] lists = new List<?>[1];
 *          - можно добавить только null
 *
 * - нельзя:
 *      - todo аргумент типа у аргумента, передаваемого в обобщенный метод
 *          genericMeth(List<T> list) {} ...
 *          genericMeth(?);
 *      - определение обобщенного класса
 *          class Clazz <?> {}
 *      - передача аргумента типа обобщенному родительскому классу или имплементируемому интерфейсу
 *          class Clazz <T> extends SuperClazz <?> implements Comparable<?>{} */


/* ЗАПРЕТ НА СОЗДАНИЕ ОБЪЕКТА ОТ МЕТАСИМВОЛА, ВЫВЕДЕНИЕ ТИПА
 * - нельзя создавать объекты обобщенного типа
 *      ArrayList<?> list = new ArrayList<?>();
 *      - т.к. нужен конкретный тип, а он скрыт
 *          - следовательно, непонятно, что создавать
 *      - но можно:
 *          - создавать обобщенный массив с неограниченным метасимволом вместо параметра типа
 *              new Generic<?>[20];
 *              - в него все равно нельзя ничего добавить, кроме null
 *                  - т.е. JVM может не беспокоиться о загрезнении кучи
 *          - использовать метасимвол в качестве аргумента типа у аргумента типа, который
 *          указывается при создании обобщенного типа
 *              new List<List<?>>();
 *              - т.к. метасимвол не является аргументом типа, который передается самому объекту
 *              обобщенного типа, который создается
 *
 * - ссылке обобщенного типа можно назначить объект обобщенного типа, не указывая ему параметр типа
 * при создании
 *      ArrayList<?> list = new ArrayList<>();
 *      - тип будет выведен по верхней границе автоматически:
 *          - для неограниченного: Object
 *          - для ограниченного сверху: тип верхней границы
 *          - для ограниченного снизу: тип нижней границы */


/* ПОДХОДЯЩИЕ СЛУЧАИ ПРИМЕНЕНИЯ МЕТАСИМВОЛОВ В МЕТОДАХ
 * - все случаи применений основываются на лимитах, которые накладывают метасимволы:
 *      - возможность добавлять в экземпляр обобщенного типа объекты с типом, который скрыт или
 *      частично скрыт метасимволом
 *      - возможность получать из экземпляр обобщенного типа объекты с типом, который скрыт или
 *      частично скрыт метасимволом
 *      - доступность методов у полученных объектов из экземпляров обобщенного типа
 *
 * - неограниченный метасимвол:
 *      - т.к. в экземпляр обобщенного типа нельзя ничего добавить, а получать можно только объекты
 *      типа Object, то полученные объекты можно только проверять на null или работать с их методами,
 *      унаследованными от Object, или с методами самого экземпляра
 *          - т.е. можно применять только в довольно ограниченных функционально методах
 *
 * - ограниченный сверху метасимвол
 *      - т.к. в экземпляр обобщенного типа нельзя ничего добавить, но получить можно объекты
 *      граничного типа, то можно считывать объекты из экземпляра и пользоваться всеми доступными
 *      граничному типу методами
 *          - т.е. применять можно в методах, которые нужно ограничить на чтение объектов из
 *          экземпляров обобщенного типа
 *
 * - ограниченный снизу метасимвол
 *      - т.к. из экземпляра обобщенного кода можно получить только объекты типа Object, но можно
 *      добавить граничный тип, то можно свободно записывать объекты такого типа в экземпляр
 *          - т.е. применять можно в методах, которым можно позволить запись объектов из экземпляров
 *          обобщенного типа */


/* ПАРАМЕТРЫ ТИПА VS МЕТАСИМВОЛЫ В МЕТОДАХ
 * - взаимозаменяемость:
 *      - если у метода используется только 1 параметр типа
 *          - при этом сам тип неважен
 *
 * - различия:
 *      - если у метода используется несколько параметров типа, то в обобщенном методе их все можно
 *      родственно связать, указав для них одну и ту же переменную типа
 *          - метасимволы же никак не связаны между собой
 *      - у параметров типа могут быть несколько границ, а у метасимвола только 1
 *      - у метасимволов граница может быть или верхняя или нижняя, а у параметров типа только верхняя
 *
 * - т.е. метасимвол стоит использовать там, где от него не зависят другие аргументы и возвращаемое
 * значение, а параметр типа там - где такая зависимость имеется */


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ЗАХВАТ МЕТАСИМВОЛА~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * - когда в выражении происходит обращение к члену (напр. к методу) у экземпляра обобщенного типа,
 * тип параметра у которого скрыт метасимволом, компилятор все равно должен правильно выводить тип
 * передаваемый или возвращаемый таким методом, чтобы оценивать корректность выражения
 *      - для этого он привязывает скрытый метасимволом тип к конкретной (но анонимной) переменной
 *      типа:
 *          - т.н. переменная вхождения или capture
 *          - напр. объявлен Clazz<? super Number> clazz:
 *
 *              - при вызове метода clazz.get(), компилятор пытается вывести возвращаемый тип
 *                  - т.к. он неизвестен (скрыт метасимволом "? super Number"), он будет назначен в
 *                  анонимную переменную типа напр. "capture#1 of ? super Number"
 *                      - т.к. любой результат getter-метода у Clazz (даже типа "capture#1 of ? super
 *                      Number") можно безопасно привести только к Object, компилятор в итоге
 *                      определяет возвращаемый тип как Object
 *
 *              - при вызове метода clazz.set(object) или clazz.set(clazz.get()), компилятор пытается
 *              вывести тип, требуемый методу set
 *                  - т.к. он неизвестен (скрыт метасимволом "? super Number"), он будет обобзначен
 *                  новыми анонимными переменными типа, напр. "capture#2 of ? super Number" для
 *                  clazz.set(object) и "capture#3 of ? super Number" для clazz.set(clazz.get())
 *                      - т.к. записать через setter-метод у Clazz можно только тип, указанный как
 *                      нижняя граница метосимвола, то будут 2 одинаковые ошибки компиляции:
 *                      - Object cannot be converted to capture#2 of ? super Number
 *                      - Object cannot be converted to capture#3 of ? super Number
 *                          - поскольку результат clazz.get() также вычисляется как Object
 *
 *              - т.е. когда есть верхняя граница возвращаемый тип может быть вычислен в виде
 *              нормального типа и когда есть нижняя граница записываемый тип также может быть
 *              вычислен в виде нормального типа
 *                  - (а не анонимной переменной типа)
 *
 *              - т.е. правила иерархии у анонимных переменных типа такие же:
 *                  - у "capture#1 of ? extends Number" и "capture#2 of ? extends Number" точно общий
 *                  родитель Number (и выше)
 *                      - сами типы не совместимы
 *                          - т.к. могут быть любым из подтипов
 *
 *                  - у "capture#1 of ? super Number" и "capture#2 of ? super Number" точно общий
 *                  родитель только Object
 *                      - сами типы не совместимы
 *                          - т.к. могут быть любым из подтипов
 *
 * - для простого объявления этого не происходит, напр. может быть просто List<?>*/


/* HELPER-МЕТОД
 * - напр. нужен метод, который для экземпляра обобщенного класса с неизвестным параметром типа и у
 * которого внутри хранятся 2 объекта такого неизвестного типа, будет менять их местами
 *      - я не смогу это сделать, просто передав экземпляр класса в метод, если у метода в качестве
 *      параметра указан класс такого экземпляра, а в качестве параметра типа такого класса указан
 *      метасимвол, поскольку:
 *          - я не смогу сохранить 1 из объектов, прежде чем поменять их местами, т.к. я не могу
 *          создать переменную с таким типом - напр. "capture#1 of ?"
 *          - когда я получу первый объект через getter-метод, то он вернется как (напр.) Object, а
 *          setter-метод будет требовать "capture#2 of ?"
 *              - т.е. я не смогу ничего записать
 *
 * - выход - создать обобщенный метод, куда и передавать экземпляр класса с неизвестным параметром
 * типа
 *      - в таком случае обобщенный параметр типа у метода сможет захватить метасимвол
 *          - т.е. переменная типа будет уже не анонимной, а с именем (этого параметра) */


@Ntrstn("Метасимвол подразумевает, что параметр типа, переданный экземпляру обобщенного кода, для " +
        "которого стоит этот метасимвол, точно неизвестен (т.е. по сути абстрактен). Он " +
        "подразумевает какое-то неизвестное семейство типов параметров, возможное у этого экземпляра.")

@Ntrstn("Есть 3 вида метасимволов - неограниченный, ограниченный сверху и ограниченный снизу")

@Ntrstn("Метасимволы призваны ослабить жесткое правило совместимости у экземпляров обобщенных типов, " +
        "где для определения совместимости их параметры типа должны точно совпадать (т.н. " +
        "инвариантность). Указание верхней границы (extends (для интерфейса аналогичен implements)) " +
        "у метасимвола позволяет ослабить условие для параметра типа до ковариантности - т.е. " +
        "возможным типом в качестве параметра может быть не только указанная граница, но и ее " +
        "типы-наследники. А указание нижней границы (super) позволяет ослабить условие до " +
        "контравариантности - возможным параметром типа может быть не только указанная граница, но и " +
        "ее родители. Одновременно верхнюю и нижнюю границы указывать нельзя. Границами могут быть " +
        "только ссылочные типы, включая параметризированные типы, но не примитивы")

@Ntrstn("Совместимость типов ссылок и реальных обобщенных объектов работает по обычным правилам " +
        "обобщений, но их скрытые неограниченным метасимволом параметры не сверяются, а скрытые " +
        "ограниченными метасимволами параметры сверяются только на соответствие указанной границе")

@Ntrstn("Т.к. под метасимволом может скрываться любой тип из данного семейства, то компилятор видит " +
        "2 метасимвола как 2 отдельных типа, даже если на самом деле реальные типы параметров у " +
        "экземпляра обобщенного типа одинаковы. Все, что знает компилятор, что у этих типов родитель " +
        "Object (или другая верхняя граница, если она указана)")

@Ntrstn("Из экземпляров обобщенных типов, у которых в качестве параметра типа стоит ограниченный " +
        "сверху метасимвол, можно получать хранимые внутри обобщенные объекты с типом, который " +
        "указан как верхняя граница, т.к. какой бы ни был реальный параметр типа у экземпляра, он " +
        "должен быть наследником типа этой границы (или типа самой границы), поэтому получая объект " +
        "в мой код, он может быть безопасно приведен к типу указанной границы, т.к. все методы, " +
        "которые есть у граничного типа, должны быть и у него (upcast). В то же время добавить в " +
        "данный экземпляр ничего кроме null не получится, т.к. передаваемый внутрь тип может быть " +
        "выше реального параметра, установленного у этого экземпляра (ведь параметр типа может быть " +
        "и ниже указанной границы), поэтому нет гарантии, что у передаваемого объекта будут все " +
        "методы реального типа (т.н. downcast)")

@Ntrstn("Из экземпляров обобщенных типов, у которых в качестве параметра типа стоит ограниченный " +
        "снизу метасимвол, можно получать хранимые внутри обобщенные объекты только с типом Object. " +
        "Реальный тип может быть каким угодно от нижней границы до Object, поэтому если пытаться его " +
        "привести в моем коде к типу ниже его по иерархии, то это будет downcast - у него может не " +
        "быть требуемых методов. Т.е. существует только одна гарантия - у данного типа в родителях " +
        "точно есть Object. В то же время добавить в данный экземпляр обобщенного типа можно только " +
        "тип, указанный, как нижняя граница, т.к. какой бы ни был реальный тип параметра, у " +
        "передаваемого внутрь объекта, если он типа нижней границы, точно есть методы реального типа")

@Ntrstn("Неограниченный символ на самом деле является ограниченным сверху, просто этой границей " +
        "является тип Object. Важно не путать неограниченный метасимвол с аргументом типа Object! " +
        "В экземпляр обобщенного кода, у которого параметром стоит Object, можно добавлять объекты " +
        "типа Object, а в экземпляр, у которого параметром стоит неограниченный метасимвол нельзя " +
        "добавлять ничего, кроме null")

@Ntrstn("Метасимволы используются везде, где требуется аргумент типа для ссылки обобщенного типа, " +
        "кроме аргумента типа, передаваемого родительскому классу или имплементируемому интерфейсу, " +
        "а также аргумента типа, передаваемого обобщенному конструктору или методу. Неограниченный " +
        "метасимвол также можно использовать с оператором instanceof (никакого эффекта) и при " +
        "создании объекта обобщенного массива (но туда можно добавить только null, поэтому JVM не " +
        "нужно следить за загрязнением кучи)")

@Ntrstn("От метасимвола нельзя создавать объекты, т.е. использовать его вместо типа, аналогично " +
        "переменной типа (он ей не является - разве что анонимной). Исключением является только " +
        "создание обобщенного массива. Кроме того, можно использовать метасимвол в качестве " +
        "аргумента типа у аргумента типа, который указывается при создании обобщенного типа (new " +
        "List<ArrayList<?>>();), но в данном случае метасимвол указывается не для создаваемого " +
        "объекта (List<>)")

@Ntrstn("При создании обобщенного объекта, назначаемого обобщенной ссылке, у которой параметр типа " +
        "замещен метасимволом, конкретный параметр типа можно не передавать в конструктор - он будет " +
        "автоматически выведен из границы метасимвола (т.е. Object или другой тип, указанный как " +
        "верхняя или нижняя граница для метасимвола")

@Ntrstn("Все подходящие случаи применения метасимволов в методах основываются на лимитах, которые " +
        "накладывают эти метасимволы: т.е. возможность добавлять в экземпляр обобщенного типа " +
        "объекты с типом, который скрыт или частично скрыт метасимволом, возможность получать из " +
        "экземпляра обобщенного типа объекты с типом, который скрыт или частично скрыт метасимволом, " +
        "и доступность методов у полученных объектов из экземпляров обобщенного типа. Т.е. " +
        "неограниченный метасимвол можно использовать в функционально ограниченных методах - где " +
        "нужен доступ только к методам Object у полученного из экземпляра обобщенного типа объекта " +
        "или к методам самого обобщенного экземпляра, а также где достаточно только проверить объект " +
        "на null. Ограниченный сверху метасимвол можно использовать в методах, где доступ к элементам " +
        "экземпляра должен быть ограничен только на чтение. Ограниченный снизу метасимвол можно " +
        "использовать в методах, где необходимо только добавлять элементы в экземпляр")

@Ntrstn("Использование параметра типа в обобщенном методе и метасимвола в простом методе являются " +
        "взаимозаменяемым в случае, когда в метод передается только 1 параметр типа и этот тип не " +
        "нужно указывать отдельно как тип ссылки какого-то объекта (т.е. ? obj vs T obj). Но если " +
        "передается 2 параметра типа и между ними подразумевается родственная связь, то ее можно " +
        "обеспечить одной переменной типа в обобщенном методе, в то время метасимволы не являются " +
        "конкретными переменными типа и полностью различаются компилятором. Кроме того, для " +
        "параметра типа можно указать несколько границ, но нижних, а для метасимвола только одну, но " +
        "она может быть верхней или нижней.")

@Ntrstn("Т.к. компилятор оценивает (типовую) корректность каждого выражения, ему необходимо уметь " +
        "правильно выводить все типы, которые участвуют в выражении (простое объявление, напр. " +
        "List<?>, не является выражением). В выражениях, где происходит обращение к экземпляру " +
        "обобщенного типа, у которого параметр типа скрыт метасимволом, компилятор в процессе " +
        "выведения типа назначает такой неизвестный тип параметра в конкретную, но анонимную " +
        "переменную типа (напр. \"capture#1 of ? extends Number\" - т.н. переменная вхождения/" +
        "capture). Если в выражении происходит получение объекта скрытого типа из данного экземпляра, " +
        "то, зная, что из него можно вернуть только тип Object, компилятор автоматически выводит " +
        "возвращаемый в выражение тип как Object. В то же время если в выражении происходит передача " +
        "объекта внутрь экземпляра, то, во-первых, без нижней границы будет требоваться тип именно " +
        "присвоенной анонимной переменной, т.е. по сути ничего передать, кроме null, туда не " +
        "получится, а во-вторых, при указанной нижней границе компилятор сможет вывести ее в " +
        "нормальный тип - тот, который указан как нижняя граница. Т.е. нормальный (не анонимный) тип " +
        "может быть выведен при попытке получить объект, когда задана верхняя граница (или не задана " +
        "вообще) и при попытке добавить объект, когда задана нижняя граница")

@Ntrstn("При каждом использовании экземпляра обобщенного типа создается новая анонимная переменная " +
        "типа, с новым именем, поэтому 2 разные анонимные переменные типа не совместимы между собой. " +
        "Но у \"capture#1 of ? extends Number\" и \"capture#2 of ? extends Number\" точно общий " +
        "родитель Number и выше, а у \"capture#1 of ? super Number\" и \"capture#2 of ? super Number\" " +
        "общий родитель точно только Object")

@Ntrstn("Создание новой анонимной переменной типа при каждом обращении к членам экземпляра " +
        "обобщенного типа делает невозможным работу с 2 параметризированными объектами внутри " +
        "экземпляра такого типа. На самом деле у них 1 тип, установленный параметром типа, но " +
        "компилятор их видит как объекты разного типа. Чтобы обойти это ограничение, придется " +
        "создать обобщенный метод, в который нужно передать данный экземпляр обобщенного типа, а " +
        "параметр типа этого метода сможет удерживать тип, скрытый метасимволом, в простой " +
        "переменной типа, а не анонимной - и получать все объекты из этого класса с 1 типом")


class Usage {
    /* ~~~~~~~~~~~~~~~~~~~~~ГДЕ МОЖНО ИСПОЛЬЗОВАТЬ~~~~~~~~~~~~~~~~~~~~~ */
    List<? extends Number> field; // поле

    void method(List<? super Number> list) { // параметр метода
        List<?> local; // локальная переменная
    }

    List<?> method2() { // возвращаемое значение (не рекомендуется)
        return new ArrayList<>();
    }

    /*ТОЛЬКО НЕОГРАНИЧЕННЫЙ*/
    void unlimitedOnly() {
        ArrayList<?>[] list = new ArrayList<?>[1]; // создание массива неизвестного типа
        boolean b = new ArrayList<Integer>() instanceof ArrayList<?>; // проверка типа в runtime
    }


    /* ~~~~~~~~~~~~~~~~~~~~~ГДЕ НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ~~~~~~~~~~~~~~~~~~~~~ */
    <T> void genericMeth(List<T> list) {
//        genericMeth(?); // вызов обобщенного метода/конструктора

//        class Inner<?> {} // объявление обобщенного класса

//        class Par<T> { }
//        class Inner<T> extends Par<?> implements Comparable<?> { } // передача родителю или интерфейсу
    }


    /* ~~~~~~~~~~~~~~~~~~~~~НЕЛЬЗЯ СОЗДАВАТЬ ОБЪЕКТЫ ПО МЕТАСИМВОЛУ~~~~~~~~~~~~~~~~~~~~~ */
    void meth(ArrayList<?> arrayList) {
        /* РЕАЛЬНЫЙ ТИП НЕИЗВЕСТЕН */
//        ? t = new ArrayList<String>();
//        ArrayList<?> t = new ArrayList<?>();
//        ArrayList<? extends Number> t1 = new ArrayList<? extends Number>();
//        ArrayList<? super Number> t2 = new ArrayList<? super Number>();
        ArrayList<?>[] al = new ArrayList<?>[1];
//        ArrayList<? extends Number>[] all = new ArrayList<? extends Number>[1];
//        ArrayList<? super Number>[] all2 = new ArrayList<? super Number>[1];
        ArrayList<?> al2 = new ArrayList<ArrayList<?>>(); // не является аргументом для al2

        /* ВЫВЕДЕНИЕ ТИПА */
        ArrayList<?> l = new ArrayList<Object>();
        ArrayList<? extends Number> l2 = new ArrayList<Number>();
        ArrayList<? super Integer> l3 = new ArrayList<Integer>();
    }
}


/* ~~~~~~~~~~~~~~~~~~~~ ЗАХВАТ ПЕРЕМЕННОЙ ~~~~~~~~~~~~~~~~~~~~ */
class G2<T> {
    T ob;
    T ob2;

    public G2() {
    }

    public G2(T ob) {
        this.ob = ob;
    }

    public T getOb() {
        return ob;
    }

    public void setOb(T ob) {
        this.ob = ob;
    }

    public T getOb2() {
        return ob2;
    }

    public void setOb2(T ob2) {
        this.ob2 = ob2;
    }

    /*~~~~~~~~~~~~~~~~~~~~ЗАХВАТ МЕТАСИМВОЛА~~~~~~~~~~~~~~~~~~~~*/
    /* МЕТАСИМВОЛ ОГРАНИЧЕН СВЕРХУ - АНОНИМНАЯ ПЕРЕМЕННАЯ ТИПА - capture# of ? extends Number */
    static void captureExtends(G2<? extends Number> g) {
        /* РЕЗУЛЬТАТ GETTER-МЕТОДА ВЫВОДИТСЯ КОМПИЛЯТОРОМ КАК NUMBER */
        Number n = g.getOb(); // capture#1 of ? extends Number -> Number = OK
        Number n2 = g.getOb2(); // capture#2 of ? extends Number -> Number = OK
        Object o = g.getOb(); // capture#3 of ? extends Number -> Object = OK
        Object o2 = g.getOb2(); // capture#4 of ? extends Number -> Object = OK
//        Integer i = g.getOb2(); // capture#5 of ? extends Number -> Object = NOT OK
//        Integer i2 = g.getOb2(); // capture#6 of ? extends Number -> Object = NOT OK


        /* SETTER-МЕТОД НЕ МОЖЕТ НИЧЕГО ПРИНИМАТЬ */
//        g.setOb(o); // Object cannot be converted to capture#7 of ? extends Number
//        g.setOb2(o2); // Object cannot be converted to capture#8 of ? extends Number
//        g.setOb(n); // Number cannot be converted to capture#9 of ? extends Number
//        g.setOb2(n2); // Number cannot be converted to capture#10 of ? extends Number
//        g.setOb(g.getOb2()); // Number cannot be converted to capture#11 of ? extends Number
//        g.setOb2(g.getOb()); // Number cannot be converted to capture#12 of ? extends Number

    }


    /* МЕТАСИМВОЛ ОГРАНИЧЕН СВЕРХУ - АНОНИМНАЯ ПЕРЕМЕННАЯ ТИПА - capture# of ? super Number */
    static void captureSuper(G2 g) {
        /* РЕЗУЛЬТАТ GETTER-МЕТОДА ВЫВОДИТСЯ КОМПИЛЯТОРОМ КАК OBJECT */
//        Number n = g.getOb(); // capture#1 of ? super Number cannot be converted to Number
//        Number n2 = g.getOb2(); // capture#2 of ? super Number cannot be converted to Number
        Object o = g.getOb(); // capture#3 of ? super Number -> Object = OK
        Object o2 = g.getOb2(); // capture#4 of ? super Number -> Object = OK
//        Integer i = g.getOb2(); // capture#5 of ? super Number cannot be converted to Integer
//        Integer i2 = g.getOb2(); // capture#5 of ? super Number cannot be converted to Integer


        /* SETTER-МЕТОД МОЖЕТ ПРИНИМАТЬ ТОЛЬКО NUMBER */
//        g.setOb(o); // Object cannot be converted to capture#1 of ? super Number
//        g.setOb2(o2); // Object cannot be converted to capture#2 of ? super Number
        g.setOb(1); // Integer -> Number = OK
        g.setOb2(1); // Integer -> Number = OK
//        g.setOb(g.getOb2()); // Object cannot be converted to capture#3 of ? super Number
//        g.setOb2(g.getOb()); // Object cannot be converted to capture#4 of ? super Number
    }


    /* АНОНИМНЫЕ ПЕРЕМЕННЫЕ МЕЖДУ СОБОЙ НЕ СОВМЕСТИМЫ */
    static void captureHierarchySup(G2 g) {
        g.setOb(1);
//        g.setOb(new Object());

    }

    /* HELPER-МЕТОД */
    private static <T> void swapG2Helper(G2<T> g) {
        T t = g.getOb(); // спокойно достают обобщенные объекты из экземпляра
        T t2 = g.getOb2();
        g.setOb(t2); // и меняю их местами
        g.setOb2(t);
        G2 f = new G2();
        swapG2Helper(f);
    }
}


public class WildcardAndCapture {

    public static void main(String[] args) {
        /* ~~~~~~~~~~~~~КОНКРЕТНЫЕ ЭКЗЕМПЛЯРЫ G2 (ДЛЯ СРАВНЕНИЯ)~~~~~~~~~~~~~*/
        /* СОЗДАНИЕ ЭКЗЕМПЛЯРА ОБОБЩЕННОГО КЛАССА - УСТАНАВЛИВАЕТСЯ ПЕРЕДАННЫЙ ПАРАМЕТР ТИПА
         * - т.е. напр. в классе G2<Number> все Т меняются на Number */
        G2<Number> g = new G2<>(new Double(1.1)); // конструктор принимает Number и ниже
        G2<Integer> gI = new G2<>(new Integer(1)); // конструктор принимает Integer и ниже
        G2<Double> gD = new G2<>(new Double(1.0)); // конструктор принимает Double и ниже


        /* ПРИНИМАЕМЫЙ ТИП У ЭКЗЕМПЛЯРА - УСТАНОВЛЕННЫЙ ПАРАМЕТРОМ ТИПА И ЕГО НАСЛЕДНИКИ
         * - т.к. Т заменен на (напр.) Number, такой объект может хранить любые Number и наследников */
        g.setOb(2.1); // метод принимает Number и ниже
        gI.setOb(2); // метод принимает Integer и ниже
        gD.setOb(2.0); // метод принимает Double и ниже


        /* ВОЗВРАЩАЕМЫЙ ТИП У ЭКЗЕМПЛЯРА - ТОЛЬКО УСТАНОВЛЕННЫЙ ПАРАМЕТРОМ ТИПА
         * - т.к. T заменен на (напр.) Number, то при возвращении производится приведение к нему */
//        int i1 = (Integer) g.getOb(); // возвращаемое значение автоматически приводится к Number
        int i2 = gI.getOb(); // возвращаемое значение автоматически приводится к Integer
        double d1 = gD.getOb(); // возвращаемое значение автоматически приводится к Double


        /* ~~~~~~~~~~~~~КОНКРЕТНЫЕ ЭКЗЕМПЛЯРЫ G2, ГДЕ ПЕРЕДАННЫЙ АРГУМЕНТ НЕИЗВЕСТЕН~~~~~~~~~~~~~ */
        /* G2<?> - ЭТО КОНКРЕТНЫЙ ЭКЗЕМПЛЯР G2, НО НЕИЗВЕСТНО, КАКОЙ БЫЛ ПЕРЕДАН ПАРАМЕТР ТИПА
         * - т.е. то же, что и G2<? extends Object> */
        G2<?> gW = new G2<>(1);
        G2<?> gW1 = new G2<>("s");
        G2<? extends Object> gWObj = new G2<>(1);
        G2<? extends Object> gWObj1 = new G2<>("s");
        G2<Object> gObj = new G2<>(1); // НЕ ТО ЖЕ САМОЕ!
        G2<Object> gObj1 = new G2<>("s");


        /* G2<? extends Number> - ЭТО ЭКЗЕМПЛЯР G2, ГДЕ ИЗВЕСТНО, ЧТО ПАРАМЕТР ТИПА - NUMBER ИЛИ НИЖЕ
         * * - т.е. это может быть и G2<Number> и G2<Integer> и G2<Double> и т.д. */
        G2<? extends Number> gWUpLim = new G2<>(1);
        gWUpLim = new G2<Integer>(new Integer(1));
        gWUpLim = new G2<Double>(new Double(1.0));
//        gWUpLim = new G2<String>(new String ("s")); // нельзя - параметр типа точно не String


        /* G2<? super Integer> - ЭТО ЭКЗЕМПЛЯР G2, ГДЕ ИЗВЕСТНО, ЧТО ПАРАМЕТР ТИПА - ВЫШЕ INTEGER
         * * - т.е. это может быть G2<Integer> и G2<Number> и G2<Object> */
        G2<? super Integer> gWLowLim = new G2<>(1);
        gWLowLim = new G2<Integer>(1);
        gWLowLim = new G2<Integer>(new Integer(1));
        gWLowLim = new G2<Object>(new Object());
//        gWLowLim = new G2<Double>(1.0); // нельзя - Double не выше Integer


        /* ~~~~~~~~ПРИНИМАЕМЫЙ ТИП У ЭКЗЕМПЛЯРА - ТОТ, ЧТО УСТАНОВЛЕН КАК НИЖНЯЯ ГРАНИЦА~~~~~~~~*/
        /* КОГДА ГРАНИЦЫ НЕТ - РЕАЛЬНЫЙ ТИП МОЖЕТ БЫТЬ НЕ СОВМЕСТИМ С ПЕРЕДАВАЕМЫМ */
//        gW.setOb(new Object());
//        gW.setOb(new Integer(1));
//        gW.setOb(new Double(1.0));

        /* КОГДА УКАЗАНА ВЕРХНЯЯ ГРАНИЦА - РЕАЛЬНЫЙ ТИП МОЖЕТ БЫТЬ НЕ СОВМЕСТИМ С ПЕРЕДАВАЕМЫМ */
//        gWUpLim.setOb(new Object());
//        gWUpLim.setOb(new Integer(1));
//        gWUpLim.setOb(new Double(1.0));

        /* КОГДА УКАЗАНА НИЖНЯЯ ГРАНИЦА - РЕАЛЬНЫЙ ТИП МОЖЕТ БЫТЬ СОВМЕСТИМ ТОЛЬКО С НЕЙ */
//        gWLowLim.setOb(new Object()); // Object не совместим (безопасно) с реальной границей
        gWLowLim.setOb(new Integer(1)); // Integer совместим без потерь с реальной границей
//        gWLowLim.setOb(new Double(1.0)); // Double не связан иерархически с реальной границей
        gW.setOb(null); // null также работает


        /* ~~~~~~~~ВОЗВРАЩАЕМЫЙ ТИП У ЭКЗЕМПЛЯРА - ТОТ, ЧТО УСТАНОВЛЕН КАК ВЕРХНЯЯ ГРАНИЦА ИЛИ
        OBJECT, ЕСЛИ УСТАНОВЛЕНА НИЖНЯЯ ГРАНИЦА) ~~~~~~~~*/
        /* КОГДА УКАЗАНА ВЕРХНЯЯ ГРАНИЦА - РЕАЛЬНЫЙ ТИП ВСЕГДА СОВМЕСТИМ С ЭТОЙ ГРАНИЦЕЙ */
        Object o = gW.getOb(); // вернет Object, т.к. неявно граница Object
        Object o1 = gWUpLim.getOb(); // вернет Number, и может быть назначен в ссылку Object
//        Integer o2 = (Integer) gWUpLim.getOb(); // вернет Number, а для ссылки Integer нужно приведение

        /* КОГДА УКАЗАНА НИЖНЯЯ ГРАНИЦА - РЕАЛЬНЫЙ ТИП БЕЗОПАСНО СОВМЕСТИМ ТОЛЬКО С OBJECT*/
        Object o3 = gWLowLim.getOb(); // всегда вернет Object
        Number o4 = (Number) gWLowLim.getOb(); // всегда вернет Object
        Integer o5 = (Integer) gWLowLim.getOb(); // всегда вернет Object
    }
}